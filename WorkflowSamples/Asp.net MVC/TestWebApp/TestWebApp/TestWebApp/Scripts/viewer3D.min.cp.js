var IS_CONCAT_BUILD = !0,
    BUILD_LMV_WORKER_URL = "viewer3D.min.cp.js",
    LMV_WORKER_URL = BUILD_LMV_WORKER_URL,
    ENABLE_DEBUG = !1,
    ENABLE_TRACE = !1,
    ENABLE_INLINE_WORKER = !0;
AutodeskNamespace = function (a) {
    var b = this;
    a = a.split(".");
    for (var c = 0; c < a.length; ++c) b[a[c]] = b[a[c]] || {}, b = b[a[c]];
    return b
};
var _isIE11 = !!navigator.userAgent.match(/Trident\/7\./);
"undefined" !== typeof window && _isIE11 && function () {
    function a(a, c) {
        c = c || {
            bubbles: !1,
            cancelable: !1,
            detail: void 0
        };
        var e = document.createEvent("CustomEvent");
        e.initCustomEvent(a, c.bubbles, c.cancelable, c.detail);
        return e
    }
    a.prototype = window.CustomEvent.prototype;
    window.CustomEvent = a
}();
ArrayBuffer.prototype.slice || (ArrayBuffer.prototype.slice = function (a, b) {
    !b || b > this.byteLength ? b = this.byteLength : 0 > b && (b = this.byteLength + b, 0 > b && (b = 0));
    0 > a && (a = this.byteLength + a, 0 > a && (a = 0));
    if (b <= a) return new ArrayBuffer;
    for (var c = b - a, e = new Uint8Array(this, a, c), d = new Uint8Array(c), g = 0; g < c; g++) d[g] = e[g];
    return d.buffer
});
"undefined" !== typeof window && (window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder);

function launchFullscreen(a) {
    a.requestFullscreen ? a.requestFullscreen() : a.mozRequestFullScreen ? a.mozRequestFullScreen() : a.webkitRequestFullscreen ? a.webkitRequestFullscreen() : a.msRequestFullscreen && a.msRequestFullscreen()
}

function exitFullscreen() {
    document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.msExitFullscreen && document.msExitFullscreen()
}

function inFullscreen() {
    return document.fullscreenEnabled || document.mozFullScreenElement || document.webkitIsFullScreen || document.msFullscreenElement ? !0 : !1
}

function fullscreenElement() {
    return document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement
}

function isFullscreenAvailable(a) {
    return a.requestFullscreen || a.mozRequestFullScreen || a.webkitRequestFullscreen || a.msRequestFullscreen
};
/*
 Copyright (c) 2013 Autodesk Inc. */
AutodeskNamespace("Autodesk.Viewing");
Autodesk.Viewing.ERROR_EVENT = "error";
Autodesk.Viewing.ESCAPE_EVENT = "escape";
Autodesk.Viewing.PROGRESS_UPDATE_EVENT = "progress";
Autodesk.Viewing.FULLSCREEN_MODE_EVENT = "fullScreenMode";
Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT = "navmode";
Autodesk.Viewing.Viewer = function (a, b) {
    this.clientContainer = a;
    this.container = document.createElement("div");
    this.container.className = "viewer";
    this.container.style.height = "100%";
    this.container.style.width = "100%";
    this.container.style.overflow = "hidden";
    this.clientContainer.appendChild(this.container);
    this.listeners = {};
    this.config = b;
    this.screenModeDelegate = null;
    b && b.screenModeDelegate && (this.screenModeDelegate = new b.screenModeDelegate(this))
};
Autodesk.Viewing.Viewer.prototype = {
    initialize: function () {
        throw "void initialize() must be implemented.  For more details, read the Viewer class documentation.";
    },
    load: function (a, b) {
        throw "bool load(urn, function(void)) must be implemented.  For more details, read the Viewer class documentation.";
    }
};
Autodesk.Viewing.Viewer.prototype.uninitialize = function () {
    this.screenModeDelegate && (this.screenModeDelegate.uninitialize(), this.screenModeDelegate = null)
};
Autodesk.Viewing.Viewer.prototype.addEventListener = function (a, b) {
    "undefined" == typeof this.listeners[a] && (this.listeners[a] = []);
    this.listeners[a].push(b)
};
Autodesk.Viewing.Viewer.prototype.removeEventListener = function (a, b) {
    if (this.listeners[a] instanceof Array)
        for (var c = this.listeners[a], e = 0, d = c.length; e < d; e++)
            if (c[e] === b) {
                c.splice(e, 1);
                break
            }
};
Autodesk.Viewing.Viewer.prototype.fireEvent = function (a) {
    "string" == typeof a && (a = {
        type: a
    });
    a.target || (a.target = this);
    if (!a.type) throw Error("event type unknown.");
    if (this.listeners[a.type] instanceof Array)
        for (var b = 0, c = this.listeners[a.type].length; b < c; b++) this.listeners[a.type][b].call(this, a)
};
Autodesk.Viewing.Viewer.prototype.getDimensions = function () {
    if (this.container) {
        var a = {};
        this.getScreenMode() === this.ScreenMode.kFullScreen ? (a.width = screen.width, a.height = screen.height) : a = this.container.getBoundingClientRect();
        return {
            width: a.width,
            height: a.height
        }
    }
    return null
};
Autodesk.Viewing.Viewer.prototype.setViewFromArray = function (a) {};
Autodesk.Viewing.Viewer.prototype.setViewFromFile = function () {};
Autodesk.Viewing.Viewer.prototype.resize = function () {};
Autodesk.Viewing.Viewer.prototype.search = function (a, b) {};
Autodesk.Viewing.Viewer.prototype.ScreenMode = {
    kNormal: 0,
    kFullBrowser: 1,
    kFullScreen: 2
};
Autodesk.Viewing.Viewer.prototype.setScreenModeDelegate = function (a) {
    this.screenModeDelegate && this.screenModeDelegate.uninitialize();
    this.screenModeDelegate = a
};
Autodesk.Viewing.Viewer.prototype.getScreenModeDelegate = function () {
    this.screenModeDelegate || (this.screenModeDelegate = new Autodesk.Viewing.ViewerScreenModeDelegate(this));
    return this.screenModeDelegate
};
Autodesk.Viewing.Viewer.prototype.setScreenMode = function (a) {
    return this.getScreenModeDelegate().setMode(a)
};
Autodesk.Viewing.Viewer.prototype.getScreenMode = function () {
    return this.getScreenModeDelegate().getMode()
};
Autodesk.Viewing.Viewer.prototype.nextScreenMode = function () {
    var a = this.getScreenModeDelegate().getNextMode();
    return void 0 !== a ? this.setScreenMode(a) : !1
};
Autodesk.Viewing.Viewer.prototype.escapeScreenMode = function () {
    var a = this.getScreenModeDelegate().getEscapeMode();
    return void 0 !== a ? this.setScreenMode(a) : !1
};
Autodesk.Viewing.ScreenModeDelegate = function (a) {
    this.viewer = a
};
Autodesk.Viewing.ScreenModeDelegate.prototype = {
    uninitialize: function () {
        this.viewer = null
    },
    isModeSupported: function (a) {
        return !0
    },
    setMode: function (a) {
        return !1
    },
    getMode: function () {
        return Autodesk.Viewing.Viewer.ScreenMode.prototype.kNormal
    },
    getNextMode: function () {
        var a = this.getMode(),
            b;
        a === Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal && this.isModeSupported(Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser) ? b = Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser : a === Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal &&
            this.isModeSupported(Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen) ? b = Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen : a === Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser && this.isModeSupported(Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen) ? b = Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen : a === Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser && this.isModeSupported(Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal) ? b = Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal :
            a === Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen && this.isModeSupported(Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal) ? b = Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal : a === Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen && this.isModeSupported(Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser) && (b = Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser);
        return b
    },
    getEscapeMode: function () {
        var a = this.getMode(),
            b;
        if (a === Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser ||
            a === Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen) b = Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal;
        return b
    }
};
Autodesk.Viewing.ViewerScreenModeDelegate = function (a, b) {
    Autodesk.Viewing.ScreenModeDelegate.call(this, a);
    b || (b = a.container);
    this.element = b;
    var c = this;
    this.fullScreenEventListener = function (a) {
        inFullscreen() ? c._doScreenModeChange(Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen) : c._doScreenModeChange(Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal)
    };
    document.addEventListener("fullscreenchange", this.fullScreenEventListener, !1);
    document.addEventListener("mozfullscreenchange", this.fullScreenEventListener, !1);
    document.addEventListener("webkitfullscreenchange", this.fullScreenEventListener, !1);
    document.addEventListener("MSFullscreenChange", this.fullScreenEventListener, !1)
};
Autodesk.Viewing.ViewerScreenModeDelegate.prototype = Object.create(Autodesk.Viewing.ScreenModeDelegate.prototype);
Autodesk.Viewing.ViewerScreenModeDelegate.prototype.constructor = Autodesk.Viewing.ViewerScreenModeDelegate;
Autodesk.Viewing.ViewerScreenModeDelegate.prototype._doScreenModeChange = function (a) {
    var b = this.isModeSupported(Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser),
        c = this.isModeSupported(Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen);
    this.element.classList.remove("screenMode-kFullBrowser");
    this.element.classList.remove("screenMode-kFullScreen");
    switch (a) {
    case Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal:
        b && this.element.classList.remove("viewer-fill-browser");
        break;
    case Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser:
        b &&
            this.element.classList.add("viewer-fill-browser");
        c ? this.element.classList.add("screenMode-kFullBrowser") : this.element.classList.add("screenMode-kFullScreen");
        break;
    case Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen:
        b && this.element.classList.add("viewer-fill-browser");
        this.element.classList.add("screenMode-kFullScreen");
        break;
    default:
        throw new RangeError("Unexpected mode=" + a);
    }
    this.viewer.resize();
    this.viewer.fireEvent({
        type: Autodesk.Viewing.FULLSCREEN_MODE_EVENT,
        mode: a
    })
};
Autodesk.Viewing.ViewerScreenModeDelegate.prototype.uninitialize = function () {
    document.removeEventListener("fullscreenchange", this.fullScreenEventListener, !1);
    document.removeEventListener("mozfullscreenchange", this.fullScreenEventListener, !1);
    document.removeEventListener("webkitfullscreenchange", this.fullScreenEventListener, !1);
    document.removeEventListener("MSFullscreenChange", this.fullScreenEventListener, !1);
    this.element = null;
    Autodesk.Viewing.ScreenModeDelegate.prototype.uninitialize.call(this)
};
Autodesk.Viewing.ViewerScreenModeDelegate.prototype.setMode = function (a) {
    var b = this.getMode(),
        c = !1;
    a !== b && this.isModeSupported(a) && (b === Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser && a === Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal ? (this._doScreenModeChange(Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal), c = !0) : b === Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen && a === Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal ? (exitFullscreen(), c = !0) : b === Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal &&
        a === Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser ? (this._doScreenModeChange(Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser), c = !0) : b === Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser && a === Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen ? (launchFullscreen(this.element), c = !0) : b === Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal && a === Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen && (launchFullscreen(this.element), c = !0));
    return c
};
Autodesk.Viewing.ViewerScreenModeDelegate.prototype.getMode = function () {
    var a = this.isModeSupported(Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser),
        b = a ? this.element.classList.contains("viewer-fill-browser") : !1;
    return inFullscreen() && fullscreenElement() === this.element ? Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen : a && b ? Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser : Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal
};
Autodesk.Viewing.ApplicationScreenModeDelegate = function (a, b) {
    b || (b = document.documentElement);
    Autodesk.Viewing.ViewerScreenModeDelegate.call(this, a, b)
};
Autodesk.Viewing.ApplicationScreenModeDelegate.prototype = Object.create(Autodesk.Viewing.ViewerScreenModeDelegate.prototype);
Autodesk.Viewing.ApplicationScreenModeDelegate.prototype.constructor = Autodesk.Viewing.ApplicationScreenModeDelegate;
Autodesk.Viewing.ApplicationScreenModeDelegate.prototype.isModeSupported = function (a) {
    return a !== Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser
};
var THREE = {
    REVISION: "66"
};
self.console = self.console || {
    info: function () {},
    log: function () {},
    debug: function () {},
    warn: function () {},
    error: function () {}
};
(function () {
    for (var a = 0, b = ["ms", "moz", "webkit", "o"], c = 0; c < b.length && !self.requestAnimationFrame; ++c) self.requestAnimationFrame = self[b[c] + "RequestAnimationFrame"], self.cancelAnimationFrame = self[b[c] + "CancelAnimationFrame"] || self[b[c] + "CancelRequestAnimationFrame"];
    void 0 === self.requestAnimationFrame && void 0 !== self.setTimeout && (self.requestAnimationFrame = function (b) {
        var d = Date.now(),
            c = Math.max(0, 16 - (d - a)),
            f = self.setTimeout(function () {
                b(d + c)
            }, c);
        a = d + c;
        return f
    });
    void 0 === self.cancelAnimationFrame && void 0 !==
        self.clearTimeout && (self.cancelAnimationFrame = function (a) {
            self.clearTimeout(a)
        })
})();
THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;
THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;
THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;
THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;
THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;
THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;
THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;
THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;
THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;
THREE.UVMapping = function () {};
THREE.CubeReflectionMapping = function () {};
THREE.CubeRefractionMapping = function () {};
THREE.SphericalReflectionMapping = function () {};
THREE.SphericalRefractionMapping = function () {};
THREE.RepeatWrapping = 1E3;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;
THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;
THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.HalfFloatType = 1099;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;
THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;
THREE.Color = function (a) {
    return 3 === arguments.length ? this.setRGB(arguments[0], arguments[1], arguments[2]) : this.set(a)
};
THREE.Color.prototype = {
    constructor: THREE.Color,
    r: 1,
    g: 1,
    b: 1,
    set: function (a) {
        a instanceof THREE.Color ? this.copy(a) : "number" === typeof a ? this.setHex(a) : "string" === typeof a && this.setStyle(a);
        return this
    },
    setHex: function (a) {
        a = Math.floor(a);
        this.r = (a >> 16 & 255) / 255;
        this.g = (a >> 8 & 255) / 255;
        this.b = (a & 255) / 255;
        return this
    },
    setRGB: function (a, b, c) {
        this.r = a;
        this.g = b;
        this.b = c;
        return this
    },
    setHSL: function (a, b, c) {
        if (0 === b) this.r = this.g = this.b = c;
        else {
            var e = function (a, b, f) {
                0 > f && (f += 1);
                1 < f && (f -= 1);
                return f < 1 / 6 ? a + 6 * (b - a) *
                    f : 0.5 > f ? b : f < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - f) : a
            };
            b = 0.5 >= c ? c * (1 + b) : c + b - c * b;
            c = 2 * c - b;
            this.r = e(c, b, a + 1 / 3);
            this.g = e(c, b, a);
            this.b = e(c, b, a - 1 / 3)
        }
        return this
    },
    setStyle: function (a) {
        if (/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(a)) return a = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(a), this.r = Math.min(255, parseInt(a[1], 10)) / 255, this.g = Math.min(255, parseInt(a[2], 10)) / 255, this.b = Math.min(255, parseInt(a[3], 10)) / 255, this;
        if (/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(a)) return a = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(a), this.r =
            Math.min(100, parseInt(a[1], 10)) / 100, this.g = Math.min(100, parseInt(a[2], 10)) / 100, this.b = Math.min(100, parseInt(a[3], 10)) / 100, this;
        if (/^\#([0-9a-f]{6})$/i.test(a)) return a = /^\#([0-9a-f]{6})$/i.exec(a), this.setHex(parseInt(a[1], 16)), this;
        if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(a)) return a = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a), this.setHex(parseInt(a[1] + a[1] + a[2] + a[2] + a[3] + a[3], 16)), this;
        if (/^(\w+)$/i.test(a)) return this.setHex(THREE.ColorKeywords[a]), this
    },
    copy: function (a) {
        this.r = a.r;
        this.g =
            a.g;
        this.b = a.b;
        return this
    },
    copyGammaToLinear: function (a) {
        this.r = a.r * a.r;
        this.g = a.g * a.g;
        this.b = a.b * a.b;
        return this
    },
    copyLinearToGamma: function (a) {
        this.r = Math.sqrt(a.r);
        this.g = Math.sqrt(a.g);
        this.b = Math.sqrt(a.b);
        return this
    },
    convertGammaToLinear: function () {
        var a = this.r,
            b = this.g,
            c = this.b;
        this.r = a * a;
        this.g = b * b;
        this.b = c * c;
        return this
    },
    convertLinearToGamma: function () {
        this.r = Math.sqrt(this.r);
        this.g = Math.sqrt(this.g);
        this.b = Math.sqrt(this.b);
        return this
    },
    getHex: function () {
        return 255 * this.r << 16 ^ 255 * this.g <<
            8 ^ 255 * this.b << 0
    },
    getHexString: function () {
        return ("000000" + this.getHex().toString(16)).slice(-6)
    },
    getHSL: function (a) {
        a = a || {
            h: 0,
            s: 0,
            l: 0
        };
        var b = this.r,
            c = this.g,
            e = this.b,
            d = Math.max(b, c, e),
            g = Math.min(b, c, e),
            f, k = (g + d) / 2;
        if (g === d) g = f = 0;
        else {
            var h = d - g,
                g = 0.5 >= k ? h / (d + g) : h / (2 - d - g);
            switch (d) {
            case b:
                f = (c - e) / h + (c < e ? 6 : 0);
                break;
            case c:
                f = (e - b) / h + 2;
                break;
            case e:
                f = (b - c) / h + 4
            }
            f /= 6
        }
        a.h = f;
        a.s = g;
        a.l = k;
        return a
    },
    getStyle: function () {
        return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
    },
    offsetHSL: function (a,
        b, c) {
        var e = this.getHSL();
        e.h += a;
        e.s += b;
        e.l += c;
        this.setHSL(e.h, e.s, e.l);
        return this
    },
    add: function (a) {
        this.r += a.r;
        this.g += a.g;
        this.b += a.b;
        return this
    },
    addColors: function (a, b) {
        this.r = a.r + b.r;
        this.g = a.g + b.g;
        this.b = a.b + b.b;
        return this
    },
    addScalar: function (a) {
        this.r += a;
        this.g += a;
        this.b += a;
        return this
    },
    multiply: function (a) {
        this.r *= a.r;
        this.g *= a.g;
        this.b *= a.b;
        return this
    },
    multiplyScalar: function (a) {
        this.r *= a;
        this.g *= a;
        this.b *= a;
        return this
    },
    lerp: function (a, b) {
        this.r += (a.r - this.r) * b;
        this.g += (a.g - this.g) * b;
        this.b += (a.b - this.b) * b;
        return this
    },
    equals: function (a) {
        return a.r === this.r && a.g === this.g && a.b === this.b
    },
    fromArray: function (a) {
        this.r = a[0];
        this.g = a[1];
        this.b = a[2];
        return this
    },
    toArray: function () {
        return [this.r, this.g, this.b]
    },
    clone: function () {
        return (new THREE.Color).setRGB(this.r, this.g, this.b)
    }
};
THREE.ColorKeywords = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
};
THREE.Quaternion = function (a, b, c, e) {
    this._x = a || 0;
    this._y = b || 0;
    this._z = c || 0;
    this._w = void 0 !== e ? e : 1
};
THREE.Quaternion.prototype = {
    constructor: THREE.Quaternion,
    _x: 0,
    _y: 0,
    _z: 0,
    _w: 0,
    _euler: void 0,
    _updateEuler: function (a) {
        void 0 !== this._euler && this._euler.setFromQuaternion(this, void 0, !1)
    },
    get x() {
        return this._x
    },
    set x(a) {
        this._x = a;
        this._updateEuler()
    },
    get y() {
        return this._y
    },
    set y(a) {
        this._y = a;
        this._updateEuler()
    },
    get z() {
        return this._z
    },
    set z(a) {
        this._z = a;
        this._updateEuler()
    },
    get w() {
        return this._w
    },
    set w(a) {
        this._w = a;
        this._updateEuler()
    },
    set: function (a, b, c, e) {
        this._x = a;
        this._y = b;
        this._z = c;
        this._w =
            e;
        this._updateEuler();
        return this
    },
    copy: function (a) {
        this._x = a._x;
        this._y = a._y;
        this._z = a._z;
        this._w = a._w;
        this._updateEuler();
        return this
    },
    setFromEuler: function (a, b) {
        if (!1 === a instanceof THREE.Euler) throw Error("ERROR: Quaternion's .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");
        var c = Math.cos(a._x / 2),
            e = Math.cos(a._y / 2),
            d = Math.cos(a._z / 2),
            g = Math.sin(a._x / 2),
            f = Math.sin(a._y / 2),
            k = Math.sin(a._z / 2);
        "XYZ" === a.order ? (this._x = g * e * d + c * f * k, this._y = c *
            f * d - g * e * k, this._z = c * e * k + g * f * d, this._w = c * e * d - g * f * k) : "YXZ" === a.order ? (this._x = g * e * d + c * f * k, this._y = c * f * d - g * e * k, this._z = c * e * k - g * f * d, this._w = c * e * d + g * f * k) : "ZXY" === a.order ? (this._x = g * e * d - c * f * k, this._y = c * f * d + g * e * k, this._z = c * e * k + g * f * d, this._w = c * e * d - g * f * k) : "ZYX" === a.order ? (this._x = g * e * d - c * f * k, this._y = c * f * d + g * e * k, this._z = c * e * k - g * f * d, this._w = c * e * d + g * f * k) : "YZX" === a.order ? (this._x = g * e * d + c * f * k, this._y = c * f * d + g * e * k, this._z = c * e * k - g * f * d, this._w = c * e * d - g * f * k) : "XZY" === a.order && (this._x = g * e * d - c * f * k, this._y = c * f * d - g * e * k,
            this._z = c * e * k + g * f * d, this._w = c * e * d + g * f * k);
        !1 !== b && this._updateEuler();
        return this
    },
    setFromAxisAngle: function (a, b) {
        var c = b / 2,
            e = Math.sin(c);
        this._x = a.x * e;
        this._y = a.y * e;
        this._z = a.z * e;
        this._w = Math.cos(c);
        this._updateEuler();
        return this
    },
    setFromRotationMatrix: function (a) {
        var b = a.elements,
            c = b[0];
        a = b[4];
        var e = b[8],
            d = b[1],
            g = b[5],
            f = b[9],
            k = b[2],
            h = b[6],
            b = b[10],
            l = c + g + b;
        0 < l ? (c = 0.5 / Math.sqrt(l + 1), this._w = 0.25 / c, this._x = (h - f) * c, this._y = (e - k) * c, this._z = (d - a) * c) : c > g && c > b ? (c = 2 * Math.sqrt(1 + c - g - b), this._w = (h - f) / c, this._x =
            0.25 * c, this._y = (a + d) / c, this._z = (e + k) / c) : g > b ? (c = 2 * Math.sqrt(1 + g - c - b), this._w = (e - k) / c, this._x = (a + d) / c, this._y = 0.25 * c, this._z = (f + h) / c) : (c = 2 * Math.sqrt(1 + b - c - g), this._w = (d - a) / c, this._x = (e + k) / c, this._y = (f + h) / c, this._z = 0.25 * c);
        this._updateEuler();
        return this
    },
    inverse: function () {
        this.conjugate().normalize();
        return this
    },
    conjugate: function () {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._updateEuler();
        return this
    },
    lengthSq: function () {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    },
    length: function () {
        return Math.sqrt(this._x *
            this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    },
    normalize: function () {
        var a = this.length();
        0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a);
        return this
    },
    multiply: function (a, b) {
        return void 0 !== b ? (console.warn("DEPRECATED: Quaternion's .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a)
    },
    multiplyQuaternions: function (a, b) {
        var c = a._x,
            e = a._y,
            d = a._z,
            g =
            a._w,
            f = b._x,
            k = b._y,
            h = b._z,
            l = b._w;
        this._x = c * l + g * f + e * h - d * k;
        this._y = e * l + g * k + d * f - c * h;
        this._z = d * l + g * h + c * k - e * f;
        this._w = g * l - c * f - e * k - d * h;
        this._updateEuler();
        return this
    },
    multiplyVector3: function (a) {
        console.warn("DEPRECATED: Quaternion's .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
        return a.applyQuaternion(this)
    },
    slerp: function (a, b) {
        var c = this._x,
            e = this._y,
            d = this._z,
            g = this._w,
            f = g * a._w + c * a._x + e * a._y + d * a._z;
        0 > f ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, f = -f) : this.copy(a);
        if (1 <= f) return this._w = g, this._x = c, this._y = e, this._z = d, this;
        var k = Math.acos(f),
            h = Math.sqrt(1 - f * f);
        if (0.001 > Math.abs(h)) return this._w = 0.5 * (g + this._w), this._x = 0.5 * (c + this._x), this._y = 0.5 * (e + this._y), this._z = 0.5 * (d + this._z), this;
        f = Math.sin((1 - b) * k) / h;
        k = Math.sin(b * k) / h;
        this._w = g * f + this._w * k;
        this._x = c * f + this._x * k;
        this._y = e * f + this._y * k;
        this._z = d * f + this._z * k;
        this._updateEuler();
        return this
    },
    equals: function (a) {
        return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w
    },
    fromArray: function (a) {
        this._x = a[0];
        this._y = a[1];
        this._z = a[2];
        this._w = a[3];
        this._updateEuler();
        return this
    },
    toArray: function () {
        return [this._x, this._y, this._z, this._w]
    },
    clone: function () {
        return new THREE.Quaternion(this._x, this._y, this._z, this._w)
    }
};
THREE.Quaternion.slerp = function (a, b, c, e) {
    return c.copy(a).slerp(b, e)
};
THREE.Vector2 = function (a, b) {
    this.x = a || 0;
    this.y = b || 0
};
THREE.Vector2.prototype = {
    constructor: THREE.Vector2,
    set: function (a, b) {
        this.x = a;
        this.y = b;
        return this
    },
    setX: function (a) {
        this.x = a;
        return this
    },
    setY: function (a) {
        this.y = a;
        return this
    },
    setComponent: function (a, b) {
        switch (a) {
        case 0:
            this.x = b;
            break;
        case 1:
            this.y = b;
            break;
        default:
            throw Error("index is out of range: " + a);
        }
    },
    getComponent: function (a) {
        switch (a) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw Error("index is out of range: " + a);
        }
    },
    copy: function (a) {
        this.x = a.x;
        this.y = a.y;
        return this
    },
    add: function (a,
        b) {
        if (void 0 !== b) return console.warn("DEPRECATED: Vector2's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
        this.x += a.x;
        this.y += a.y;
        return this
    },
    addVectors: function (a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this
    },
    addScalar: function (a) {
        this.x += a;
        this.y += a;
        return this
    },
    sub: function (a, b) {
        if (void 0 !== b) return console.warn("DEPRECATED: Vector2's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
        this.x -= a.x;
        this.y -=
            a.y;
        return this
    },
    subVectors: function (a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this
    },
    multiplyScalar: function (a) {
        this.x *= a;
        this.y *= a;
        return this
    },
    divideScalar: function (a) {
        0 !== a ? (a = 1 / a, this.x *= a, this.y *= a) : this.y = this.x = 0;
        return this
    },
    min: function (a) {
        this.x > a.x && (this.x = a.x);
        this.y > a.y && (this.y = a.y);
        return this
    },
    max: function (a) {
        this.x < a.x && (this.x = a.x);
        this.y < a.y && (this.y = a.y);
        return this
    },
    clamp: function (a, b) {
        this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
        this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
        return this
    },
    clampScalar: function () {
        var a, b;
        return function (c, e) {
            void 0 === a && (a = new THREE.Vector2, b = new THREE.Vector2);
            a.set(c, c);
            b.set(e, e);
            return this.clamp(a, b)
        }
    }(),
    floor: function () {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this
    },
    ceil: function () {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this
    },
    round: function () {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this
    },
    roundToZero: function () {
        this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = 0 > this.y ?
            Math.ceil(this.y) : Math.floor(this.y);
        return this
    },
    negate: function () {
        return this.multiplyScalar(-1)
    },
    dot: function (a) {
        return this.x * a.x + this.y * a.y
    },
    lengthSq: function () {
        return this.x * this.x + this.y * this.y
    },
    length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    },
    normalize: function () {
        return this.divideScalar(this.length())
    },
    distanceTo: function (a) {
        return Math.sqrt(this.distanceToSquared(a))
    },
    distanceToSquared: function (a) {
        var b = this.x - a.x;
        a = this.y - a.y;
        return b * b + a * a
    },
    setLength: function (a) {
        var b =
            this.length();
        0 !== b && a !== b && this.multiplyScalar(a / b);
        return this
    },
    lerp: function (a, b) {
        this.x += (a.x - this.x) * b;
        this.y += (a.y - this.y) * b;
        return this
    },
    equals: function (a) {
        return a.x === this.x && a.y === this.y
    },
    fromArray: function (a) {
        this.x = a[0];
        this.y = a[1];
        return this
    },
    toArray: function () {
        return [this.x, this.y]
    },
    clone: function () {
        return new THREE.Vector2(this.x, this.y)
    }
};
THREE.Vector3 = function (a, b, c) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0
};
THREE.Vector3.prototype = {
    constructor: THREE.Vector3,
    set: function (a, b, c) {
        this.x = a;
        this.y = b;
        this.z = c;
        return this
    },
    setX: function (a) {
        this.x = a;
        return this
    },
    setY: function (a) {
        this.y = a;
        return this
    },
    setZ: function (a) {
        this.z = a;
        return this
    },
    setComponent: function (a, b) {
        switch (a) {
        case 0:
            this.x = b;
            break;
        case 1:
            this.y = b;
            break;
        case 2:
            this.z = b;
            break;
        default:
            throw Error("index is out of range: " + a);
        }
    },
    getComponent: function (a) {
        switch (a) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw Error("index is out of range: " +
                a);
        }
    },
    copy: function (a) {
        this.x = a.x;
        this.y = a.y;
        this.z = a.z;
        return this
    },
    add: function (a, b) {
        if (void 0 !== b) return console.warn("DEPRECATED: Vector3's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
        this.x += a.x;
        this.y += a.y;
        this.z += a.z;
        return this
    },
    addScalar: function (a) {
        this.x += a;
        this.y += a;
        this.z += a;
        return this
    },
    addVectors: function (a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this
    },
    sub: function (a, b) {
        if (void 0 !== b) return console.warn("DEPRECATED: Vector3's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(a, b);
        this.x -= a.x;
        this.y -= a.y;
        this.z -= a.z;
        return this
    },
    subVectors: function (a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this
    },
    multiply: function (a, b) {
        if (void 0 !== b) return console.warn("DEPRECATED: Vector3's .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(a, b);
        this.x *= a.x;
        this.y *= a.y;
        this.z *= a.z;
        return this
    },
    multiplyScalar: function (a) {
        this.x *= a;
        this.y *= a;
        this.z *= a;
        return this
    },
    multiplyVectors: function (a, b) {
        this.x = a.x *
            b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this
    },
    applyEuler: function () {
        var a;
        return function (b) {
            !1 === b instanceof THREE.Euler && console.error("ERROR: Vector3's .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");
            void 0 === a && (a = new THREE.Quaternion);
            this.applyQuaternion(a.setFromEuler(b));
            return this
        }
    }(),
    applyAxisAngle: function () {
        var a;
        return function (b, c) {
            void 0 === a && (a = new THREE.Quaternion);
            this.applyQuaternion(a.setFromAxisAngle(b, c));
            return this
        }
    }(),
    applyMatrix3: function (a) {
        var b = this.x,
            c = this.y,
            e = this.z;
        a = a.elements;
        this.x = a[0] * b + a[3] * c + a[6] * e;
        this.y = a[1] * b + a[4] * c + a[7] * e;
        this.z = a[2] * b + a[5] * c + a[8] * e;
        return this
    },
    applyMatrix4: function (a) {
        var b = this.x,
            c = this.y,
            e = this.z;
        a = a.elements;
        this.x = a[0] * b + a[4] * c + a[8] * e + a[12];
        this.y = a[1] * b + a[5] * c + a[9] * e + a[13];
        this.z = a[2] * b + a[6] * c + a[10] * e + a[14];
        return this
    },
    applyProjection: function (a) {
        var b = this.x,
            c = this.y,
            e = this.z;
        a = a.elements;
        var d = 1 / (a[3] * b + a[7] * c + a[11] * e + a[15]);
        this.x = (a[0] * b + a[4] * c + a[8] * e + a[12]) * d;
        this.y =
            (a[1] * b + a[5] * c + a[9] * e + a[13]) * d;
        this.z = (a[2] * b + a[6] * c + a[10] * e + a[14]) * d;
        return this
    },
    applyQuaternion: function (a) {
        var b = this.x,
            c = this.y,
            e = this.z,
            d = a.x,
            g = a.y,
            f = a.z;
        a = a.w;
        var k = a * b + g * e - f * c,
            h = a * c + f * b - d * e,
            l = a * e + d * c - g * b,
            b = -d * b - g * c - f * e;
        this.x = k * a + b * -d + h * -f - l * -g;
        this.y = h * a + b * -g + l * -d - k * -f;
        this.z = l * a + b * -f + k * -g - h * -d;
        return this
    },
    transformDirection: function (a) {
        var b = this.x,
            c = this.y,
            e = this.z;
        a = a.elements;
        this.x = a[0] * b + a[4] * c + a[8] * e;
        this.y = a[1] * b + a[5] * c + a[9] * e;
        this.z = a[2] * b + a[6] * c + a[10] * e;
        this.normalize();
        return this
    },
    divide: function (a) {
        this.x /= a.x;
        this.y /= a.y;
        this.z /= a.z;
        return this
    },
    divideScalar: function (a) {
        0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *= a) : this.z = this.y = this.x = 0;
        return this
    },
    min: function (a) {
        this.x > a.x && (this.x = a.x);
        this.y > a.y && (this.y = a.y);
        this.z > a.z && (this.z = a.z);
        return this
    },
    max: function (a) {
        this.x < a.x && (this.x = a.x);
        this.y < a.y && (this.y = a.y);
        this.z < a.z && (this.z = a.z);
        return this
    },
    clamp: function (a, b) {
        this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
        this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
        this.z <
            a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);
        return this
    },
    clampScalar: function () {
        var a, b;
        return function (c, e) {
            void 0 === a && (a = new THREE.Vector3, b = new THREE.Vector3);
            a.set(c, c, c);
            b.set(e, e, e);
            return this.clamp(a, b)
        }
    }(),
    floor: function () {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this
    },
    ceil: function () {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this
    },
    round: function () {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this
    },
    roundToZero: function () {
        this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
        return this
    },
    negate: function () {
        return this.multiplyScalar(-1)
    },
    dot: function (a) {
        return this.x * a.x + this.y * a.y + this.z * a.z
    },
    lengthSq: function () {
        return this.x * this.x + this.y * this.y + this.z * this.z
    },
    length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    },
    lengthManhattan: function () {
        return Math.abs(this.x) +
            Math.abs(this.y) + Math.abs(this.z)
    },
    normalize: function () {
        return this.divideScalar(this.length())
    },
    setLength: function (a) {
        var b = this.length();
        0 !== b && a !== b && this.multiplyScalar(a / b);
        return this
    },
    lerp: function (a, b) {
        this.x += (a.x - this.x) * b;
        this.y += (a.y - this.y) * b;
        this.z += (a.z - this.z) * b;
        return this
    },
    cross: function (a, b) {
        if (void 0 !== b) return console.warn("DEPRECATED: Vector3's .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(a, b);
        var c = this.x,
            e = this.y,
            d = this.z;
        this.x =
            e * a.z - d * a.y;
        this.y = d * a.x - c * a.z;
        this.z = c * a.y - e * a.x;
        return this
    },
    crossVectors: function (a, b) {
        var c = a.x,
            e = a.y,
            d = a.z,
            g = b.x,
            f = b.y,
            k = b.z;
        this.x = e * k - d * f;
        this.y = d * g - c * k;
        this.z = c * f - e * g;
        return this
    },
    projectOnVector: function () {
        var a, b;
        return function (c) {
            void 0 === a && (a = new THREE.Vector3);
            a.copy(c).normalize();
            b = this.dot(a);
            return this.copy(a).multiplyScalar(b)
        }
    }(),
    projectOnPlane: function () {
        var a;
        return function (b) {
            void 0 === a && (a = new THREE.Vector3);
            a.copy(this).projectOnVector(b);
            return this.sub(a)
        }
    }(),
    reflect: function () {
        var a;
        return function (b) {
            void 0 === a && (a = new THREE.Vector3);
            return this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)))
        }
    }(),
    angleTo: function (a) {
        a = this.dot(a) / (this.length() * a.length());
        return Math.acos(THREE.Math.clamp(a, -1, 1))
    },
    distanceTo: function (a) {
        return Math.sqrt(this.distanceToSquared(a))
    },
    distanceToSquared: function (a) {
        var b = this.x - a.x,
            c = this.y - a.y;
        a = this.z - a.z;
        return b * b + c * c + a * a
    },
    setEulerFromRotationMatrix: function (a, b) {
        console.error("REMOVED: Vector3's setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.")
    },
    setEulerFromQuaternion: function (a, b) {
        console.error("REMOVED: Vector3's setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.")
    },
    getPositionFromMatrix: function (a) {
        console.warn("DEPRECATED: Vector3's .getPositionFromMatrix() has been renamed to .setFromMatrixPosition(). Please update your code.");
        return this.setFromMatrixPosition(a)
    },
    getScaleFromMatrix: function (a) {
        console.warn("DEPRECATED: Vector3's .getScaleFromMatrix() has been renamed to .setFromMatrixScale(). Please update your code.");
        return this.setFromMatrixScale(a)
    },
    getColumnFromMatrix: function (a, b) {
        console.warn("DEPRECATED: Vector3's .getColumnFromMatrix() has been renamed to .setFromMatrixColumn(). Please update your code.");
        return this.setFromMatrixColumn(a, b)
    },
    setFromMatrixPosition: function (a) {
        this.x = a.elements[12];
        this.y = a.elements[13];
        this.z = a.elements[14];
        return this
    },
    setFromMatrixScale: function (a) {
        var b = this.set(a.elements[0], a.elements[1], a.elements[2]).length(),
            c = this.set(a.elements[4], a.elements[5], a.elements[6]).length();
        a = this.set(a.elements[8], a.elements[9], a.elements[10]).length();
        this.x = b;
        this.y = c;
        this.z = a;
        return this
    },
    setFromMatrixColumn: function (a, b) {
        var c = 4 * a,
            e = b.elements;
        this.x = e[c];
        this.y = e[c + 1];
        this.z = e[c + 2];
        return this
    },
    equals: function (a) {
        return a.x === this.x && a.y === this.y && a.z === this.z
    },
    fromArray: function (a) {
        this.x = a[0];
        this.y = a[1];
        this.z = a[2];
        return this
    },
    toArray: function () {
        return [this.x, this.y, this.z]
    },
    clone: function () {
        return new THREE.Vector3(this.x, this.y, this.z)
    }
};
THREE.Vector4 = function (a, b, c, e) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0;
    this.w = void 0 !== e ? e : 1
};
THREE.Vector4.prototype = {
    constructor: THREE.Vector4,
    set: function (a, b, c, e) {
        this.x = a;
        this.y = b;
        this.z = c;
        this.w = e;
        return this
    },
    setX: function (a) {
        this.x = a;
        return this
    },
    setY: function (a) {
        this.y = a;
        return this
    },
    setZ: function (a) {
        this.z = a;
        return this
    },
    setW: function (a) {
        this.w = a;
        return this
    },
    setComponent: function (a, b) {
        switch (a) {
        case 0:
            this.x = b;
            break;
        case 1:
            this.y = b;
            break;
        case 2:
            this.z = b;
            break;
        case 3:
            this.w = b;
            break;
        default:
            throw Error("index is out of range: " + a);
        }
    },
    getComponent: function (a) {
        switch (a) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw Error("index is out of range: " + a);
        }
    },
    copy: function (a) {
        this.x = a.x;
        this.y = a.y;
        this.z = a.z;
        this.w = void 0 !== a.w ? a.w : 1;
        return this
    },
    add: function (a, b) {
        if (void 0 !== b) return console.warn("DEPRECATED: Vector4's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
        this.x += a.x;
        this.y += a.y;
        this.z += a.z;
        this.w += a.w;
        return this
    },
    addScalar: function (a) {
        this.x += a;
        this.y += a;
        this.z += a;
        this.w += a;
        return this
    },
    addVectors: function (a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this
    },
    sub: function (a, b) {
        if (void 0 !== b) return console.warn("DEPRECATED: Vector4's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
        this.x -= a.x;
        this.y -= a.y;
        this.z -= a.z;
        this.w -= a.w;
        return this
    },
    subVectors: function (a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this
    },
    multiplyScalar: function (a) {
        this.x *= a;
        this.y *= a;
        this.z *= a;
        this.w *= a;
        return this
    },
    applyMatrix4: function (a) {
        var b = this.x,
            c = this.y,
            e = this.z,
            d = this.w;
        a = a.elements;
        this.x = a[0] * b + a[4] * c + a[8] * e + a[12] * d;
        this.y = a[1] * b + a[5] * c + a[9] * e + a[13] * d;
        this.z = a[2] * b + a[6] * c + a[10] * e + a[14] * d;
        this.w = a[3] * b + a[7] * c + a[11] * e + a[15] * d;
        return this
    },
    divideScalar: function (a) {
        0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *= a, this.w *= a) : (this.z = this.y = this.x = 0, this.w = 1);
        return this
    },
    setAxisAngleFromQuaternion: function (a) {
        this.w = 2 * Math.acos(a.w);
        var b = Math.sqrt(1 - a.w * a.w);
        1E-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b,
            this.y = a.y / b, this.z = a.z / b);
        return this
    },
    setAxisAngleFromRotationMatrix: function (a) {
        var b, c, e;
        a = a.elements;
        var d = a[0];
        e = a[4];
        var g = a[8],
            f = a[1],
            k = a[5],
            h = a[9];
        c = a[2];
        b = a[6];
        var l = a[10];
        if (0.01 > Math.abs(e - f) && 0.01 > Math.abs(g - c) && 0.01 > Math.abs(h - b)) {
            if (0.1 > Math.abs(e + f) && 0.1 > Math.abs(g + c) && 0.1 > Math.abs(h + b) && 0.1 > Math.abs(d + k + l - 3)) return this.set(1, 0, 0, 0), this;
            a = Math.PI;
            d = (d + 1) / 2;
            k = (k + 1) / 2;
            l = (l + 1) / 2;
            e = (e + f) / 4;
            g = (g + c) / 4;
            h = (h + b) / 4;
            d > k && d > l ? 0.01 > d ? (b = 0, e = c = 0.707106781) : (b = Math.sqrt(d), c = e / b, e = g / b) : k > l ? 0.01 >
                k ? (b = 0.707106781, c = 0, e = 0.707106781) : (c = Math.sqrt(k), b = e / c, e = h / c) : 0.01 > l ? (c = b = 0.707106781, e = 0) : (e = Math.sqrt(l), b = g / e, c = h / e);
            this.set(b, c, e, a);
            return this
        }
        a = Math.sqrt((b - h) * (b - h) + (g - c) * (g - c) + (f - e) * (f - e));
        0.001 > Math.abs(a) && (a = 1);
        this.x = (b - h) / a;
        this.y = (g - c) / a;
        this.z = (f - e) / a;
        this.w = Math.acos((d + k + l - 1) / 2);
        return this
    },
    min: function (a) {
        this.x > a.x && (this.x = a.x);
        this.y > a.y && (this.y = a.y);
        this.z > a.z && (this.z = a.z);
        this.w > a.w && (this.w = a.w);
        return this
    },
    max: function (a) {
        this.x < a.x && (this.x = a.x);
        this.y < a.y && (this.y =
            a.y);
        this.z < a.z && (this.z = a.z);
        this.w < a.w && (this.w = a.w);
        return this
    },
    clamp: function (a, b) {
        this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
        this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
        this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);
        this.w < a.w ? this.w = a.w : this.w > b.w && (this.w = b.w);
        return this
    },
    clampScalar: function () {
        var a, b;
        return function (c, e) {
            void 0 === a && (a = new THREE.Vector4, b = new THREE.Vector4);
            a.set(c, c, c, c);
            b.set(e, e, e, e);
            return this.clamp(a, b)
        }
    }(),
    floor: function () {
        this.x = Math.floor(this.x);
        this.y =
            Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this
    },
    ceil: function () {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this
    },
    round: function () {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this
    },
    roundToZero: function () {
        this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = 0 > this.z ? Math.ceil(this.z) :
            Math.floor(this.z);
        this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
        return this
    },
    negate: function () {
        return this.multiplyScalar(-1)
    },
    dot: function (a) {
        return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
    },
    lengthSq: function () {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    },
    length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    },
    lengthManhattan: function () {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    },
    normalize: function () {
        return this.divideScalar(this.length())
    },
    setLength: function (a) {
        var b = this.length();
        0 !== b && a !== b && this.multiplyScalar(a / b);
        return this
    },
    lerp: function (a, b) {
        this.x += (a.x - this.x) * b;
        this.y += (a.y - this.y) * b;
        this.z += (a.z - this.z) * b;
        this.w += (a.w - this.w) * b;
        return this
    },
    equals: function (a) {
        return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
    },
    fromArray: function (a) {
        this.x = a[0];
        this.y = a[1];
        this.z = a[2];
        this.w = a[3];
        return this
    },
    toArray: function () {
        return [this.x, this.y, this.z, this.w]
    },
    clone: function () {
        return new THREE.Vector4(this.x, this.y, this.z,
            this.w)
    }
};
THREE.Euler = function (a, b, c, e) {
    this._x = a || 0;
    this._y = b || 0;
    this._z = c || 0;
    this._order = e || THREE.Euler.DefaultOrder
};
THREE.Euler.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
THREE.Euler.DefaultOrder = "XYZ";
THREE.Euler.prototype = {
    constructor: THREE.Euler,
    _x: 0,
    _y: 0,
    _z: 0,
    _order: THREE.Euler.DefaultOrder,
    _quaternion: void 0,
    _updateQuaternion: function () {
        void 0 !== this._quaternion && this._quaternion.setFromEuler(this, !1)
    },
    get x() {
        return this._x
    },
    set x(a) {
        this._x = a;
        this._updateQuaternion()
    },
    get y() {
        return this._y
    },
    set y(a) {
        this._y = a;
        this._updateQuaternion()
    },
    get z() {
        return this._z
    },
    set z(a) {
        this._z = a;
        this._updateQuaternion()
    },
    get order() {
        return this._order
    },
    set order(a) {
        this._order = a;
        this._updateQuaternion()
    },
    set: function (a, b, c, e) {
        this._x = a;
        this._y = b;
        this._z = c;
        this._order = e || this._order;
        this._updateQuaternion();
        return this
    },
    copy: function (a) {
        this._x = a._x;
        this._y = a._y;
        this._z = a._z;
        this._order = a._order;
        this._updateQuaternion();
        return this
    },
    setFromRotationMatrix: function (a, b) {
        function c(a) {
            return Math.min(Math.max(a, -1), 1)
        }
        var e = a.elements,
            d = e[0],
            g = e[4],
            f = e[8],
            k = e[1],
            h = e[5],
            l = e[9],
            m = e[2],
            n = e[6],
            e = e[10];
        b = b || this._order;
        "XYZ" === b ? (this._y = Math.asin(c(f)), 0.99999 > Math.abs(f) ? (this._x = Math.atan2(-l, e), this._z =
            Math.atan2(-g, d)) : (this._x = Math.atan2(n, h), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-c(l)), 0.99999 > Math.abs(l) ? (this._y = Math.atan2(f, e), this._z = Math.atan2(k, h)) : (this._y = Math.atan2(-m, d), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(c(n)), 0.99999 > Math.abs(n) ? (this._y = Math.atan2(-m, e), this._z = Math.atan2(-g, h)) : (this._y = 0, this._z = Math.atan2(k, d))) : "ZYX" === b ? (this._y = Math.asin(-c(m)), 0.99999 > Math.abs(m) ? (this._x = Math.atan2(n, e), this._z = Math.atan2(k, d)) : (this._x = 0, this._z = Math.atan2(-g, h))) : "YZX" === b ? (this._z =
            Math.asin(c(k)), 0.99999 > Math.abs(k) ? (this._x = Math.atan2(-l, h), this._y = Math.atan2(-m, d)) : (this._x = 0, this._y = Math.atan2(f, e))) : "XZY" === b ? (this._z = Math.asin(-c(g)), 0.99999 > Math.abs(g) ? (this._x = Math.atan2(n, h), this._y = Math.atan2(f, d)) : (this._x = Math.atan2(-l, e), this._y = 0)) : console.warn("WARNING: Euler.setFromRotationMatrix() given unsupported order: " + b);
        this._order = b;
        this._updateQuaternion();
        return this
    },
    setFromQuaternion: function (a, b, c) {
        function e(a) {
            return Math.min(Math.max(a, -1), 1)
        }
        var d = a.x * a.x,
            g =
            a.y * a.y,
            f = a.z * a.z,
            k = a.w * a.w;
        b = b || this._order;
        "XYZ" === b ? (this._x = Math.atan2(2 * (a.x * a.w - a.y * a.z), k - d - g + f), this._y = Math.asin(e(2 * (a.x * a.z + a.y * a.w))), this._z = Math.atan2(2 * (a.z * a.w - a.x * a.y), k + d - g - f)) : "YXZ" === b ? (this._x = Math.asin(e(2 * (a.x * a.w - a.y * a.z))), this._y = Math.atan2(2 * (a.x * a.z + a.y * a.w), k - d - g + f), this._z = Math.atan2(2 * (a.x * a.y + a.z * a.w), k - d + g - f)) : "ZXY" === b ? (this._x = Math.asin(e(2 * (a.x * a.w + a.y * a.z))), this._y = Math.atan2(2 * (a.y * a.w - a.z * a.x), k - d - g + f), this._z = Math.atan2(2 * (a.z * a.w - a.x * a.y), k - d + g - f)) : "ZYX" ===
            b ? (this._x = Math.atan2(2 * (a.x * a.w + a.z * a.y), k - d - g + f), this._y = Math.asin(e(2 * (a.y * a.w - a.x * a.z))), this._z = Math.atan2(2 * (a.x * a.y + a.z * a.w), k + d - g - f)) : "YZX" === b ? (this._x = Math.atan2(2 * (a.x * a.w - a.z * a.y), k - d + g - f), this._y = Math.atan2(2 * (a.y * a.w - a.x * a.z), k + d - g - f), this._z = Math.asin(e(2 * (a.x * a.y + a.z * a.w)))) : "XZY" === b ? (this._x = Math.atan2(2 * (a.x * a.w + a.y * a.z), k - d + g - f), this._y = Math.atan2(2 * (a.x * a.z + a.y * a.w), k + d - g - f), this._z = Math.asin(e(2 * (a.z * a.w - a.x * a.y)))) : console.warn("WARNING: Euler.setFromQuaternion() given unsupported order: " +
                b);
        this._order = b;
        !1 !== c && this._updateQuaternion();
        return this
    },
    reorder: function () {
        var a = new THREE.Quaternion;
        return function (b) {
            a.setFromEuler(this);
            this.setFromQuaternion(a, b)
        }
    }(),
    fromArray: function (a) {
        this._x = a[0];
        this._y = a[1];
        this._z = a[2];
        void 0 !== a[3] && (this._order = a[3]);
        this._updateQuaternion();
        return this
    },
    toArray: function () {
        return [this._x, this._y, this._z, this._order]
    },
    equals: function (a) {
        return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order
    },
    clone: function () {
        return new THREE.Euler(this._x,
            this._y, this._z, this._order)
    }
};
THREE.Line3 = function (a, b) {
    this.start = void 0 !== a ? a : new THREE.Vector3;
    this.end = void 0 !== b ? b : new THREE.Vector3
};
THREE.Line3.prototype = {
    constructor: THREE.Line3,
    set: function (a, b) {
        this.start.copy(a);
        this.end.copy(b);
        return this
    },
    copy: function (a) {
        this.start.copy(a.start);
        this.end.copy(a.end);
        return this
    },
    center: function (a) {
        return (a || new THREE.Vector3).addVectors(this.start, this.end).multiplyScalar(0.5)
    },
    delta: function (a) {
        return (a || new THREE.Vector3).subVectors(this.end, this.start)
    },
    distanceSq: function () {
        return this.start.distanceToSquared(this.end)
    },
    distance: function () {
        return this.start.distanceTo(this.end)
    },
    at: function (a,
        b) {
        var c = b || new THREE.Vector3;
        return this.delta(c).multiplyScalar(a).add(this.start)
    },
    closestPointToPointParameter: function () {
        var a = new THREE.Vector3,
            b = new THREE.Vector3;
        return function (c, e) {
            a.subVectors(c, this.start);
            b.subVectors(this.end, this.start);
            var d = b.dot(b),
                d = b.dot(a) / d;
            e && (d = THREE.Math.clamp(d, 0, 1));
            return d
        }
    }(),
    closestPointToPoint: function (a, b, c) {
        a = this.closestPointToPointParameter(a, b);
        c = c || new THREE.Vector3;
        return this.delta(c).multiplyScalar(a).add(this.start)
    },
    applyMatrix4: function (a) {
        this.start.applyMatrix4(a);
        this.end.applyMatrix4(a);
        return this
    },
    equals: function (a) {
        return a.start.equals(this.start) && a.end.equals(this.end)
    },
    clone: function () {
        return (new THREE.Line3).copy(this)
    }
};
THREE.Box2 = function (a, b) {
    this.min = void 0 !== a ? a : new THREE.Vector2(Infinity, Infinity);
    this.max = void 0 !== b ? b : new THREE.Vector2(-Infinity, -Infinity)
};
THREE.Box2.prototype = {
    constructor: THREE.Box2,
    set: function (a, b) {
        this.min.copy(a);
        this.max.copy(b);
        return this
    },
    setFromPoints: function (a) {
        if (0 < a.length) {
            var b = a[0];
            this.min.copy(b);
            this.max.copy(b);
            for (var c = 1, e = a.length; c < e; c++) b = a[c], b.x < this.min.x ? this.min.x = b.x : b.x > this.max.x && (this.max.x = b.x), b.y < this.min.y ? this.min.y = b.y : b.y > this.max.y && (this.max.y = b.y)
        } else this.makeEmpty();
        return this
    },
    setFromCenterAndSize: function () {
        var a = new THREE.Vector2;
        return function (b, c) {
            var e = a.copy(c).multiplyScalar(0.5);
            this.min.copy(b).sub(e);
            this.max.copy(b).add(e);
            return this
        }
    }(),
    copy: function (a) {
        this.min.copy(a.min);
        this.max.copy(a.max);
        return this
    },
    makeEmpty: function () {
        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;
        return this
    },
    empty: function () {
        return this.max.x < this.min.x || this.max.y < this.min.y
    },
    center: function (a) {
        return (a || new THREE.Vector2).addVectors(this.min, this.max).multiplyScalar(0.5)
    },
    size: function (a) {
        return (a || new THREE.Vector2).subVectors(this.max, this.min)
    },
    expandByPoint: function (a) {
        this.min.min(a);
        this.max.max(a);
        return this
    },
    expandByVector: function (a) {
        this.min.sub(a);
        this.max.add(a);
        return this
    },
    expandByScalar: function (a) {
        this.min.addScalar(-a);
        this.max.addScalar(a);
        return this
    },
    containsPoint: function (a) {
        return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0
    },
    containsBox: function (a) {
        return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y ? !0 : !1
    },
    getParameter: function (a, b) {
        return (b || new THREE.Vector2).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y))
    },
    isIntersectionBox: function (a) {
        return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0
    },
    clampPoint: function (a, b) {
        return (b || new THREE.Vector2).copy(a).clamp(this.min, this.max)
    },
    distanceToPoint: function () {
        var a = new THREE.Vector2;
        return function (b) {
            return a.copy(b).clamp(this.min, this.max).sub(b).length()
        }
    }(),
    intersect: function (a) {
        this.min.max(a.min);
        this.max.min(a.max);
        return this
    },
    union: function (a) {
        this.min.min(a.min);
        this.max.max(a.max);
        return this
    },
    translate: function (a) {
        this.min.add(a);
        this.max.add(a);
        return this
    },
    equals: function (a) {
        return a.min.equals(this.min) && a.max.equals(this.max)
    },
    clone: function () {
        return (new THREE.Box2).copy(this)
    }
};
THREE.Box3 = function (a, b) {
    this.min = void 0 !== a ? a : new THREE.Vector3(Infinity, Infinity, Infinity);
    this.max = void 0 !== b ? b : new THREE.Vector3(-Infinity, -Infinity, -Infinity)
};
THREE.Box3.prototype = {
    constructor: THREE.Box3,
    set: function (a, b) {
        this.min.copy(a);
        this.max.copy(b);
        return this
    },
    addPoint: function (a) {
        a.x < this.min.x ? this.min.x = a.x : a.x > this.max.x && (this.max.x = a.x);
        a.y < this.min.y ? this.min.y = a.y : a.y > this.max.y && (this.max.y = a.y);
        a.z < this.min.z ? this.min.z = a.z : a.z > this.max.z && (this.max.z = a.z)
    },
    setFromPoints: function (a) {
        if (0 < a.length) {
            var b = a[0];
            this.min.copy(b);
            this.max.copy(b);
            for (var b = 1, c = a.length; b < c; b++) this.addPoint(a[b])
        } else this.makeEmpty();
        return this
    },
    setFromCenterAndSize: function () {
        var a =
            new THREE.Vector3;
        return function (b, c) {
            var e = a.copy(c).multiplyScalar(0.5);
            this.min.copy(b).sub(e);
            this.max.copy(b).add(e);
            return this
        }
    }(),
    setFromObject: function () {
        var a = new THREE.Vector3;
        return function (b) {
            var c = this;
            b.updateMatrixWorld(!0);
            this.makeEmpty();
            b.traverse(function (b) {
                if (void 0 !== b.geometry && void 0 !== b.geometry.vertices)
                    for (var d = b.geometry.vertices, g = 0, f = d.length; g < f; g++) a.copy(d[g]), a.applyMatrix4(b.matrixWorld), c.expandByPoint(a)
            });
            return this
        }
    }(),
    copy: function (a) {
        this.min.copy(a.min);
        this.max.copy(a.max);
        return this
    },
    makeEmpty: function () {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this
    },
    empty: function () {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    },
    center: function (a) {
        return (a || new THREE.Vector3).addVectors(this.min, this.max).multiplyScalar(0.5)
    },
    size: function (a) {
        return (a || new THREE.Vector3).subVectors(this.max, this.min)
    },
    expandByPoint: function (a) {
        this.min.min(a);
        this.max.max(a);
        return this
    },
    expandByVector: function (a) {
        this.min.sub(a);
        this.max.add(a);
        return this
    },
    expandByScalar: function (a) {
        this.min.addScalar(-a);
        this.max.addScalar(a);
        return this
    },
    containsPoint: function (a) {
        return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0
    },
    containsBox: function (a) {
        return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z ? !0 : !1
    },
    getParameter: function (a, b) {
        return (b || new THREE.Vector3).set((a.x - this.min.x) / (this.max.x -
            this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z))
    },
    isIntersectionBox: function (a) {
        return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0
    },
    clampPoint: function (a, b) {
        return (b || new THREE.Vector3).copy(a).clamp(this.min, this.max)
    },
    distanceToPoint: function () {
        var a = new THREE.Vector3;
        return function (b) {
            return a.copy(b).clamp(this.min, this.max).sub(b).length()
        }
    }(),
    getBoundingSphere: function () {
        var a =
            new THREE.Vector3;
        return function (b) {
            b = b || new THREE.Sphere;
            b.center = this.center();
            b.radius = 0.5 * this.size(a).length();
            return b
        }
    }(),
    intersect: function (a) {
        this.min.max(a.min);
        this.max.min(a.max);
        return this
    },
    union: function (a) {
        this.min.min(a.min);
        this.max.max(a.max);
        return this
    },
    applyMatrix4: function () {
        var a = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3];
        return function (b) {
            a[0].set(this.min.x, this.min.y,
                this.min.z).applyMatrix4(b);
            a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b);
            a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b);
            a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b);
            a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b);
            a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b);
            a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b);
            a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b);
            this.makeEmpty();
            this.setFromPoints(a);
            return this
        }
    }(),
    translate: function (a) {
        this.min.add(a);
        this.max.add(a);
        return this
    },
    equals: function (a) {
        return a.min.equals(this.min) && a.max.equals(this.max)
    },
    clone: function () {
        return (new THREE.Box3).copy(this)
    }
};
THREE.Matrix3 = function (a, b, c, e, d, g, f, k, h) {
    this.elements = new Float32Array(9);
    this.set(void 0 !== a ? a : 1, b || 0, c || 0, e || 0, void 0 !== d ? d : 1, g || 0, f || 0, k || 0, void 0 !== h ? h : 1)
};
THREE.Matrix3.prototype = {
    constructor: THREE.Matrix3,
    set: function (a, b, c, e, d, g, f, k, h) {
        var l = this.elements;
        l[0] = a;
        l[3] = b;
        l[6] = c;
        l[1] = e;
        l[4] = d;
        l[7] = g;
        l[2] = f;
        l[5] = k;
        l[8] = h;
        return this
    },
    identity: function () {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this
    },
    copy: function (a) {
        a = a.elements;
        this.set(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]);
        return this
    },
    multiplyVector3: function (a) {
        console.warn("DEPRECATED: Matrix3's .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
        return a.applyMatrix3(this)
    },
    multiplyVector3Array: function () {
        var a = new THREE.Vector3;
        return function (b) {
            for (var c = 0, e = b.length; c < e; c += 3) a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], a.applyMatrix3(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;
            return b
        }
    }(),
    multiplyScalar: function (a) {
        var b = this.elements;
        b[0] *= a;
        b[3] *= a;
        b[6] *= a;
        b[1] *= a;
        b[4] *= a;
        b[7] *= a;
        b[2] *= a;
        b[5] *= a;
        b[8] *= a;
        return this
    },
    determinant: function () {
        var a = this.elements,
            b = a[0],
            c = a[1],
            e = a[2],
            d = a[3],
            g = a[4],
            f = a[5],
            k = a[6],
            h = a[7],
            a = a[8];
        return b * g * a - b * f * h - c * d * a + c * f * k + e * d * h - e * g * k
    },
    getInverse: function (a,
        b) {
        var c = a.elements,
            e = this.elements;
        e[0] = c[10] * c[5] - c[6] * c[9];
        e[1] = -c[10] * c[1] + c[2] * c[9];
        e[2] = c[6] * c[1] - c[2] * c[5];
        e[3] = -c[10] * c[4] + c[6] * c[8];
        e[4] = c[10] * c[0] - c[2] * c[8];
        e[5] = -c[6] * c[0] + c[2] * c[4];
        e[6] = c[9] * c[4] - c[5] * c[8];
        e[7] = -c[9] * c[0] + c[1] * c[8];
        e[8] = c[5] * c[0] - c[1] * c[4];
        c = c[0] * e[0] + c[1] * e[3] + c[2] * e[6];
        if (0 === c) {
            if (b) throw Error("Matrix3.getInverse(): can't invert matrix, determinant is 0");
            console.warn("Matrix3.getInverse(): can't invert matrix, determinant is 0");
            this.identity();
            return this
        }
        this.multiplyScalar(1 /
            c);
        return this
    },
    transpose: function () {
        var a, b = this.elements;
        a = b[1];
        b[1] = b[3];
        b[3] = a;
        a = b[2];
        b[2] = b[6];
        b[6] = a;
        a = b[5];
        b[5] = b[7];
        b[7] = a;
        return this
    },
    getNormalMatrix: function (a) {
        this.getInverse(a).transpose();
        return this
    },
    transposeIntoArray: function (a) {
        var b = this.elements;
        a[0] = b[0];
        a[1] = b[3];
        a[2] = b[6];
        a[3] = b[1];
        a[4] = b[4];
        a[5] = b[7];
        a[6] = b[2];
        a[7] = b[5];
        a[8] = b[8];
        return this
    },
    fromArray: function (a) {
        this.elements.set(a);
        return this
    },
    toArray: function () {
        var a = this.elements;
        return [a[0], a[1], a[2], a[3], a[4], a[5],
            a[6], a[7], a[8]
        ]
    },
    clone: function () {
        var a = this.elements;
        return new THREE.Matrix3(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8])
    }
};
THREE.Matrix4 = function (a, b, c, e, d, g, f, k, h, l, m, n, r, s, t, p) {
    var u = this.elements = new Float32Array(16);
    u[0] = void 0 !== a ? a : 1;
    u[4] = b || 0;
    u[8] = c || 0;
    u[12] = e || 0;
    u[1] = d || 0;
    u[5] = void 0 !== g ? g : 1;
    u[9] = f || 0;
    u[13] = k || 0;
    u[2] = h || 0;
    u[6] = l || 0;
    u[10] = void 0 !== m ? m : 1;
    u[14] = n || 0;
    u[3] = r || 0;
    u[7] = s || 0;
    u[11] = t || 0;
    u[15] = void 0 !== p ? p : 1
};
THREE.Matrix4.prototype = {
    constructor: THREE.Matrix4,
    set: function (a, b, c, e, d, g, f, k, h, l, m, n, r, s, t, p) {
        var u = this.elements;
        u[0] = a;
        u[4] = b;
        u[8] = c;
        u[12] = e;
        u[1] = d;
        u[5] = g;
        u[9] = f;
        u[13] = k;
        u[2] = h;
        u[6] = l;
        u[10] = m;
        u[14] = n;
        u[3] = r;
        u[7] = s;
        u[11] = t;
        u[15] = p;
        return this
    },
    identity: function () {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this
    },
    copy: function (a) {
        this.elements.set(a.elements);
        return this
    },
    extractPosition: function (a) {
        console.warn("DEPRECATED: Matrix4's .extractPosition() has been renamed to .copyPosition().");
        return this.copyPosition(a)
    },
    copyPosition: function (a) {
        var b = this.elements;
        a = a.elements;
        b[12] = a[12];
        b[13] = a[13];
        b[14] = a[14];
        return this
    },
    extractRotation: function () {
        var a = new THREE.Vector3;
        return function (b) {
            var c = this.elements;
            b = b.elements;
            var e = 1 / a.set(b[0], b[1], b[2]).length(),
                d = 1 / a.set(b[4], b[5], b[6]).length(),
                g = 1 / a.set(b[8], b[9], b[10]).length();
            c[0] = b[0] * e;
            c[1] = b[1] * e;
            c[2] = b[2] * e;
            c[4] = b[4] * d;
            c[5] = b[5] * d;
            c[6] = b[6] * d;
            c[8] = b[8] * g;
            c[9] = b[9] * g;
            c[10] = b[10] * g;
            return this
        }
    }(),
    makeRotationFromEuler: function (a) {
        !1 ===
            a instanceof THREE.Euler && console.error("ERROR: Matrix's .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");
        var b = this.elements,
            c = a.x,
            e = a.y,
            d = a.z,
            g = Math.cos(c),
            c = Math.sin(c),
            f = Math.cos(e),
            e = Math.sin(e),
            k = Math.cos(d),
            d = Math.sin(d);
        if ("XYZ" === a.order) {
            a = g * k;
            var h = g * d,
                l = c * k,
                m = c * d;
            b[0] = f * k;
            b[4] = -f * d;
            b[8] = e;
            b[1] = h + l * e;
            b[5] = a - m * e;
            b[9] = -c * f;
            b[2] = m - a * e;
            b[6] = l + h * e;
            b[10] = g * f
        } else "YXZ" === a.order ? (a = f * k, h = f * d, l = e * k, m = e * d, b[0] = a + m * c, b[4] = l * c - h, b[8] =
            g * e, b[1] = g * d, b[5] = g * k, b[9] = -c, b[2] = h * c - l, b[6] = m + a * c, b[10] = g * f) : "ZXY" === a.order ? (a = f * k, h = f * d, l = e * k, m = e * d, b[0] = a - m * c, b[4] = -g * d, b[8] = l + h * c, b[1] = h + l * c, b[5] = g * k, b[9] = m - a * c, b[2] = -g * e, b[6] = c, b[10] = g * f) : "ZYX" === a.order ? (a = g * k, h = g * d, l = c * k, m = c * d, b[0] = f * k, b[4] = l * e - h, b[8] = a * e + m, b[1] = f * d, b[5] = m * e + a, b[9] = h * e - l, b[2] = -e, b[6] = c * f, b[10] = g * f) : "YZX" === a.order ? (a = g * f, h = g * e, l = c * f, m = c * e, b[0] = f * k, b[4] = m - a * d, b[8] = l * d + h, b[1] = d, b[5] = g * k, b[9] = -c * k, b[2] = -e * k, b[6] = h * d + l, b[10] = a - m * d) : "XZY" === a.order && (a = g * f, h = g * e, l = c * f, m = c * e, b[0] =
            f * k, b[4] = -d, b[8] = e * k, b[1] = a * d + m, b[5] = g * k, b[9] = h * d - l, b[2] = l * d - h, b[6] = c * k, b[10] = m * d + a);
        b[3] = 0;
        b[7] = 0;
        b[11] = 0;
        b[12] = 0;
        b[13] = 0;
        b[14] = 0;
        b[15] = 1;
        return this
    },
    setRotationFromQuaternion: function (a) {
        console.warn("DEPRECATED: Matrix4's .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code.");
        return this.makeRotationFromQuaternion(a)
    },
    makeRotationFromQuaternion: function (a) {
        var b = this.elements,
            c = a.x,
            e = a.y,
            d = a.z,
            g = a.w,
            f = c + c,
            k = e + e,
            h = d + d;
        a = c * f;
        var l = c *
            k,
            c = c * h,
            m = e * k,
            e = e * h,
            d = d * h,
            f = g * f,
            k = g * k,
            g = g * h;
        b[0] = 1 - (m + d);
        b[4] = l - g;
        b[8] = c + k;
        b[1] = l + g;
        b[5] = 1 - (a + d);
        b[9] = e - f;
        b[2] = c - k;
        b[6] = e + f;
        b[10] = 1 - (a + m);
        b[3] = 0;
        b[7] = 0;
        b[11] = 0;
        b[12] = 0;
        b[13] = 0;
        b[14] = 0;
        b[15] = 1;
        return this
    },
    lookAt: function () {
        var a = new THREE.Vector3,
            b = new THREE.Vector3,
            c = new THREE.Vector3;
        return function (e, d, g) {
            var f = this.elements;
            c.subVectors(e, d).normalize();
            0 === c.length() && (c.z = 1);
            a.crossVectors(g, c).normalize();
            0 === a.length() && (c.x += 1E-4, a.crossVectors(g, c).normalize());
            b.crossVectors(c, a);
            f[0] =
                a.x;
            f[4] = b.x;
            f[8] = c.x;
            f[1] = a.y;
            f[5] = b.y;
            f[9] = c.y;
            f[2] = a.z;
            f[6] = b.z;
            f[10] = c.z;
            return this
        }
    }(),
    multiply: function (a, b) {
        return void 0 !== b ? (console.warn("DEPRECATED: Matrix4's .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a)
    },
    multiplyMatrices: function (a, b) {
        var c = a.elements,
            e = b.elements,
            d = this.elements,
            g = c[0],
            f = c[4],
            k = c[8],
            h = c[12],
            l = c[1],
            m = c[5],
            n = c[9],
            r = c[13],
            s = c[2],
            t = c[6],
            p = c[10],
            u = c[14],
            v = c[3],
            w = c[7],
            y = c[11],
            c = c[15],
            x = e[0],
            A = e[4],
            N = e[8],
            B = e[12],
            G = e[1],
            C = e[5],
            P = e[9],
            z = e[13],
            Q = e[2],
            F = e[6],
            O = e[10],
            T = e[14],
            D = e[3],
            J = e[7],
            I = e[11],
            e = e[15];
        d[0] = g * x + f * G + k * Q + h * D;
        d[4] = g * A + f * C + k * F + h * J;
        d[8] = g * N + f * P + k * O + h * I;
        d[12] = g * B + f * z + k * T + h * e;
        d[1] = l * x + m * G + n * Q + r * D;
        d[5] = l * A + m * C + n * F + r * J;
        d[9] = l * N + m * P + n * O + r * I;
        d[13] = l * B + m * z + n * T + r * e;
        d[2] = s * x + t * G + p * Q + u * D;
        d[6] = s * A + t * C + p * F + u * J;
        d[10] = s * N + t * P + p * O + u * I;
        d[14] = s * B + t * z + p * T + u * e;
        d[3] = v * x + w * G + y * Q + c * D;
        d[7] = v * A + w * C + y * F + c * J;
        d[11] = v * N + w * P + y * O + c * I;
        d[15] = v * B + w * z + y * T + c * e;
        return this
    },
    multiplyToArray: function (a,
        b, c) {
        var e = this.elements;
        this.multiplyMatrices(a, b);
        c[0] = e[0];
        c[1] = e[1];
        c[2] = e[2];
        c[3] = e[3];
        c[4] = e[4];
        c[5] = e[5];
        c[6] = e[6];
        c[7] = e[7];
        c[8] = e[8];
        c[9] = e[9];
        c[10] = e[10];
        c[11] = e[11];
        c[12] = e[12];
        c[13] = e[13];
        c[14] = e[14];
        c[15] = e[15];
        return this
    },
    multiplyScalar: function (a) {
        var b = this.elements;
        b[0] *= a;
        b[4] *= a;
        b[8] *= a;
        b[12] *= a;
        b[1] *= a;
        b[5] *= a;
        b[9] *= a;
        b[13] *= a;
        b[2] *= a;
        b[6] *= a;
        b[10] *= a;
        b[14] *= a;
        b[3] *= a;
        b[7] *= a;
        b[11] *= a;
        b[15] *= a;
        return this
    },
    multiplyVector3: function (a) {
        console.warn("DEPRECATED: Matrix4's .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.");
        return a.applyProjection(this)
    },
    multiplyVector4: function (a) {
        console.warn("DEPRECATED: Matrix4's .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return a.applyMatrix4(this)
    },
    multiplyVector3Array: function () {
        var a = new THREE.Vector3;
        return function (b) {
            for (var c = 0, e = b.length; c < e; c += 3) a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], a.applyProjection(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;
            return b
        }
    }(),
    rotateAxis: function (a) {
        console.warn("DEPRECATED: Matrix4's .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
        a.transformDirection(this)
    },
    crossVector: function (a) {
        console.warn("DEPRECATED: Matrix4's .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return a.applyMatrix4(this)
    },
    determinant: function () {
        var a = this.elements,
            b = a[0],
            c = a[4],
            e = a[8],
            d = a[12],
            g = a[1],
            f = a[5],
            k = a[9],
            h = a[13],
            l = a[2],
            m = a[6],
            n = a[10],
            r = a[14];
        return a[3] * (+d * k * m - e * h * m - d * f * n + c * h * n + e * f * r - c * k * r) + a[7] * (+b * k * r - b * h * n + d * g * n - e * g * r + e * h * l - d * k * l) + a[11] * (+b * h * m - b * f * r - d * g * m + c * g * r + d * f * l - c * h * l) + a[15] * (-e * f * l - b * k * m + b * f * n + e * g * m - c * g *
            n + c * k * l)
    },
    transpose: function () {
        var a = this.elements,
            b;
        b = a[1];
        a[1] = a[4];
        a[4] = b;
        b = a[2];
        a[2] = a[8];
        a[8] = b;
        b = a[6];
        a[6] = a[9];
        a[9] = b;
        b = a[3];
        a[3] = a[12];
        a[12] = b;
        b = a[7];
        a[7] = a[13];
        a[13] = b;
        b = a[11];
        a[11] = a[14];
        a[14] = b;
        return this
    },
    flattenToArray: function (a) {
        var b = this.elements;
        a[0] = b[0];
        a[1] = b[1];
        a[2] = b[2];
        a[3] = b[3];
        a[4] = b[4];
        a[5] = b[5];
        a[6] = b[6];
        a[7] = b[7];
        a[8] = b[8];
        a[9] = b[9];
        a[10] = b[10];
        a[11] = b[11];
        a[12] = b[12];
        a[13] = b[13];
        a[14] = b[14];
        a[15] = b[15];
        return a
    },
    flattenToArrayOffset: function (a, b) {
        var c = this.elements;
        a[b] = c[0];
        a[b + 1] = c[1];
        a[b + 2] = c[2];
        a[b + 3] = c[3];
        a[b + 4] = c[4];
        a[b + 5] = c[5];
        a[b + 6] = c[6];
        a[b + 7] = c[7];
        a[b + 8] = c[8];
        a[b + 9] = c[9];
        a[b + 10] = c[10];
        a[b + 11] = c[11];
        a[b + 12] = c[12];
        a[b + 13] = c[13];
        a[b + 14] = c[14];
        a[b + 15] = c[15];
        return a
    },
    getPosition: function () {
        var a = new THREE.Vector3;
        return function () {
            console.warn("DEPRECATED: Matrix4's .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
            var b = this.elements;
            return a.set(b[12], b[13], b[14])
        }
    }(),
    setPosition: function (a) {
        var b = this.elements;
        b[12] = a.x;
        b[13] = a.y;
        b[14] = a.z;
        return this
    },
    getInverse: function (a, b) {
        var c = this.elements,
            e = a.elements,
            d = e[0],
            g = e[4],
            f = e[8],
            k = e[12],
            h = e[1],
            l = e[5],
            m = e[9],
            n = e[13],
            r = e[2],
            s = e[6],
            t = e[10],
            p = e[14],
            u = e[3],
            v = e[7],
            w = e[11],
            e = e[15];
        c[0] = m * p * v - n * t * v + n * s * w - l * p * w - m * s * e + l * t * e;
        c[4] = k * t * v - f * p * v - k * s * w + g * p * w + f * s * e - g * t * e;
        c[8] = f * n * v - k * m * v + k * l * w - g * n * w - f * l * e + g * m * e;
        c[12] = k * m * s - f * n * s - k * l * t + g * n * t + f * l * p - g * m * p;
        c[1] = n * t * u - m * p * u - n * r * w + h * p * w + m * r * e - h * t * e;
        c[5] = f * p * u - k * t * u + k * r * w - d * p * w - f * r * e + d * t * e;
        c[9] = k * m * u - f * n * u - k * h * w + d * n * w + f * h * e -
            d * m * e;
        c[13] = f * n * r - k * m * r + k * h * t - d * n * t - f * h * p + d * m * p;
        c[2] = l * p * u - n * s * u + n * r * v - h * p * v - l * r * e + h * s * e;
        c[6] = k * s * u - g * p * u - k * r * v + d * p * v + g * r * e - d * s * e;
        c[10] = g * n * u - k * l * u + k * h * v - d * n * v - g * h * e + d * l * e;
        c[14] = k * l * r - g * n * r - k * h * s + d * n * s + g * h * p - d * l * p;
        c[3] = m * s * u - l * t * u - m * r * v + h * t * v + l * r * w - h * s * w;
        c[7] = g * t * u - f * s * u + f * r * v - d * t * v - g * r * w + d * s * w;
        c[11] = f * l * u - g * m * u - f * h * v + d * m * v + g * h * w - d * l * w;
        c[15] = g * m * r - f * l * r + f * h * s - d * m * s - g * h * t + d * l * t;
        c = d * c[0] + h * c[4] + r * c[8] + u * c[12];
        if (0 == c) {
            if (b) throw Error("Matrix4.getInverse(): can't invert matrix, determinant is 0");
            console.warn("Matrix4.getInverse(): can't invert matrix, determinant is 0");
            this.identity();
            return this
        }
        this.multiplyScalar(1 / c);
        return this
    },
    translate: function (a) {
        console.warn("DEPRECATED: Matrix4's .translate() has been removed.")
    },
    rotateX: function (a) {
        console.warn("DEPRECATED: Matrix4's .rotateX() has been removed.")
    },
    rotateY: function (a) {
        console.warn("DEPRECATED: Matrix4's .rotateY() has been removed.")
    },
    rotateZ: function (a) {
        console.warn("DEPRECATED: Matrix4's .rotateZ() has been removed.")
    },
    rotateByAxis: function (a, b) {
        console.warn("DEPRECATED: Matrix4's .rotateByAxis() has been removed.")
    },
    scale: function (a) {
        var b = this.elements,
            c = a.x,
            e = a.y;
        a = a.z;
        b[0] *= c;
        b[4] *= e;
        b[8] *= a;
        b[1] *= c;
        b[5] *= e;
        b[9] *= a;
        b[2] *= c;
        b[6] *= e;
        b[10] *= a;
        b[3] *= c;
        b[7] *= e;
        b[11] *= a;
        return this
    },
    getMaxScaleOnAxis: function () {
        var a = this.elements;
        return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], Math.max(a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10])))
    },
    makeTranslation: function (a, b, c) {
        this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);
        return this
    },
    makeRotationX: function (a) {
        var b = Math.cos(a);
        a = Math.sin(a);
        this.set(1,
            0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1);
        return this
    },
    makeRotationY: function (a) {
        var b = Math.cos(a);
        a = Math.sin(a);
        this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);
        return this
    },
    makeRotationZ: function (a) {
        var b = Math.cos(a);
        a = Math.sin(a);
        this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this
    },
    makeRotationAxis: function (a, b) {
        var c = Math.cos(b),
            e = Math.sin(b),
            d = 1 - c,
            g = a.x,
            f = a.y,
            k = a.z,
            h = d * g,
            l = d * f;
        this.set(h * g + c, h * f - e * k, h * k + e * f, 0, h * f + e * k, l * f + c, l * k - e * g, 0, h * k - e * f, l * k + e * g, d * k * k + c, 0, 0, 0, 0, 1);
        return this
    },
    makeScale: function (a, b, c) {
        this.set(a,
            0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);
        return this
    },
    compose: function (a, b, c) {
        this.makeRotationFromQuaternion(b);
        this.scale(c);
        this.setPosition(a);
        return this
    },
    decompose: function () {
        var a = new THREE.Vector3,
            b = new THREE.Matrix4;
        return function (c, e, d) {
            var g = this.elements,
                f = a.set(g[0], g[1], g[2]).length(),
                k = a.set(g[4], g[5], g[6]).length(),
                h = a.set(g[8], g[9], g[10]).length();
            0 > this.determinant() && (f = -f);
            c.x = g[12];
            c.y = g[13];
            c.z = g[14];
            b.elements.set(this.elements);
            c = 1 / f;
            var g = 1 / k,
                l = 1 / h;
            b.elements[0] *= c;
            b.elements[1] *=
                c;
            b.elements[2] *= c;
            b.elements[4] *= g;
            b.elements[5] *= g;
            b.elements[6] *= g;
            b.elements[8] *= l;
            b.elements[9] *= l;
            b.elements[10] *= l;
            e.setFromRotationMatrix(b);
            d.x = f;
            d.y = k;
            d.z = h;
            return this
        }
    }(),
    makeFrustum: function (a, b, c, e, d, g) {
        var f = this.elements;
        f[0] = 2 * d / (b - a);
        f[4] = 0;
        f[8] = (b + a) / (b - a);
        f[12] = 0;
        f[1] = 0;
        f[5] = 2 * d / (e - c);
        f[9] = (e + c) / (e - c);
        f[13] = 0;
        f[2] = 0;
        f[6] = 0;
        f[10] = -(g + d) / (g - d);
        f[14] = -2 * g * d / (g - d);
        f[3] = 0;
        f[7] = 0;
        f[11] = -1;
        f[15] = 0;
        return this
    },
    makePerspective: function (a, b, c, e) {
        a = c * Math.tan(THREE.Math.degToRad(0.5 * a));
        var d = -a;
        return this.makeFrustum(d * b, a * b, d, a, c, e)
    },
    makeOrthographic: function (a, b, c, e, d, g) {
        var f = this.elements,
            k = b - a,
            h = c - e,
            l = g - d;
        f[0] = 2 / k;
        f[4] = 0;
        f[8] = 0;
        f[12] = -((b + a) / k);
        f[1] = 0;
        f[5] = 2 / h;
        f[9] = 0;
        f[13] = -((c + e) / h);
        f[2] = 0;
        f[6] = 0;
        f[10] = -2 / l;
        f[14] = -((g + d) / l);
        f[3] = 0;
        f[7] = 0;
        f[11] = 0;
        f[15] = 1;
        return this
    },
    fromArray: function (a) {
        this.elements.set(a);
        return this
    },
    toArray: function () {
        var a = this.elements;
        return [a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]]
    },
    clone: function () {
        var a =
            this.elements;
        return new THREE.Matrix4(a[0], a[4], a[8], a[12], a[1], a[5], a[9], a[13], a[2], a[6], a[10], a[14], a[3], a[7], a[11], a[15])
    }
};
THREE.Ray = function (a, b) {
    this.origin = void 0 !== a ? a : new THREE.Vector3;
    this.direction = void 0 !== b ? b : new THREE.Vector3
};
THREE.Ray.prototype = {
    constructor: THREE.Ray,
    set: function (a, b) {
        this.origin.copy(a);
        this.direction.copy(b);
        return this
    },
    copy: function (a) {
        this.origin.copy(a.origin);
        this.direction.copy(a.direction);
        return this
    },
    at: function (a, b) {
        return (b || new THREE.Vector3).copy(this.direction).multiplyScalar(a).add(this.origin)
    },
    recast: function () {
        var a = new THREE.Vector3;
        return function (b) {
            this.origin.copy(this.at(b, a));
            return this
        }
    }(),
    closestPointToPoint: function (a, b) {
        var c = b || new THREE.Vector3;
        c.subVectors(a, this.origin);
        var e = c.dot(this.direction);
        return 0 > e ? c.copy(this.origin) : c.copy(this.direction).multiplyScalar(e).add(this.origin)
    },
    distanceToPoint: function () {
        var a = new THREE.Vector3;
        return function (b) {
            var c = a.subVectors(b, this.origin).dot(this.direction);
            if (0 > c) return this.origin.distanceTo(b);
            a.copy(this.direction).multiplyScalar(c).add(this.origin);
            return a.distanceTo(b)
        }
    }(),
    distanceSqToSegment: function (a, b, c, e) {
        var d = a.clone().add(b).multiplyScalar(0.5),
            g = b.clone().sub(a).normalize(),
            f = 0.5 * a.distanceTo(b),
            k = this.origin.clone().sub(d);
        a = -this.direction.dot(g);
        b = k.dot(this.direction);
        var h = -k.dot(g),
            l = k.lengthSq(),
            m = Math.abs(1 - a * a),
            n, r;
        0 <= m ? (k = a * h - b, n = a * b - h, r = f * m, 0 <= k ? n >= -r ? n <= r ? (f = 1 / m, k *= f, n *= f, a = k * (k + a * n + 2 * b) + n * (a * k + n + 2 * h) + l) : (n = f, k = Math.max(0, -(a * n + b)), a = -k * k + n * (n + 2 * h) + l) : (n = -f, k = Math.max(0, -(a * n + b)), a = -k * k + n * (n + 2 * h) + l) : n <= -r ? (k = Math.max(0, -(-a * f + b)), n = 0 < k ? -f : Math.min(Math.max(-f, -h), f), a = -k * k + n * (n + 2 * h) + l) : n <= r ? (k = 0, n = Math.min(Math.max(-f, -h), f), a = n * (n + 2 * h) + l) : (k = Math.max(0, -(a * f + b)), n = 0 < k ? f : Math.min(Math.max(-f, -h), f), a = -k * k + n * (n + 2 * h) + l)) : (n = 0 < a ? -f : f, k = Math.max(0, -(a * n + b)), a = -k * k + n * (n + 2 * h) + l);
        c && c.copy(this.direction.clone().multiplyScalar(k).add(this.origin));
        e && e.copy(g.clone().multiplyScalar(n).add(d));
        return a
    },
    isIntersectionSphere: function (a) {
        return this.distanceToPoint(a.center) <= a.radius
    },
    isIntersectionPlane: function (a) {
        var b = a.distanceToPoint(this.origin);
        return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1
    },
    distanceToPlane: function (a) {
        var b = a.normal.dot(this.direction);
        if (0 == b) return 0 == a.distanceToPoint(this.origin) ?
            0 : null;
        a = -(this.origin.dot(a.normal) + a.constant) / b;
        return 0 <= a ? a : null
    },
    intersectPlane: function (a, b) {
        var c = this.distanceToPlane(a);
        return null === c ? null : this.at(c, b)
    },
    isIntersectionBox: function () {
        var a = new THREE.Vector3;
        return function (b) {
            return null !== this.intersectBox(b, a)
        }
    }(),
    intersectBox: function (a, b) {
        var c, e, d, g, f;
        e = 1 / this.direction.x;
        g = 1 / this.direction.y;
        f = 1 / this.direction.z;
        var k = this.origin;
        0 <= e ? (c = (a.min.x - k.x) * e, e *= a.max.x - k.x) : (c = (a.max.x - k.x) * e, e *= a.min.x - k.x);
        0 <= g ? (d = (a.min.y - k.y) * g, g *=
            a.max.y - k.y) : (d = (a.max.y - k.y) * g, g *= a.min.y - k.y);
        if (c > g || d > e) return null;
        if (d > c || c !== c) c = d;
        if (g < e || e !== e) e = g;
        0 <= f ? (d = (a.min.z - k.z) * f, f *= a.max.z - k.z) : (d = (a.max.z - k.z) * f, f *= a.min.z - k.z);
        if (c > f || d > e) return null;
        if (d > c || c !== c) c = d;
        if (f < e || e !== e) e = f;
        return 0 > e ? null : this.at(0 <= c ? c : e, b)
    },
    intersectTriangle: function () {
        var a = new THREE.Vector3,
            b = new THREE.Vector3,
            c = new THREE.Vector3,
            e = new THREE.Vector3;
        return function (d, g, f, k, h) {
            b.subVectors(g, d);
            c.subVectors(f, d);
            e.crossVectors(b, c);
            g = this.direction.dot(e);
            if (0 <
                g) {
                if (k) return null;
                k = 1
            } else if (0 > g) k = -1, g = -g;
            else return null;
            a.subVectors(this.origin, d);
            d = k * this.direction.dot(c.crossVectors(a, c));
            if (0 > d) return null;
            f = k * this.direction.dot(b.cross(a));
            if (0 > f || d + f > g) return null;
            d = -k * a.dot(e);
            return 0 > d ? null : this.at(d / g, h)
        }
    }(),
    applyMatrix4: function (a) {
        this.direction.add(this.origin).applyMatrix4(a);
        this.origin.applyMatrix4(a);
        this.direction.sub(this.origin);
        this.direction.normalize();
        return this
    },
    equals: function (a) {
        return a.origin.equals(this.origin) && a.direction.equals(this.direction)
    },
    clone: function () {
        return (new THREE.Ray).copy(this)
    }
};
THREE.Sphere = function (a, b) {
    this.center = void 0 !== a ? a : new THREE.Vector3;
    this.radius = void 0 !== b ? b : 0
};
THREE.Sphere.prototype = {
    constructor: THREE.Sphere,
    set: function (a, b) {
        this.center.copy(a);
        this.radius = b;
        return this
    },
    setFromPoints: function () {
        var a = new THREE.Box3;
        return function (b, c) {
            var e = this.center;
            void 0 !== c ? e.copy(c) : a.setFromPoints(b).center(e);
            for (var d = 0, g = 0, f = b.length; g < f; g++) d = Math.max(d, e.distanceToSquared(b[g]));
            this.radius = Math.sqrt(d);
            return this
        }
    }(),
    copy: function (a) {
        this.center.copy(a.center);
        this.radius = a.radius;
        return this
    },
    empty: function () {
        return 0 >= this.radius
    },
    containsPoint: function (a) {
        return a.distanceToSquared(this.center) <=
            this.radius * this.radius
    },
    distanceToPoint: function (a) {
        return a.distanceTo(this.center) - this.radius
    },
    intersectsSphere: function (a) {
        var b = this.radius + a.radius;
        return a.center.distanceToSquared(this.center) <= b * b
    },
    clampPoint: function (a, b) {
        var c = this.center.distanceToSquared(a),
            e = b || new THREE.Vector3;
        e.copy(a);
        c > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center));
        return e
    },
    getBoundingBox: function (a) {
        a = a || new THREE.Box3;
        a.set(this.center, this.center);
        a.expandByScalar(this.radius);
        return a
    },
    applyMatrix4: function (a) {
        this.center.applyMatrix4(a);
        this.radius *= a.getMaxScaleOnAxis();
        return this
    },
    translate: function (a) {
        this.center.add(a);
        return this
    },
    equals: function (a) {
        return a.center.equals(this.center) && a.radius === this.radius
    },
    clone: function () {
        return (new THREE.Sphere).copy(this)
    }
};
THREE.Frustum = function (a, b, c, e, d, g) {
    this.planes = [void 0 !== a ? a : new THREE.Plane, void 0 !== b ? b : new THREE.Plane, void 0 !== c ? c : new THREE.Plane, void 0 !== e ? e : new THREE.Plane, void 0 !== d ? d : new THREE.Plane, void 0 !== g ? g : new THREE.Plane]
};
THREE.Frustum.prototype = {
    constructor: THREE.Frustum,
    set: function (a, b, c, e, d, g) {
        var f = this.planes;
        f[0].copy(a);
        f[1].copy(b);
        f[2].copy(c);
        f[3].copy(e);
        f[4].copy(d);
        f[5].copy(g);
        return this
    },
    copy: function (a) {
        for (var b = this.planes, c = 0; 6 > c; c++) b[c].copy(a.planes[c]);
        return this
    },
    setFromMatrix: function (a) {
        var b = this.planes,
            c = a.elements;
        a = c[0];
        var e = c[1],
            d = c[2],
            g = c[3],
            f = c[4],
            k = c[5],
            h = c[6],
            l = c[7],
            m = c[8],
            n = c[9],
            r = c[10],
            s = c[11],
            t = c[12],
            p = c[13],
            u = c[14],
            c = c[15];
        b[0].setComponents(g - a, l - f, s - m, c - t).normalize();
        b[1].setComponents(g +
            a, l + f, s + m, c + t).normalize();
        b[2].setComponents(g + e, l + k, s + n, c + p).normalize();
        b[3].setComponents(g - e, l - k, s - n, c - p).normalize();
        b[4].setComponents(g - d, l - h, s - r, c - u).normalize();
        b[5].setComponents(g + d, l + h, s + r, c + u).normalize();
        return this
    },
    intersectsObject: function () {
        var a = new THREE.Sphere;
        return function (b) {
            var c = b.geometry;
            null === c.boundingSphere && c.computeBoundingSphere();
            a.copy(c.boundingSphere);
            a.applyMatrix4(b.matrixWorld);
            return this.intersectsSphere(a)
        }
    }(),
    intersectsSphere: function (a) {
        var b = this.planes,
            c = a.center;
        a = -a.radius;
        for (var e = 0; 6 > e; e++)
            if (b[e].distanceToPoint(c) < a) return !1;
        return !0
    },
    intersectsBox: function () {
        var a = new THREE.Vector3,
            b = new THREE.Vector3;
        return function (c) {
            for (var e = this.planes, d = 0; 6 > d; d++) {
                var g = e[d];
                a.x = 0 < g.normal.x ? c.min.x : c.max.x;
                b.x = 0 < g.normal.x ? c.max.x : c.min.x;
                a.y = 0 < g.normal.y ? c.min.y : c.max.y;
                b.y = 0 < g.normal.y ? c.max.y : c.min.y;
                a.z = 0 < g.normal.z ? c.min.z : c.max.z;
                b.z = 0 < g.normal.z ? c.max.z : c.min.z;
                var f = g.distanceToPoint(a),
                    g = g.distanceToPoint(b);
                if (0 > f && 0 > g) return !1
            }
            return !0
        }
    }(),
    containsPoint: function (a) {
        for (var b = this.planes, c = 0; 6 > c; c++)
            if (0 > b[c].distanceToPoint(a)) return !1;
        return !0
    },
    clone: function () {
        return (new THREE.Frustum).copy(this)
    }
};
THREE.Plane = function (a, b) {
    this.normal = void 0 !== a ? a : new THREE.Vector3(1, 0, 0);
    this.constant = void 0 !== b ? b : 0
};
THREE.Plane.prototype = {
    constructor: THREE.Plane,
    set: function (a, b) {
        this.normal.copy(a);
        this.constant = b;
        return this
    },
    setComponents: function (a, b, c, e) {
        this.normal.set(a, b, c);
        this.constant = e;
        return this
    },
    setFromNormalAndCoplanarPoint: function (a, b) {
        this.normal.copy(a);
        this.constant = -b.dot(this.normal);
        return this
    },
    setFromCoplanarPoints: function () {
        var a = new THREE.Vector3,
            b = new THREE.Vector3;
        return function (c, e, d) {
            e = a.subVectors(d, e).cross(b.subVectors(c, e)).normalize();
            this.setFromNormalAndCoplanarPoint(e,
                c);
            return this
        }
    }(),
    copy: function (a) {
        this.normal.copy(a.normal);
        this.constant = a.constant;
        return this
    },
    normalize: function () {
        var a = 1 / this.normal.length();
        this.normal.multiplyScalar(a);
        this.constant *= a;
        return this
    },
    negate: function () {
        this.constant *= -1;
        this.normal.negate();
        return this
    },
    distanceToPoint: function (a) {
        return this.normal.dot(a) + this.constant
    },
    distanceToSphere: function (a) {
        return this.distanceToPoint(a.center) - a.radius
    },
    projectPoint: function (a, b) {
        return this.orthoPoint(a, b).sub(a).negate()
    },
    orthoPoint: function (a,
        b) {
        var c = this.distanceToPoint(a);
        return (b || new THREE.Vector3).copy(this.normal).multiplyScalar(c)
    },
    isIntersectionLine: function (a) {
        var b = this.distanceToPoint(a.start);
        a = this.distanceToPoint(a.end);
        return 0 > b && 0 < a || 0 > a && 0 < b
    },
    intersectLine: function () {
        var a = new THREE.Vector3;
        return function (b, c) {
            var e = c || new THREE.Vector3,
                d = b.delta(a),
                g = this.normal.dot(d);
            if (0 == g) {
                if (0 == this.distanceToPoint(b.start)) return e.copy(b.start)
            } else return g = -(b.start.dot(this.normal) + this.constant) / g, 0 > g || 1 < g ? void 0 : e.copy(d).multiplyScalar(g).add(b.start)
        }
    }(),
    coplanarPoint: function (a) {
        return (a || new THREE.Vector3).copy(this.normal).multiplyScalar(-this.constant)
    },
    applyMatrix4: function () {
        var a = new THREE.Vector3,
            b = new THREE.Vector3,
            c = new THREE.Matrix3;
        return function (e, d) {
            var g = d || c.getNormalMatrix(e),
                g = a.copy(this.normal).applyMatrix3(g),
                f = this.coplanarPoint(b);
            f.applyMatrix4(e);
            this.setFromNormalAndCoplanarPoint(g, f);
            return this
        }
    }(),
    translate: function (a) {
        this.constant -= a.dot(this.normal);
        return this
    },
    equals: function (a) {
        return a.normal.equals(this.normal) &&
            a.constant == this.constant
    },
    clone: function () {
        return (new THREE.Plane).copy(this)
    }
};
THREE.Math = {
    PI2: 2 * Math.PI,
    generateUUID: function () {
        var a = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
            b = Array(36),
            c = 0,
            e;
        return function () {
            for (var d = 0; 36 > d; d++) 8 == d || 13 == d || 18 == d || 23 == d ? b[d] = "-" : 14 == d ? b[d] = "4" : (2 >= c && (c = 33554432 + 16777216 * Math.random() | 0), e = c & 15, c >>= 4, b[d] = a[19 == d ? e & 3 | 8 : e]);
            return b.join("")
        }
    }(),
    clamp: function (a, b, c) {
        return a < b ? b : a > c ? c : a
    },
    clampBottom: function (a, b) {
        return a < b ? b : a
    },
    mapLinear: function (a, b, c, e, d) {
        return e + (a - b) * (d - e) / (c - b)
    },
    smoothstep: function (a,
        b, c) {
        if (a <= b) return 0;
        if (a >= c) return 1;
        a = (a - b) / (c - b);
        return a * a * (3 - 2 * a)
    },
    smootherstep: function (a, b, c) {
        if (a <= b) return 0;
        if (a >= c) return 1;
        a = (a - b) / (c - b);
        return a * a * a * (a * (6 * a - 15) + 10)
    },
    random16: function () {
        return (65280 * Math.random() + 255 * Math.random()) / 65535
    },
    randInt: function (a, b) {
        return a + Math.floor(Math.random() * (b - a + 1))
    },
    randFloat: function (a, b) {
        return a + Math.random() * (b - a)
    },
    randFloatSpread: function (a) {
        return a * (0.5 - Math.random())
    },
    sign: function (a) {
        return 0 > a ? -1 : 0 < a ? 1 : 0
    },
    degToRad: function () {
        var a = Math.PI /
            180;
        return function (b) {
            return b * a
        }
    }(),
    radToDeg: function () {
        var a = 180 / Math.PI;
        return function (b) {
            return b * a
        }
    }(),
    isPowerOfTwo: function (a) {
        return 0 === (a & a - 1) && 0 !== a
    }
};
THREE.Spline = function (a) {
    function b(a, b, f, d, c, k, e) {
        a = 0.5 * (f - a);
        d = 0.5 * (d - b);
        return (2 * (b - f) + a + d) * e + (-3 * (b - f) - 2 * a - d) * k + a * c + b
    }
    this.points = a;
    var c = [],
        e = {
            x: 0,
            y: 0,
            z: 0
        },
        d, g, f, k, h, l, m, n, r;
    this.initFromArray = function (a) {
        this.points = [];
        for (var b = 0; b < a.length; b++) this.points[b] = {
            x: a[b][0],
            y: a[b][1],
            z: a[b][2]
        }
    };
    this.getPoint = function (a) {
        d = (this.points.length - 1) * a;
        g = Math.floor(d);
        f = d - g;
        c[0] = 0 === g ? g : g - 1;
        c[1] = g;
        c[2] = g > this.points.length - 2 ? this.points.length - 1 : g + 1;
        c[3] = g > this.points.length - 3 ? this.points.length - 1 :
            g + 2;
        l = this.points[c[0]];
        m = this.points[c[1]];
        n = this.points[c[2]];
        r = this.points[c[3]];
        k = f * f;
        h = f * k;
        e.x = b(l.x, m.x, n.x, r.x, f, k, h);
        e.y = b(l.y, m.y, n.y, r.y, f, k, h);
        e.z = b(l.z, m.z, n.z, r.z, f, k, h);
        return e
    };
    this.getControlPointsArray = function () {
        var a, b, f = this.points.length,
            d = [];
        for (a = 0; a < f; a++) b = this.points[a], d[a] = [b.x, b.y, b.z];
        return d
    };
    this.getLength = function (a) {
        var b, f, d, c = 0,
            k = new THREE.Vector3,
            e = new THREE.Vector3,
            h = [],
            g = 0;
        h[0] = 0;
        a || (a = 100);
        f = this.points.length * a;
        k.copy(this.points[0]);
        for (a = 1; a < f; a++) b = a /
            f, d = this.getPoint(b), e.copy(d), g += e.distanceTo(k), k.copy(d), b *= this.points.length - 1, b = Math.floor(b), b != c && (h[b] = g, c = b);
        h[h.length] = g;
        return {
            chunks: h,
            total: g
        }
    };
    this.reparametrizeByArcLength = function (a) {
        var b, f, d, c, k, e, h = [],
            g = new THREE.Vector3,
            l = this.getLength();
        h.push(g.copy(this.points[0]).clone());
        for (b = 1; b < this.points.length; b++) {
            f = l.chunks[b] - l.chunks[b - 1];
            e = Math.ceil(a * f / l.total);
            c = (b - 1) / (this.points.length - 1);
            k = b / (this.points.length - 1);
            for (f = 1; f < e - 1; f++) d = c + 1 / e * f * (k - c), d = this.getPoint(d), h.push(g.copy(d).clone());
            h.push(g.copy(this.points[b]).clone())
        }
        this.points = h
    }
};
THREE.Triangle = function (a, b, c) {
    this.a = void 0 !== a ? a : new THREE.Vector3;
    this.b = void 0 !== b ? b : new THREE.Vector3;
    this.c = void 0 !== c ? c : new THREE.Vector3
};
THREE.Triangle.normal = function () {
    var a = new THREE.Vector3;
    return function (b, c, e, d) {
        d = d || new THREE.Vector3;
        d.subVectors(e, c);
        a.subVectors(b, c);
        d.cross(a);
        b = d.lengthSq();
        return 0 < b ? d.multiplyScalar(1 / Math.sqrt(b)) : d.set(0, 0, 0)
    }
}();
THREE.Triangle.barycoordFromPoint = function () {
    var a = new THREE.Vector3,
        b = new THREE.Vector3,
        c = new THREE.Vector3;
    return function (e, d, g, f, k) {
        a.subVectors(f, d);
        b.subVectors(g, d);
        c.subVectors(e, d);
        e = a.dot(a);
        d = a.dot(b);
        g = a.dot(c);
        var h = b.dot(b);
        f = b.dot(c);
        var l = e * h - d * d;
        k = k || new THREE.Vector3;
        if (0 == l) return k.set(-2, -1, -1);
        l = 1 / l;
        h = (h * g - d * f) * l;
        e = (e * f - d * g) * l;
        return k.set(1 - h - e, e, h)
    }
}();
THREE.Triangle.containsPoint = function () {
    var a = new THREE.Vector3;
    return function (b, c, e, d) {
        b = THREE.Triangle.barycoordFromPoint(b, c, e, d, a);
        return 0 <= b.x && 0 <= b.y && 1 >= b.x + b.y
    }
}();
THREE.Triangle.prototype = {
    constructor: THREE.Triangle,
    set: function (a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this
    },
    setFromPointsAndIndices: function (a, b, c, e) {
        this.a.copy(a[b]);
        this.b.copy(a[c]);
        this.c.copy(a[e]);
        return this
    },
    copy: function (a) {
        this.a.copy(a.a);
        this.b.copy(a.b);
        this.c.copy(a.c);
        return this
    },
    area: function () {
        var a = new THREE.Vector3,
            b = new THREE.Vector3;
        return function () {
            a.subVectors(this.c, this.b);
            b.subVectors(this.a, this.b);
            return 0.5 * a.cross(b).length()
        }
    }(),
    midpoint: function (a) {
        return (a ||
            new THREE.Vector3).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    },
    normal: function (a) {
        return THREE.Triangle.normal(this.a, this.b, this.c, a)
    },
    plane: function (a) {
        return (a || new THREE.Plane).setFromCoplanarPoints(this.a, this.b, this.c)
    },
    barycoordFromPoint: function (a, b) {
        return THREE.Triangle.barycoordFromPoint(a, this.a, this.b, this.c, b)
    },
    containsPoint: function (a) {
        return THREE.Triangle.containsPoint(a, this.a, this.b, this.c)
    },
    equals: function (a) {
        return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c)
    },
    clone: function () {
        return (new THREE.Triangle).copy(this)
    }
};
THREE.Vertex = function (a) {
    console.warn("THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.");
    return a
};
THREE.UV = function (a, b) {
    console.warn("THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.");
    return new THREE.Vector2(a, b)
};
THREE.Clock = function (a) {
    this.autoStart = void 0 !== a ? a : !0;
    this.elapsedTime = this.oldTime = this.startTime = 0;
    this.running = !1
};
THREE.Clock.prototype = {
    constructor: THREE.Clock,
    start: function () {
        this.oldTime = this.startTime = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now();
        this.running = !0
    },
    stop: function () {
        this.getElapsedTime();
        this.running = !1
    },
    getElapsedTime: function () {
        this.getDelta();
        return this.elapsedTime
    },
    getDelta: function () {
        var a = 0;
        this.autoStart && !this.running && this.start();
        if (this.running) {
            var b = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(),
                a = 0.001 * (b - this.oldTime);
            this.oldTime = b;
            this.elapsedTime += a
        }
        return a
    }
};
THREE.EventDispatcher = function () {};
THREE.EventDispatcher.prototype = {
    constructor: THREE.EventDispatcher,
    apply: function (a) {
        a.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
        a.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
        a.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
        a.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent
    },
    addEventListener: function (a, b) {
        void 0 === this._listeners && (this._listeners = {});
        var c = this._listeners;
        void 0 === c[a] && (c[a] = []); - 1 === c[a].indexOf(b) &&
            c[a].push(b)
    },
    hasEventListener: function (a, b) {
        if (void 0 === this._listeners) return !1;
        var c = this._listeners;
        return void 0 !== c[a] && -1 !== c[a].indexOf(b) ? !0 : !1
    },
    removeEventListener: function (a, b) {
        if (void 0 !== this._listeners) {
            var c = this._listeners[a];
            if (void 0 !== c) {
                var e = c.indexOf(b); - 1 !== e && c.splice(e, 1)
            }
        }
    },
    dispatchEvent: function () {
        var a = [];
        return function (b) {
            if (void 0 !== this._listeners) {
                var c = this._listeners[b.type];
                if (void 0 !== c) {
                    b.target = this;
                    for (var e = c.length, d = 0; d < e; d++) a[d] = c[d];
                    for (d = 0; d < e; d++) a[d].call(this,
                        b)
                }
            }
        }
    }()
};
(function (a) {
    a.Raycaster = function (b, f, d, c) {
        this.ray = new a.Ray(b, f);
        this.near = d || 0;
        this.far = c || Infinity
    };
    var b = new a.Sphere,
        c = new a.Ray;
    new a.Plane;
    new a.Vector3;
    var e = new a.Vector3,
        d = new a.Matrix4,
        g = function (a, b) {
            return a.distance - b.distance
        },
        f = new a.Vector3,
        k = new a.Vector3,
        h = new a.Vector3,
        l = function (g, m, s) {
            if (g instanceof a.Sprite) {
                e.setFromMatrixPosition(g.matrixWorld);
                var t = m.ray.distanceToPoint(e);
                if (t > g.scale.x) return s;
                s.push({
                    distance: t,
                    point: g.position,
                    face: null,
                    object: g
                })
            } else if (g instanceof a.LOD) e.setFromMatrixPosition(g.matrixWorld),
                t = m.ray.origin.distanceTo(e), l(g.getObjectForDistance(t), m, s);
            else if (g instanceof a.Mesh) {
                var p = g.geometry;
                null === p.boundingSphere && p.computeBoundingSphere();
                b.copy(p.boundingSphere);
                b.applyMatrix4(g.matrixWorld);
                if (!1 === m.ray.isIntersectionSphere(b)) return s;
                d.getInverse(g.matrixWorld);
                c.copy(m.ray).applyMatrix4(d);
                if (null !== p.boundingBox && !1 === c.isIntersectionBox(p.boundingBox)) return s;
                if (p instanceof a.BufferGeometry) {
                    var u = g.material;
                    if (void 0 === u) return s;
                    var v = p.attributes,
                        w, y, x = m.precision;
                    if (void 0 !== v.index)
                        for (var A = p.offsets, N = v.index.array, B = p.vb ? p.vb : v.position.array, G = p.vb ? p.vbstride : 3, C = 0, P = A.length; C < P; ++C)
                            for (var v = A[C].start, z = A[C].index, p = v, Q = v + A[C].count; p < Q; p += 3) {
                                v = z + N[p];
                                w = z + N[p + 1];
                                y = z + N[p + 2];
                                f.set(B[v * G], B[v * G + 1], B[v * G + 2]);
                                k.set(B[w * G], B[w * G + 1], B[w * G + 2]);
                                h.set(B[y * G], B[y * G + 1], B[y * G + 2]);
                                var F = u.side === a.BackSide ? c.intersectTriangle(h, k, f, !0) : c.intersectTriangle(f, k, h, u.side !== a.DoubleSide);
                                null !== F && (F.applyMatrix4(g.matrixWorld), t = m.ray.origin.distanceTo(F), t < x || t < m.near ||
                                    t > m.far || s.push({
                                        distance: t,
                                        point: F,
                                        indices: [v, w, y],
                                        face: null,
                                        faceIndex: null,
                                        object: g
                                    }))
                            } else
                                for (B = p.vb ? p.vb : v.position.array, G = p.vb ? p.vbstride : 3, p = 0, Q = v.position.array.length; p < Q; p += 3) v = p, w = p + 1, y = p + 2, f.set(B[v * G], B[v * G + 1], B[v * G + 2]), k.set(B[w * G], B[w * G + 1], B[w * G + 2]), h.set(B[y * G], B[y * G + 1], B[y * G + 2]), F = u.side === a.BackSide ? c.intersectTriangle(h, k, f, !0) : c.intersectTriangle(f, k, h, u.side !== a.DoubleSide), null !== F && (F.applyMatrix4(g.matrixWorld), t = m.ray.origin.distanceTo(F), t < x || t < m.near || t > m.far || s.push({
                                    distance: t,
                                    point: F,
                                    indices: [v, w, y],
                                    face: null,
                                    faceIndex: null,
                                    object: g
                                }))
                } else if (p instanceof a.Geometry)
                    for (N = g.material instanceof a.MeshFaceMaterial, B = !0 === N ? g.material.materials : null, x = m.precision, A = p.vertices, G = 0, C = p.faces.length; G < C; G++)
                        if (P = p.faces[G], u = !0 === N ? B[P.materialIndex] : g.material, void 0 !== u) {
                            v = A[P.a];
                            w = A[P.b];
                            y = A[P.c];
                            if (!0 === u.morphTargets) {
                                t = p.morphTargets;
                                F = g.morphTargetInfluences;
                                f.set(0, 0, 0);
                                k.set(0, 0, 0);
                                h.set(0, 0, 0);
                                z = 0;
                                for (Q = t.length; z < Q; z++) {
                                    var O = F[z];
                                    if (0 !== O) {
                                        var T = t[z].vertices;
                                        f.x +=
                                            (T[P.a].x - v.x) * O;
                                        f.y += (T[P.a].y - v.y) * O;
                                        f.z += (T[P.a].z - v.z) * O;
                                        k.x += (T[P.b].x - w.x) * O;
                                        k.y += (T[P.b].y - w.y) * O;
                                        k.z += (T[P.b].z - w.z) * O;
                                        h.x += (T[P.c].x - y.x) * O;
                                        h.y += (T[P.c].y - y.y) * O;
                                        h.z += (T[P.c].z - y.z) * O
                                    }
                                }
                                f.add(v);
                                k.add(w);
                                h.add(y);
                                v = f;
                                w = k;
                                y = h
                            }
                            F = u.side === a.BackSide ? c.intersectTriangle(y, w, v, !0) : c.intersectTriangle(v, w, y, u.side !== a.DoubleSide);
                            null !== F && (F.applyMatrix4(g.matrixWorld), t = m.ray.origin.distanceTo(F), t < x || t < m.near || t > m.far || s.push({
                                distance: t,
                                point: F,
                                face: P,
                                faceIndex: G,
                                object: g
                            }))
                        }
            } else if (g instanceof a.Line) {
                x = m.linePrecision;
                u = x * x;
                p = g.geometry;
                null === p.boundingSphere && p.computeBoundingSphere();
                b.copy(p.boundingSphere);
                b.applyMatrix4(g.matrixWorld);
                if (!1 === m.ray.isIntersectionSphere(b)) return s;
                d.getInverse(g.matrixWorld);
                c.copy(m.ray).applyMatrix4(d);
                if (p instanceof a.Geometry)
                    for (A = p.vertices, x = A.length, v = new a.Vector3, w = new a.Vector3, y = g.type === a.LineStrip ? 1 : 2, p = 0; p < x - 1; p += y) c.distanceSqToSegment(A[p], A[p + 1], w, v) > u || (t = c.origin.distanceTo(w), t < m.near || t > m.far || s.push({
                        distance: t,
                        point: v.clone().applyMatrix4(g.matrixWorld),
                        face: null,
                        faceIndex: null,
                        object: g
                    }))
            }
        },
        m = function (a, b, f) {
            a = a.getDescendants();
            for (var d = 0, c = a.length; d < c; d++) l(a[d], b, f)
        };
    a.Raycaster.prototype.precision = 1E-4;
    a.Raycaster.prototype.linePrecision = 1;
    a.Raycaster.prototype.set = function (a, b) {
        this.ray.set(a, b)
    };
    a.Raycaster.prototype.intersectObject = function (a, b) {
        var f = [];
        !0 === b && m(a, this, f);
        l(a, this, f);
        f.sort(g);
        return f
    };
    a.Raycaster.prototype.intersectObjects = function (a, b) {
        for (var f = [], d = 0, c = a.length; d < c; d++) l(a[d], this, f), !0 === b && m(a[d], this, f);
        f.sort(g);
        return f
    }
})(THREE);
THREE.Object3D = function (a) {
    this.id = THREE.Object3DIdCount++;
    this.parent = void 0;
    a ? (this.matrixAutoUpdate = !1, this.skipModTerms = !0) : (this.up = new THREE.Vector3(0, 1, 0), this.position = new THREE.Vector3, this._rotation = new THREE.Euler, this._quaternion = new THREE.Quaternion, this.scale = new THREE.Vector3(1, 1, 1), this._rotation._quaternion = this.quaternion, this._quaternion._euler = this.rotation, this.matrixAutoUpdate = !0, this.matrix = new THREE.Matrix4, this.skipModTerms = !1);
    this.renderDepth = null;
    this.rotationAutoUpdate = !0;
    this.matrixWorld = new THREE.Matrix4;
    this.visible = this.matrixWorldNeedsUpdate = !0;
    this.receiveShadow = this.castShadow = !1;
    this.frustumCulled = !0
};
THREE.Object3D.prototype = {
    constructor: THREE.Object3D,
    get rotation() {
        return this._rotation
    },
    set rotation(a) {
        this._rotation = a;
        this._rotation._quaternion = this._quaternion;
        this._quaternion._euler = this._rotation;
        this._rotation._updateQuaternion()
    },
    get quaternion() {
        return this._quaternion
    },
    set quaternion(a) {
        this._quaternion = a;
        this._quaternion._euler = this._rotation;
        this._rotation._quaternion = this._quaternion;
        this._quaternion._updateEuler()
    },
    get eulerOrder() {
        console.warn("DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order.");
        return this.rotation.order
    },
    set eulerOrder(a) {
        console.warn("DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order.");
        this.rotation.order = a
    },
    get useQuaternion() {
        console.warn("DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.")
    },
    set useQuaternion(a) {
        console.warn("DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.")
    },
    applyMatrix: function (a) {
        this.matrix.multiplyMatrices(a, this.matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    },
    setRotationFromAxisAngle: function (a, b) {
        this.quaternion.setFromAxisAngle(a, b)
    },
    setRotationFromEuler: function (a) {
        this.quaternion.setFromEuler(a, !0)
    },
    setRotationFromMatrix: function (a) {
        this.quaternion.setFromRotationMatrix(a)
    },
    setRotationFromQuaternion: function (a) {
        this.quaternion.copy(a)
    },
    rotateOnAxis: function () {
        var a = new THREE.Quaternion;
        return function (b, c) {
            a.setFromAxisAngle(b, c);
            this.quaternion.multiply(a);
            return this
        }
    }(),
    rotateX: function () {
        var a =
            new THREE.Vector3(1, 0, 0);
        return function (b) {
            return this.rotateOnAxis(a, b)
        }
    }(),
    rotateY: function () {
        var a = new THREE.Vector3(0, 1, 0);
        return function (b) {
            return this.rotateOnAxis(a, b)
        }
    }(),
    rotateZ: function () {
        var a = new THREE.Vector3(0, 0, 1);
        return function (b) {
            return this.rotateOnAxis(a, b)
        }
    }(),
    translateOnAxis: function () {
        var a = new THREE.Vector3;
        return function (b, c) {
            a.copy(b);
            a.applyQuaternion(this.quaternion);
            this.position.add(a.multiplyScalar(c));
            return this
        }
    }(),
    translate: function (a, b) {
        console.warn("DEPRECATED: Object3D's .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed.");
        return this.translateOnAxis(b, a)
    },
    translateX: function () {
        var a = new THREE.Vector3(1, 0, 0);
        return function (b) {
            return this.translateOnAxis(a, b)
        }
    }(),
    translateY: function () {
        var a = new THREE.Vector3(0, 1, 0);
        return function (b) {
            return this.translateOnAxis(a, b)
        }
    }(),
    translateZ: function () {
        var a = new THREE.Vector3(0, 0, 1);
        return function (b) {
            return this.translateOnAxis(a, b)
        }
    }(),
    localToWorld: function (a) {
        return a.applyMatrix4(this.matrixWorld)
    },
    worldToLocal: function () {
        var a = new THREE.Matrix4;
        return function (b) {
            return b.applyMatrix4(a.getInverse(this.matrixWorld))
        }
    }(),
    lookAt: function () {
        var a = new THREE.Matrix4;
        return function (b) {
            a.lookAt(b, this.position, this.up);
            this.quaternion.setFromRotationMatrix(a)
        }
    }(),
    add: function (a) {
        if (a === this) console.warn("THREE.Object3D.add: An object can't be added as a child of itself.");
        else if (a instanceof THREE.Object3D) {
            void 0 !== a.parent && a.parent.remove(a);
            a.parent = this;
            a.dispatchEvent({
                type: "added"
            });
            this.children || (this.children = []);
            this.children.push(a);
            for (var b = this; void 0 !== b.parent;) b = b.parent;
            void 0 !== b && b instanceof THREE.Scene &&
                b.__addObject(a)
        }
    },
    remove: function (a) {
        var b = this.children.indexOf(a);
        if (-1 !== b) {
            a.parent = void 0;
            a.dispatchEvent({
                type: "removed"
            });
            this.children.splice(b, 1);
            for (b = this; void 0 !== b.parent;) b = b.parent;
            void 0 !== b && b instanceof THREE.Scene && b.__removeObject(a)
        }
    },
    traverse: function (a) {
        a(this);
        for (var b = 0, c = this.children.length; b < c; b++) this.children[b].traverse(a)
    },
    getObjectById: function (a, b) {
        for (var c = 0, e = this.children.length; c < e; c++) {
            var d = this.children[c];
            if (d.id === a || !0 === b && (d = d.getObjectById(a, b), void 0 !==
                d)) return d
        }
    },
    getObjectByName: function (a, b) {
        for (var c = 0, e = this.children.length; c < e; c++) {
            var d = this.children[c];
            if (d.name === a || !0 === b && (d = d.getObjectByName(a, b), void 0 !== d)) return d
        }
    },
    getChildByName: function (a, b) {
        console.warn("DEPRECATED: Object3D's .getChildByName() has been renamed to .getObjectByName().");
        return this.getObjectByName(a, b)
    },
    getDescendants: function (a) {
        if (!this.children) return null;
        void 0 === a && (a = []);
        Array.prototype.push.apply(a, this.children);
        for (var b = 0, c = this.children.length; b < c; b++) this.children[b].getDescendants(a);
        return a
    },
    updateMatrix: function () {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = !0
    },
    updateMatrixWorld: function (a) {
        !0 === this.matrixAutoUpdate && this.updateMatrix();
        if (!0 === this.matrixWorldNeedsUpdate || !0 === a) void 0 === this.parent && this.matrix ? this.matrixWorld.copy(this.matrix) : this.matrix && this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
        if (this.children)
            for (var b = 0, c = this.children.length; b < c; b++) this.children[b].updateMatrixWorld(a)
    },
    clone: function (a, b) {
        void 0 === a && (a = new THREE.Object3D(this.skipModTerms));
        void 0 === b && (b = !0);
        this.name && (a.name = this.name);
        this.skipModTerms || (a.up.copy(this.up), a.position.copy(this.position), a.quaternion.copy(this.quaternion), a.scale.copy(this.scale));
        a.renderDepth = this.renderDepth;
        a.rotationAutoUpdate = this.rotationAutoUpdate;
        this.matrix ? a.matrix.copy(this.matrix) : a.matrix = null;
        a.matrixWorld.copy(this.matrixWorld);
        a.matrixAutoUpdate = this.matrixAutoUpdate;
        a.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;
        a.visible = this.visible;
        a.castShadow = this.castShadow;
        a.receiveShadow = this.receiveShadow;
        a.frustumCulled = this.frustumCulled;
        a.userData = JSON.parse(JSON.stringify(this.userData));
        if (!0 === b && this.children)
            for (var c = 0; c < this.children.length; c++) a.add(this.children[c].clone());
        return a
    }
};
THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);
THREE.Object3DIdCount = 0;
THREE.Projector = function () {
    function a() {
        if (m === r) {
            var a = new THREE.RenderableVertex;
            n.push(a);
            r++;
            m++;
            return a
        }
        return n[m++]
    }

    function b() {
        if (t === u) {
            var a = new THREE.RenderableFace;
            p.push(a);
            u++;
            t++;
            return a
        }
        return p[t++]
    }

    function c() {
        if (w === x) {
            var a = new THREE.RenderableLine;
            y.push(a);
            x++;
            w++;
            return a
        }
        return y[w++]
    }

    function e(a, b) {
        return a.z !== b.z ? b.z - a.z : a.id !== b.id ? a.id - b.id : 0
    }

    function d(a, b) {
        var f = 0,
            d = 1,
            c = a.z + a.w,
            k = b.z + b.w,
            e = -a.z + a.w,
            h = -b.z + b.w;
        if (0 <= c && 0 <= k && 0 <= e && 0 <= h) return !0;
        if (0 > c && 0 > k || 0 > e &&
            0 > h) return !1;
        0 > c ? f = Math.max(f, c / (c - k)) : 0 > k && (d = Math.min(d, c / (c - k)));
        0 > e ? f = Math.max(f, e / (e - h)) : 0 > h && (d = Math.min(d, e / (e - h)));
        if (d < f) return !1;
        a.lerp(b, f);
        b.lerp(a, 1 - d);
        return !0
    }
    var g, f, k = [],
        h = 0,
        l, m, n = [],
        r = 0,
        s, t, p = [],
        u = 0,
        v, w, y = [],
        x = 0,
        A, N, B = [],
        G = 0,
        C = {
            objects: [],
            lights: [],
            elements: []
        },
        P = new THREE.Vector3,
        z = new THREE.Vector3,
        Q = new THREE.Vector3,
        F = new THREE.Vector3,
        O = new THREE.Vector4,
        T = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)),
        D = new THREE.Box3,
        J = Array(3),
        I = new THREE.Matrix4,
        U =
        new THREE.Matrix4,
        M, Y = new THREE.Matrix4,
        S = new THREE.Matrix3,
        X = new THREE.Frustum,
        K = new THREE.Vector4,
        ca = new THREE.Vector4;
    this.projectVector = function (a, b) {
        b.matrixWorldInverse.getInverse(b.matrixWorld);
        U.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
        return a.applyProjection(U)
    };
    this.unprojectVector = function () {
        var a = new THREE.Matrix4;
        return function (b, f) {
            a.getInverse(f.projectionMatrix);
            U.multiplyMatrices(f.matrixWorld, a);
            return b.applyProjection(U)
        }
    }();
    this.pickingRay = function (a, b) {
        a.z = -1;
        var f = new THREE.Vector3(a.x, a.y, 1);
        this.unprojectVector(a, b);
        this.unprojectVector(f, b);
        f.sub(a).normalize();
        return new THREE.Raycaster(a, f)
    };
    var ba = function (a) {
            if (!1 !== a.visible) {
                if (a instanceof THREE.Light) C.lights.push(a);
                else if (a instanceof THREE.Mesh || a instanceof THREE.Line || a instanceof THREE.Sprite)
                    if (!1 === a.frustumCulled || !0 === X.intersectsObject(a)) {
                        if (f === h) {
                            var b = new THREE.RenderableObject;
                            k.push(b);
                            h++;
                            f++;
                            g = b
                        } else g = k[f++];
                        g.id = a.id;
                        g.object = a;
                        null !== a.renderDepth ? g.z = a.renderDepth :
                            (F.setFromMatrixPosition(a.matrixWorld), F.applyProjection(U), g.z = F.z);
                        C.objects.push(g)
                    }
                for (var b = 0, d = a.children.length; b < d; b++) ba(a.children[b])
            }
        },
        aa = new function () {
            var f = [],
                d = null,
                k = new THREE.Matrix3,
                e = function (a) {
                    var b = a.positionWorld,
                        f = a.positionScreen;
                    b.copy(a.position).applyMatrix4(M);
                    f.copy(b).applyMatrix4(U);
                    b = 1 / f.w;
                    f.x *= b;
                    f.y *= b;
                    f.z *= b;
                    a.visible = -1 <= f.x && 1 >= f.x && -1 <= f.y && 1 >= f.y && -1 <= f.z && 1 >= f.z
                },
                h = function (a, b, f) {
                    J[0] = a.positionScreen;
                    J[1] = b.positionScreen;
                    J[2] = f.positionScreen;
                    return !0 ===
                        a.visible || !0 === b.visible || !0 === f.visible || T.isIntersectionBox(D.setFromPoints(J)) ? 0 > (f.positionScreen.x - a.positionScreen.x) * (b.positionScreen.y - a.positionScreen.y) - (f.positionScreen.y - a.positionScreen.y) * (b.positionScreen.x - a.positionScreen.x) : !1
                };
            return {
                setObject: function (a) {
                    d = a;
                    k.getNormalMatrix(d.matrixWorld);
                    f.length = 0
                },
                projectVertex: e,
                checkTriangleVisibility: h,
                pushVertex: function (b, f, d) {
                    l = a();
                    l.position.set(b, f, d);
                    e(l)
                },
                pushNormal: function (a, b, d) {
                    f.push(a, b, d)
                },
                pushLine: function (a, b) {
                    var f =
                        n[a],
                        k = n[b];
                    v = c();
                    v.id = d.id;
                    v.v1.copy(f);
                    v.v2.copy(k);
                    v.z = (f.positionScreen.z + k.positionScreen.z) / 2;
                    v.material = d.material;
                    C.elements.push(v)
                },
                pushTriangle: function (a, c, e) {
                    var g = n[a],
                        l = n[c],
                        m = n[e];
                    if (!0 === h(g, l, m)) {
                        s = b();
                        s.id = d.id;
                        s.v1.copy(g);
                        s.v2.copy(l);
                        s.v3.copy(m);
                        s.z = (g.positionScreen.z + l.positionScreen.z + m.positionScreen.z) / 3;
                        for (g = 0; 3 > g; g++) l = 3 * arguments[g], m = s.vertexNormalsModel[g], m.set(f[l + 0], f[l + 1], f[l + 2]), m.applyMatrix3(k).normalize();
                        s.vertexNormalsLength = 3;
                        s.material = d.material;
                        C.elements.push(s)
                    }
                }
            }
        };
    this.projectScene = function (k, h, g, l) {
        var r, p, u, x, D, J, y, F, T;
        N = w = t = 0;
        C.elements.length = 0;
        !0 === k.autoUpdate && k.updateMatrixWorld();
        void 0 === h.parent && h.updateMatrixWorld();
        I.copy(h.matrixWorldInverse.getInverse(h.matrixWorld));
        U.multiplyMatrices(h.projectionMatrix, I);
        X.setFromMatrix(U);
        f = 0;
        C.objects.length = 0;
        C.lights.length = 0;
        ba(k);
        !0 === g && C.objects.sort(e);
        k = 0;
        for (g = C.objects.length; k < g; k++)
            if (r = C.objects[k].object, p = r.geometry, aa.setObject(r), M = r.matrixWorld, m = 0, r instanceof THREE.Mesh)
                if (p instanceof THREE.BufferGeometry) {
                    if (J = p.attributes, r = p.offsets, void 0 !== J.position) {
                        F = J.position.array;
                        p = 0;
                        for (x = F.length; p < x; p += 3) aa.pushVertex(F[p], F[p + 1], F[p + 2]);
                        T = J.normal.array;
                        p = 0;
                        for (x = T.length; p < x; p += 3) aa.pushNormal(T[p], T[p + 1], T[p + 2]);
                        if (void 0 !== J.index)
                            if (J = J.index.array, 0 < r.length)
                                for (k = 0; k < r.length; k++)
                                    for (x = r[k], F = x.index, p = x.start, x = x.start + x.count; p < x; p += 3) aa.pushTriangle(J[p] + F, J[p + 1] + F, J[p + 2] + F);
                            else
                                for (p = 0, x = J.length; p < x; p += 3) aa.pushTriangle(J[p], J[p + 1], J[p + 2]);
                        else
                            for (p = 0, x = F.length / 3; p <
                                x; p += 3) aa.pushTriangle(p, p + 1, p + 2)
                    }
                } else {
                    if (p instanceof THREE.Geometry) {
                        u = p.vertices;
                        x = p.faces;
                        J = p.faceVertexUvs;
                        S.getNormalMatrix(M);
                        F = r.material instanceof THREE.MeshFaceMaterial;
                        T = !0 === F ? r.material : null;
                        for (var na = 0, Fa = u.length; na < Fa; na++) {
                            var oa = u[na];
                            aa.pushVertex(oa.x, oa.y, oa.z)
                        }
                        na = 0;
                        for (Fa = x.length; na < Fa; na++) {
                            u = x[na];
                            var va = !0 === F ? T.materials[u.materialIndex] : r.material;
                            if (void 0 !== va) {
                                y = va.side;
                                var oa = n[u.a],
                                    wa = n[u.b],
                                    xa = n[u.c];
                                if (!0 === va.morphTargets) {
                                    D = p.morphTargets;
                                    var ya = r.morphTargetInfluences,
                                        sa = oa.position,
                                        Ba = wa.position,
                                        la = xa.position;
                                    P.set(0, 0, 0);
                                    z.set(0, 0, 0);
                                    Q.set(0, 0, 0);
                                    for (var za = 0, Wa = D.length; za < Wa; za++) {
                                        var ta = ya[za];
                                        if (0 !== ta) {
                                            var da = D[za].vertices;
                                            P.x += (da[u.a].x - sa.x) * ta;
                                            P.y += (da[u.a].y - sa.y) * ta;
                                            P.z += (da[u.a].z - sa.z) * ta;
                                            z.x += (da[u.b].x - Ba.x) * ta;
                                            z.y += (da[u.b].y - Ba.y) * ta;
                                            z.z += (da[u.b].z - Ba.z) * ta;
                                            Q.x += (da[u.c].x - la.x) * ta;
                                            Q.y += (da[u.c].y - la.y) * ta;
                                            Q.z += (da[u.c].z - la.z) * ta
                                        }
                                    }
                                    oa.position.add(P);
                                    wa.position.add(z);
                                    xa.position.add(Q);
                                    aa.projectVertex(oa);
                                    aa.projectVertex(wa);
                                    aa.projectVertex(xa)
                                }
                                ya =
                                    aa.checkTriangleVisibility(oa, wa, xa);
                                if (!(!1 === ya && y === THREE.FrontSide || !0 === ya && y === THREE.BackSide)) {
                                    s = b();
                                    s.id = r.id;
                                    s.v1.copy(oa);
                                    s.v2.copy(wa);
                                    s.v3.copy(xa);
                                    s.normalModel.copy(u.normal);
                                    !1 !== ya || y !== THREE.BackSide && y !== THREE.DoubleSide || s.normalModel.negate();
                                    s.normalModel.applyMatrix3(S).normalize();
                                    s.centroidModel.copy(u.centroid).applyMatrix4(M);
                                    D = u.vertexNormals;
                                    sa = 0;
                                    for (Ba = Math.min(D.length, 3); sa < Ba; sa++) la = s.vertexNormalsModel[sa], la.copy(D[sa]), !1 !== ya || y !== THREE.BackSide && y !== THREE.DoubleSide ||
                                        la.negate(), la.applyMatrix3(S).normalize();
                                    s.vertexNormalsLength = D.length;
                                    D = 0;
                                    for (ya = Math.min(J.length, 3); D < ya; D++)
                                        if (y = J[D][na], void 0 !== y)
                                            for (sa = 0, Ba = y.length; sa < Ba; sa++) s.uvs[D][sa] = y[sa];
                                    s.color = u.color;
                                    s.material = va;
                                    s.z = (oa.positionScreen.z + wa.positionScreen.z + xa.positionScreen.z) / 3;
                                    C.elements.push(s)
                                }
                            }
                        }
                    }
                } else if (r instanceof THREE.Line)
            if (p instanceof THREE.BufferGeometry) {
                if (J = p.attributes, void 0 !== J.position) {
                    F = J.position.array;
                    p = 0;
                    for (x = F.length; p < x; p += 3) aa.pushVertex(F[p], F[p + 1], F[p + 2]);
                    if (void 0 !== J.index)
                        for (J = J.index.array, p = 0, x = J.length; p < x; p += 2) aa.pushLine(J[p], J[p + 1]);
                    else
                        for (p = 0, x = F.length / 3 - 1; p < x; p++) aa.pushLine(p, p + 1)
                }
            } else {
                if (p instanceof THREE.Geometry && (Y.multiplyMatrices(U, M), u = r.geometry.vertices, 0 !== u.length))
                    for (oa = a(), oa.positionScreen.copy(u[0]).applyMatrix4(Y), p = r.type === THREE.LinePieces ? 2 : 1, na = 1, Fa = u.length; na < Fa; na++) oa = a(), oa.positionScreen.copy(u[na]).applyMatrix4(Y), 0 < (na + 1) % p || (wa = n[m - 2], K.copy(oa.positionScreen), ca.copy(wa.positionScreen), !0 === d(K, ca) &&
                        (K.multiplyScalar(1 / K.w), ca.multiplyScalar(1 / ca.w), v = c(), v.id = r.id, v.v1.positionScreen.copy(K), v.v2.positionScreen.copy(ca), v.z = Math.max(K.z, ca.z), v.material = r.material, r.material.vertexColors === THREE.VertexColors && (v.vertexColors[0].copy(r.geometry.colors[na]), v.vertexColors[1].copy(r.geometry.colors[na - 1])), C.elements.push(v)))
            } else r instanceof THREE.Sprite && (O.set(M.elements[12], M.elements[13], M.elements[14], 1), O.applyMatrix4(U), p = 1 / O.w, O.z *= p, -1 <= O.z && 1 >= O.z && (N === G ? (x = new THREE.RenderableSprite,
            B.push(x), G++, N++, A = x) : A = B[N++], A.id = r.id, A.x = O.x * p, A.y = O.y * p, A.z = O.z, A.object = r, A.rotation = r.rotation, A.scale.x = r.scale.x * Math.abs(A.x - (O.x + h.projectionMatrix.elements[0]) / (O.w + h.projectionMatrix.elements[12])), A.scale.y = r.scale.y * Math.abs(A.y - (O.y + h.projectionMatrix.elements[5]) / (O.w + h.projectionMatrix.elements[13])), A.material = r.material, C.elements.push(A)));
        !0 === l && C.elements.sort(e);
        return C
    }
};
THREE.Face3 = function (a, b, c, e, d, g) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.normal = e instanceof THREE.Vector3 ? e : new THREE.Vector3;
    this.vertexNormals = e instanceof Array ? e : [];
    this.color = d instanceof THREE.Color ? d : new THREE.Color;
    this.vertexColors = d instanceof Array ? d : [];
    this.vertexTangents = [];
    this.materialIndex = void 0 !== g ? g : 0;
    this.centroid = new THREE.Vector3
};
THREE.Face3.prototype = {
    constructor: THREE.Face3,
    clone: function () {
        var a = new THREE.Face3(this.a, this.b, this.c);
        a.normal.copy(this.normal);
        a.color.copy(this.color);
        a.centroid.copy(this.centroid);
        a.materialIndex = this.materialIndex;
        var b, c;
        b = 0;
        for (c = this.vertexNormals.length; b < c; b++) a.vertexNormals[b] = this.vertexNormals[b].clone();
        b = 0;
        for (c = this.vertexColors.length; b < c; b++) a.vertexColors[b] = this.vertexColors[b].clone();
        b = 0;
        for (c = this.vertexTangents.length; b < c; b++) a.vertexTangents[b] = this.vertexTangents[b].clone();
        return a
    }
};
THREE.Face4 = function (a, b, c, e, d, g, f) {
    console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
    return new THREE.Face3(a, b, c, d, g, f)
};
THREE.BufferGeometry = function () {
    this.id = THREE.GeometryIdCount++;
    this.attributes = {};
    this.offsets = [];
    this.boundingSphere = this.boundingBox = null
};
THREE.BufferGeometry.prototype = {
    constructor: THREE.BufferGeometry,
    addAttribute: function (a, b, c, e) {
        this.attributes[a] = {
            array: new b(c * e),
            itemSize: e
        };
        return this.attributes[a]
    },
    applyMatrix: function (a) {
        var b = this.attributes.position;
        void 0 !== b && (a.multiplyVector3Array(b.array), b.needsUpdate = !0);
        b = this.attributes.normal;
        void 0 !== b && ((new THREE.Matrix3).getNormalMatrix(a).multiplyVector3Array(b.array), b.needsUpdate = !0)
    },
    computeBoundingBox: function () {
        null === this.boundingBox && (this.boundingBox = new THREE.Box3);
        var a = this.attributes.position.array;
        if (a) {
            var b = this.boundingBox;
            3 <= a.length && (b.min.x = b.max.x = a[0], b.min.y = b.max.y = a[1], b.min.z = b.max.z = a[2]);
            for (var c = 3, e = a.length; c < e; c += 3) {
                var d = a[c],
                    g = a[c + 1],
                    f = a[c + 2];
                d < b.min.x ? b.min.x = d : d > b.max.x && (b.max.x = d);
                g < b.min.y ? b.min.y = g : g > b.max.y && (b.max.y = g);
                f < b.min.z ? b.min.z = f : f > b.max.z && (b.max.z = f)
            }
        }
        if (void 0 === a || 0 === a.length) this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0)
    },
    computeBoundingSphere: function () {
        var a = new THREE.Box3,
            b = new THREE.Vector3;
        return function () {
            null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
            var c = this.attributes.position.array;
            if (c) {
                a.makeEmpty();
                for (var e = this.boundingSphere.center, d = 0, g = c.length; d < g; d += 3) b.set(c[d], c[d + 1], c[d + 2]), a.addPoint(b);
                a.center(e);
                for (var f = 0, d = 0, g = c.length; d < g; d += 3) b.set(c[d], c[d + 1], c[d + 2]), f = Math.max(f, e.distanceToSquared(b));
                this.boundingSphere.radius = Math.sqrt(f)
            }
        }
    }(),
    computeVertexNormals: function () {
        if (this.attributes.position) {
            var a, b, c, e;
            a = this.attributes.position.array.length;
            if (void 0 === this.attributes.normal) this.attributes.normal = {
                itemSize: 3,
                array: new Float32Array(a)
            };
            else
                for (a = 0, b = this.attributes.normal.array.length; a < b; a++) this.attributes.normal.array[a] = 0;
            var d = this.attributes.position.array,
                g = this.attributes.normal.array,
                f, k, h, l, m, n, r = new THREE.Vector3,
                s = new THREE.Vector3,
                t = new THREE.Vector3,
                p = new THREE.Vector3,
                u = new THREE.Vector3;
            if (this.attributes.index) {
                var v = this.attributes.index.array,
                    w = this.offsets;
                c = 0;
                for (e = w.length; c < e; ++c) {
                    b = w[c].start;
                    f = w[c].count;
                    var y =
                        w[c].index;
                    a = b;
                    for (b += f; a < b; a += 3) f = y + v[a], k = y + v[a + 1], h = y + v[a + 2], l = d[3 * f], m = d[3 * f + 1], n = d[3 * f + 2], r.set(l, m, n), l = d[3 * k], m = d[3 * k + 1], n = d[3 * k + 2], s.set(l, m, n), l = d[3 * h], m = d[3 * h + 1], n = d[3 * h + 2], t.set(l, m, n), p.subVectors(t, s), u.subVectors(r, s), p.cross(u), g[3 * f] += p.x, g[3 * f + 1] += p.y, g[3 * f + 2] += p.z, g[3 * k] += p.x, g[3 * k + 1] += p.y, g[3 * k + 2] += p.z, g[3 * h] += p.x, g[3 * h + 1] += p.y, g[3 * h + 2] += p.z
                }
            } else
                for (a = 0, b = d.length; a < b; a += 9) l = d[a], m = d[a + 1], n = d[a + 2], r.set(l, m, n), l = d[a + 3], m = d[a + 4], n = d[a + 5], s.set(l, m, n), l = d[a + 6], m = d[a + 7], n = d[a + 8],
                    t.set(l, m, n), p.subVectors(t, s), u.subVectors(r, s), p.cross(u), g[a] = p.x, g[a + 1] = p.y, g[a + 2] = p.z, g[a + 3] = p.x, g[a + 4] = p.y, g[a + 5] = p.z, g[a + 6] = p.x, g[a + 7] = p.y, g[a + 8] = p.z;
            this.normalizeNormals();
            this.normalsNeedUpdate = !0
        }
    },
    normalizeNormals: function () {
        for (var a = this.attributes.normal.array, b, c, e, d = 0, g = a.length; d < g; d += 3) b = a[d], c = a[d + 1], e = a[d + 2], b = 1 / Math.sqrt(b * b + c * c + e * e), a[d] *= b, a[d + 1] *= b, a[d + 2] *= b
    },
    computeTangents: function () {
        function a(a, b, f) {
            n = e[3 * a];
            r = e[3 * a + 1];
            s = e[3 * a + 2];
            t = e[3 * b];
            p = e[3 * b + 1];
            u = e[3 * b + 2];
            v = e[3 * f];
            w = e[3 * f + 1];
            y = e[3 * f + 2];
            x = g[2 * a];
            A = g[2 * a + 1];
            N = g[2 * b];
            B = g[2 * b + 1];
            G = g[2 * f];
            C = g[2 * f + 1];
            P = t - n;
            z = v - n;
            Q = p - r;
            F = w - r;
            O = u - s;
            T = y - s;
            D = N - x;
            J = G - x;
            I = B - A;
            U = C - A;
            M = 1 / (D * U - J * I);
            Y.set((U * P - I * z) * M, (U * Q - I * F) * M, (U * O - I * T) * M);
            S.set((D * z - J * P) * M, (D * F - J * Q) * M, (D * T - J * O) * M);
            h[a].add(Y);
            h[b].add(Y);
            h[f].add(Y);
            l[a].add(S);
            l[b].add(S);
            l[f].add(S)
        }

        function b(a) {
            ma.x = d[3 * a];
            ma.y = d[3 * a + 1];
            ma.z = d[3 * a + 2];
            Ja.copy(ma);
            Ka = h[a];
            ea.copy(Ka);
            ea.sub(ma.multiplyScalar(ma.dot(Ka))).normalize();
            R.crossVectors(Ja, Ka);
            Ra = R.dot(l[a]);
            Aa = 0 > Ra ? -1 : 1;
            k[4 *
                a] = ea.x;
            k[4 * a + 1] = ea.y;
            k[4 * a + 2] = ea.z;
            k[4 * a + 3] = Aa
        }
        if (void 0 === this.attributes.index || void 0 === this.attributes.position || void 0 === this.attributes.normal || void 0 === this.attributes.uv) console.warn("Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");
        else {
            var c = this.attributes.index.array,
                e = this.attributes.position.array,
                d = this.attributes.normal.array,
                g = this.attributes.uv.array,
                f = e.length / 3;
            void 0 === this.attributes.tangent && (this.attributes.tangent = {
                itemSize: 4,
                array: new Float32Array(4 * f)
            });
            for (var k = this.attributes.tangent.array, h = [], l = [], m = 0; m < f; m++) h[m] = new THREE.Vector3, l[m] = new THREE.Vector3;
            var n, r, s, t, p, u, v, w, y, x, A, N, B, G, C, P, z, Q, F, O, T, D, J, I, U, M, Y = new THREE.Vector3,
                S = new THREE.Vector3,
                X, K, ca, ba, aa, ga = this.offsets,
                m = 0;
            for (K = ga.length; m < K; ++m) {
                X = ga[m].start;
                ca = ga[m].count;
                var pa = ga[m].index,
                    f = X;
                for (X += ca; f < X; f += 3) ca = pa + c[f], ba = pa + c[f + 1], aa = pa + c[f + 2], a(ca, ba, aa)
            }
            var ea = new THREE.Vector3,
                R = new THREE.Vector3,
                ma = new THREE.Vector3,
                Ja = new THREE.Vector3,
                Aa,
                Ka, Ra, m = 0;
            for (K = ga.length; m < K; ++m)
                for (X = ga[m].start, ca = ga[m].count, pa = ga[m].index, f = X, X += ca; f < X; f += 3) ca = pa + c[f], ba = pa + c[f + 1], aa = pa + c[f + 2], b(ca), b(ba), b(aa)
        }
    },
    computeOffsets: function (a) {
        var b = a;
        void 0 === a && (b = 65535);
        Date.now();
        a = this.attributes.index.array;
        for (var c = this.attributes.position.array, e = a.length / 3, d = new Uint16Array(a.length), g = 0, f = 0, k = [{
            start: 0,
            count: 0,
            index: 0
        }], h = k[0], l = 0, m = 0, n = new Int32Array(6), r = new Int32Array(c.length), s = new Int32Array(c.length), t = 0; t < c.length; t++) r[t] = -1, s[t] = -1;
        for (c =
            0; c < e; c++) {
            for (var p = m = 0; 3 > p; p++) t = a[3 * c + p], -1 == r[t] ? (n[2 * p] = t, n[2 * p + 1] = -1, m++) : r[t] < h.index ? (n[2 * p] = t, n[2 * p + 1] = -1, l++) : (n[2 * p] = t, n[2 * p + 1] = r[t]);
            if (f + m > h.index + b)
                for (h = {
                    start: g,
                    count: 0,
                    index: f
                }, k.push(h), m = 0; 6 > m; m += 2) p = n[m + 1], -1 < p && p < h.index && (n[m + 1] = -1);
            for (m = 0; 6 > m; m += 2) t = n[m], p = n[m + 1], -1 === p && (p = f++), r[t] = p, s[p] = t, d[g++] = p - h.index, h.count++
        }
        this.reorderBuffers(d, s, f);
        return this.offsets = k
    },
    reorderBuffers: function (a, b, c) {
        var e = {},
            d = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array,
                Uint32Array, Float32Array, Float64Array
            ],
            g;
        for (g in this.attributes)
            if ("index" != g)
                for (var f = this.attributes[g].array, k = 0, h = d.length; k < h; k++) {
                    var l = d[k];
                    if (f instanceof l) {
                        e[g] = new l(this.attributes[g].itemSize * c);
                        break
                    }
                }
            for (d = 0; d < c; d++)
                for (g in f = b[d], this.attributes)
                    if ("index" != g)
                        for (var k = this.attributes[g].array, h = this.attributes[g].itemSize, l = e[g], m = 0; m < h; m++) l[d * h + m] = k[f * h + m];
        this.attributes.index.array = a;
        for (g in this.attributes) "index" != g && (this.attributes[g].array = e[g], this.attributes[g].numItems =
            this.attributes[g].itemSize * c)
    },
    clone: function () {
        var a = new THREE.BufferGeometry,
            b = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array],
            c;
        for (c in this.attributes) {
            for (var e = this.attributes[c], d = e.array, g = {
                itemSize: e.itemSize,
                array: null
            }, e = 0, f = b.length; e < f; e++) {
                var k = b[e];
                if (d instanceof k) {
                    g.array = new k(d);
                    break
                }
            }
            a.attributes[c] = g
        }
        e = 0;
        for (f = this.offsets.length; e < f; e++) b = this.offsets[e], a.offsets.push({
            start: b.start,
            index: b.index,
            count: b.count
        });
        return a
    },
    dispose: function () {
        this.dispatchEvent({
            type: "dispose"
        })
    }
};
THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);
THREE.Geometry = function () {
    this.id = THREE.GeometryIdCount++;
    this.uuid = THREE.Math.generateUUID();
    this.name = "";
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [
        []
    ];
    this.morphTargets = [];
    this.morphColors = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingSphere = this.boundingBox = null;
    this.hasTangents = !1;
    this.dynamic = !0;
    this.buffersNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.tangentsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate =
        this.elementsNeedUpdate = this.verticesNeedUpdate = !1
};
THREE.Geometry.prototype = {
    constructor: THREE.Geometry,
    applyMatrix: function (a) {
        for (var b = (new THREE.Matrix3).getNormalMatrix(a), c = 0, e = this.vertices.length; c < e; c++) this.vertices[c].applyMatrix4(a);
        c = 0;
        for (e = this.faces.length; c < e; c++) {
            var d = this.faces[c];
            d.normal.applyMatrix3(b).normalize();
            for (var g = 0, f = d.vertexNormals.length; g < f; g++) d.vertexNormals[g].applyMatrix3(b).normalize();
            d.centroid.applyMatrix4(a)
        }
        this.boundingBox instanceof THREE.Box3 && this.computeBoundingBox();
        this.boundingSphere instanceof
        THREE.Sphere && this.computeBoundingSphere()
    },
    computeCentroids: function () {
        var a, b, c;
        a = 0;
        for (b = this.faces.length; a < b; a++) c = this.faces[a], c.centroid.set(0, 0, 0), c.centroid.add(this.vertices[c.a]), c.centroid.add(this.vertices[c.b]), c.centroid.add(this.vertices[c.c]), c.centroid.divideScalar(3)
    },
    computeFaceNormals: function () {
        for (var a = new THREE.Vector3, b = new THREE.Vector3, c = 0, e = this.faces.length; c < e; c++) {
            var d = this.faces[c],
                g = this.vertices[d.a],
                f = this.vertices[d.b];
            a.subVectors(this.vertices[d.c], f);
            b.subVectors(g,
                f);
            a.cross(b);
            a.normalize();
            d.normal.copy(a)
        }
    },
    computeVertexNormals: function (a) {
        var b, c, e;
        e = Array(this.vertices.length);
        b = 0;
        for (c = this.vertices.length; b < c; b++) e[b] = new THREE.Vector3;
        if (a) {
            var d, g, f, k = new THREE.Vector3,
                h = new THREE.Vector3;
            new THREE.Vector3;
            new THREE.Vector3;
            new THREE.Vector3;
            a = 0;
            for (b = this.faces.length; a < b; a++) c = this.faces[a], d = this.vertices[c.a], g = this.vertices[c.b], f = this.vertices[c.c], k.subVectors(f, g), h.subVectors(d, g), k.cross(h), e[c.a].add(k), e[c.b].add(k), e[c.c].add(k)
        } else
            for (a =
                0, b = this.faces.length; a < b; a++) c = this.faces[a], e[c.a].add(c.normal), e[c.b].add(c.normal), e[c.c].add(c.normal);
        b = 0;
        for (c = this.vertices.length; b < c; b++) e[b].normalize();
        a = 0;
        for (b = this.faces.length; a < b; a++) c = this.faces[a], c.vertexNormals[0] = e[c.a].clone(), c.vertexNormals[1] = e[c.b].clone(), c.vertexNormals[2] = e[c.c].clone()
    },
    computeMorphNormals: function () {
        var a, b, c, e, d;
        c = 0;
        for (e = this.faces.length; c < e; c++)
            for (d = this.faces[c], d.__originalFaceNormal ? d.__originalFaceNormal.copy(d.normal) : d.__originalFaceNormal =
                d.normal.clone(), d.__originalVertexNormals || (d.__originalVertexNormals = []), a = 0, b = d.vertexNormals.length; a < b; a++) d.__originalVertexNormals[a] ? d.__originalVertexNormals[a].copy(d.vertexNormals[a]) : d.__originalVertexNormals[a] = d.vertexNormals[a].clone();
        var g = new THREE.Geometry;
        g.faces = this.faces;
        a = 0;
        for (b = this.morphTargets.length; a < b; a++) {
            if (!this.morphNormals[a]) {
                this.morphNormals[a] = {};
                this.morphNormals[a].faceNormals = [];
                this.morphNormals[a].vertexNormals = [];
                d = this.morphNormals[a].faceNormals;
                var f =
                    this.morphNormals[a].vertexNormals,
                    k, h;
                c = 0;
                for (e = this.faces.length; c < e; c++) k = new THREE.Vector3, h = {
                    a: new THREE.Vector3,
                    b: new THREE.Vector3,
                    c: new THREE.Vector3
                }, d.push(k), f.push(h)
            }
            f = this.morphNormals[a];
            g.vertices = this.morphTargets[a].vertices;
            g.computeFaceNormals();
            g.computeVertexNormals();
            c = 0;
            for (e = this.faces.length; c < e; c++) d = this.faces[c], k = f.faceNormals[c], h = f.vertexNormals[c], k.copy(d.normal), h.a.copy(d.vertexNormals[0]), h.b.copy(d.vertexNormals[1]), h.c.copy(d.vertexNormals[2])
        }
        c = 0;
        for (e = this.faces.length; c <
            e; c++) d = this.faces[c], d.normal = d.__originalFaceNormal, d.vertexNormals = d.__originalVertexNormals
    },
    computeTangents: function () {
        var a, b, c, e, d, g, f, k, h, l, m, n, r, s, t, p, u, v = [],
            w = [];
        c = new THREE.Vector3;
        var y = new THREE.Vector3,
            x = new THREE.Vector3,
            A = new THREE.Vector3,
            N = new THREE.Vector3;
        a = 0;
        for (b = this.vertices.length; a < b; a++) v[a] = new THREE.Vector3, w[a] = new THREE.Vector3;
        a = 0;
        for (b = this.faces.length; a < b; a++) d = this.faces[a], g = this.faceVertexUvs[0][a], e = d.a, u = d.b, d = d.c, f = this.vertices[e], k = this.vertices[u], h = this.vertices[d],
            l = g[0], m = g[1], n = g[2], g = k.x - f.x, r = h.x - f.x, s = k.y - f.y, t = h.y - f.y, k = k.z - f.z, f = h.z - f.z, h = m.x - l.x, p = n.x - l.x, m = m.y - l.y, l = n.y - l.y, n = 1 / (h * l - p * m), c.set((l * g - m * r) * n, (l * s - m * t) * n, (l * k - m * f) * n), y.set((h * r - p * g) * n, (h * t - p * s) * n, (h * f - p * k) * n), v[e].add(c), v[u].add(c), v[d].add(c), w[e].add(y), w[u].add(y), w[d].add(y);
        y = ["a", "b", "c", "d"];
        a = 0;
        for (b = this.faces.length; a < b; a++)
            for (d = this.faces[a], c = 0; c < Math.min(d.vertexNormals.length, 3); c++) N.copy(d.vertexNormals[c]), e = d[y[c]], u = v[e], x.copy(u), x.sub(N.multiplyScalar(N.dot(u))).normalize(),
                A.crossVectors(d.vertexNormals[c], u), e = A.dot(w[e]), e = 0 > e ? -1 : 1, d.vertexTangents[c] = new THREE.Vector4(x.x, x.y, x.z, e);
        this.hasTangents = !0
    },
    computeLineDistances: function () {
        for (var a = 0, b = this.vertices, c = 0, e = b.length; c < e; c++) 0 < c && (a += b[c].distanceTo(b[c - 1])), this.lineDistances[c] = a
    },
    computeBoundingBox: function () {
        null === this.boundingBox && (this.boundingBox = new THREE.Box3);
        this.boundingBox.setFromPoints(this.vertices)
    },
    computeBoundingSphere: function () {
        null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
        this.boundingSphere.setFromPoints(this.vertices)
    },
    mergeVertices: function () {
        var a = {},
            b = [],
            c = [],
            e, d = Math.pow(10, 4),
            g, f;
        g = 0;
        for (f = this.vertices.length; g < f; g++) e = this.vertices[g], e = Math.round(e.x * d) + "_" + Math.round(e.y * d) + "_" + Math.round(e.z * d), void 0 === a[e] ? (a[e] = g, b.push(this.vertices[g]), c[g] = b.length - 1) : c[g] = c[a[e]];
        a = [];
        g = 0;
        for (f = this.faces.length; g < f; g++)
            for (d = this.faces[g], d.a = c[d.a], d.b = c[d.b], d.c = c[d.c], d = [d.a, d.b, d.c], e = 0; 3 > e; e++)
                if (d[e] == d[(e + 1) % 3]) {
                    a.push(g);
                    break
                }
        for (g = a.length - 1; 0 <= g; g--)
            for (d =
                a[g], this.faces.splice(d, 1), c = 0, f = this.faceVertexUvs.length; c < f; c++) this.faceVertexUvs[c].splice(d, 1);
        g = this.vertices.length - b.length;
        this.vertices = b;
        return g
    },
    makeGroups: function () {
        var a = 0;
        return function (b) {
            var c, e, d, g, f = {},
                k = this.morphTargets.length,
                h = this.morphNormals.length;
            this.geometryGroups = {};
            c = 0;
            for (e = this.faces.length; c < e; c++) d = this.faces[c], d = b ? d.materialIndex : 0, d in f || (f[d] = {
                hash: d,
                counter: 0
            }), g = f[d].hash + "_" + f[d].counter, g in this.geometryGroups || (this.geometryGroups[g] = {
                faces3: [],
                materialIndex: d,
                vertices: 0,
                numMorphTargets: k,
                numMorphNormals: h
            }), 65535 < this.geometryGroups[g].vertices + 3 && (f[d].counter += 1, g = f[d].hash + "_" + f[d].counter, g in this.geometryGroups || (this.geometryGroups[g] = {
                faces3: [],
                materialIndex: d,
                vertices: 0,
                numMorphTargets: k,
                numMorphNormals: h
            })), this.geometryGroups[g].faces3.push(c), this.geometryGroups[g].vertices += 3;
            this.geometryGroupsList = [];
            for (var l in this.geometryGroups) this.geometryGroups[l].id = a++, this.geometryGroupsList.push(this.geometryGroups[l])
        }
    }(),
    clone: function () {
        for (var a =
            new THREE.Geometry, b = this.vertices, c = 0, e = b.length; c < e; c++) a.vertices.push(b[c].clone());
        b = this.faces;
        c = 0;
        for (e = b.length; c < e; c++) a.faces.push(b[c].clone());
        b = this.faceVertexUvs[0];
        c = 0;
        for (e = b.length; c < e; c++) {
            for (var d = b[c], g = [], f = 0, k = d.length; f < k; f++) g.push(new THREE.Vector2(d[f].x, d[f].y));
            a.faceVertexUvs[0].push(g)
        }
        return a
    },
    dispose: function () {
        this.dispatchEvent({
            type: "dispose"
        })
    }
};
THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);
THREE.GeometryIdCount = 0;
THREE.Geometry2 = function (a) {
    THREE.BufferGeometry.call(this);
    this.vertices = this.addAttribute("position", Float32Array, a, 3).array;
    this.normals = this.addAttribute("normal", Float32Array, a, 3).array;
    this.uvs = this.addAttribute("uv", Float32Array, a, 2).array;
    this.boundingSphere = this.boundingBox = null
};
THREE.Geometry2.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.Camera = function () {
    THREE.Object3D.call(this);
    this.matrixWorldInverse = new THREE.Matrix4;
    this.projectionMatrix = new THREE.Matrix4
};
THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);
THREE.Camera.prototype.lookAt = function () {
    var a = new THREE.Matrix4;
    return function (b) {
        a.lookAt(this.position, b, this.up);
        this.quaternion.setFromRotationMatrix(a)
    }
}();
THREE.Camera.prototype.clone = function (a) {
    void 0 === a && (a = new THREE.Camera);
    THREE.Object3D.prototype.clone.call(this, a);
    a.matrixWorldInverse.copy(this.matrixWorldInverse);
    a.projectionMatrix.copy(this.projectionMatrix);
    return a
};
THREE.OrthographicCamera = function (a, b, c, e, d, g) {
    THREE.Camera.call(this);
    this.left = a;
    this.right = b;
    this.top = c;
    this.bottom = e;
    this.near = void 0 !== d ? d : 0.1;
    this.far = void 0 !== g ? g : 2E3;
    this.updateProjectionMatrix()
};
THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {
    this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far)
};
THREE.OrthographicCamera.prototype.clone = function () {
    var a = new THREE.OrthographicCamera;
    THREE.Camera.prototype.clone.call(this, a);
    a.left = this.left;
    a.right = this.right;
    a.top = this.top;
    a.bottom = this.bottom;
    a.near = this.near;
    a.far = this.far;
    return a
};
THREE.PerspectiveCamera = function (a, b, c, e) {
    THREE.Camera.call(this);
    this.fov = void 0 !== a ? a : 50;
    this.aspect = void 0 !== b ? b : 1;
    this.near = void 0 !== c ? c : 0.1;
    this.far = void 0 !== e ? e : 2E3;
    this.updateProjectionMatrix()
};
THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.PerspectiveCamera.prototype.setLens = function (a, b) {
    void 0 === b && (b = 24);
    this.fov = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a)));
    this.updateProjectionMatrix()
};
THREE.PerspectiveCamera.prototype.setViewOffset = function (a, b, c, e, d, g) {
    this.fullWidth = a;
    this.fullHeight = b;
    this.x = c;
    this.y = e;
    this.width = d;
    this.height = g;
    this.updateProjectionMatrix()
};
THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {
    if (this.fullWidth) {
        var a = this.fullWidth / this.fullHeight,
            b = Math.tan(THREE.Math.degToRad(0.5 * this.fov)) * this.near,
            c = -b,
            e = a * c,
            a = Math.abs(a * b - e),
            c = Math.abs(b - c);
        this.projectionMatrix.makeFrustum(e + this.x * a / this.fullWidth, e + (this.x + this.width) * a / this.fullWidth, b - (this.y + this.height) * c / this.fullHeight, b - this.y * c / this.fullHeight, this.near, this.far)
    } else this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far)
};
THREE.PerspectiveCamera.prototype.clone = function () {
    var a = new THREE.PerspectiveCamera;
    THREE.Camera.prototype.clone.call(this, a);
    a.fov = this.fov;
    a.aspect = this.aspect;
    a.near = this.near;
    a.far = this.far;
    return a
};
THREE.Light = function (a) {
    THREE.Object3D.call(this);
    this.color = new THREE.Color(a)
};
THREE.Light.prototype = Object.create(THREE.Object3D.prototype);
THREE.Light.prototype.clone = function (a) {
    void 0 === a && (a = new THREE.Light);
    THREE.Object3D.prototype.clone.call(this, a);
    a.color.copy(this.color);
    return a
};
THREE.AmbientLight = function (a) {
    THREE.Light.call(this, a)
};
THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
THREE.AmbientLight.prototype.clone = function () {
    var a = new THREE.AmbientLight;
    THREE.Light.prototype.clone.call(this, a);
    return a
};
THREE.AreaLight = function (a, b) {
    THREE.Light.call(this, a);
    this.normal = new THREE.Vector3(0, -1, 0);
    this.right = new THREE.Vector3(1, 0, 0);
    this.intensity = void 0 !== b ? b : 1;
    this.height = this.width = 1;
    this.constantAttenuation = 1.5;
    this.linearAttenuation = 0.5;
    this.quadraticAttenuation = 0.1
};
THREE.AreaLight.prototype = Object.create(THREE.Light.prototype);
THREE.DirectionalLight = function (a, b) {
    THREE.Light.call(this, a);
    this.position.set(0, 1, 0);
    this.target = new THREE.Object3D;
    this.intensity = void 0 !== b ? b : 1;
    this.onlyShadow = this.castShadow = !1;
    this.shadowCameraNear = 50;
    this.shadowCameraFar = 5E3;
    this.shadowCameraLeft = -500;
    this.shadowCameraTop = this.shadowCameraRight = 500;
    this.shadowCameraBottom = -500;
    this.shadowCameraVisible = !1;
    this.shadowBias = 0;
    this.shadowDarkness = 0.5;
    this.shadowMapHeight = this.shadowMapWidth = 512;
    this.shadowCascade = !1;
    this.shadowCascadeOffset = new THREE.Vector3(0,
        0, -1E3);
    this.shadowCascadeCount = 2;
    this.shadowCascadeBias = [0, 0, 0];
    this.shadowCascadeWidth = [512, 512, 512];
    this.shadowCascadeHeight = [512, 512, 512];
    this.shadowCascadeNearZ = [-1, 0.99, 0.998];
    this.shadowCascadeFarZ = [0.99, 0.998, 1];
    this.shadowCascadeArray = [];
    this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null
};
THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
THREE.DirectionalLight.prototype.clone = function () {
    var a = new THREE.DirectionalLight;
    THREE.Light.prototype.clone.call(this, a);
    a.target = this.target.clone();
    a.intensity = this.intensity;
    a.castShadow = this.castShadow;
    a.onlyShadow = this.onlyShadow;
    return a
};
THREE.HemisphereLight = function (a, b, c) {
    THREE.Light.call(this, a);
    this.position.set(0, 100, 0);
    this.groundColor = new THREE.Color(b);
    this.intensity = void 0 !== c ? c : 1
};
THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);
THREE.HemisphereLight.prototype.clone = function () {
    var a = new THREE.HemisphereLight;
    THREE.Light.prototype.clone.call(this, a);
    a.groundColor.copy(this.groundColor);
    a.intensity = this.intensity;
    return a
};
THREE.PointLight = function (a, b, c) {
    THREE.Light.call(this, a);
    this.intensity = void 0 !== b ? b : 1;
    this.distance = void 0 !== c ? c : 0
};
THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
THREE.PointLight.prototype.clone = function () {
    var a = new THREE.PointLight;
    THREE.Light.prototype.clone.call(this, a);
    a.intensity = this.intensity;
    a.distance = this.distance;
    return a
};
THREE.SpotLight = function (a, b, c, e, d) {
    THREE.Light.call(this, a);
    this.position.set(0, 1, 0);
    this.target = new THREE.Object3D;
    this.intensity = void 0 !== b ? b : 1;
    this.distance = void 0 !== c ? c : 0;
    this.angle = void 0 !== e ? e : Math.PI / 3;
    this.exponent = void 0 !== d ? d : 10;
    this.onlyShadow = this.castShadow = !1;
    this.shadowCameraNear = 50;
    this.shadowCameraFar = 5E3;
    this.shadowCameraFov = 50;
    this.shadowCameraVisible = !1;
    this.shadowBias = 0;
    this.shadowDarkness = 0.5;
    this.shadowMapHeight = this.shadowMapWidth = 512;
    this.shadowMatrix = this.shadowCamera = this.shadowMapSize =
        this.shadowMap = null
};
THREE.SpotLight.prototype = Object.create(THREE.Light.prototype);
THREE.SpotLight.prototype.clone = function () {
    var a = new THREE.SpotLight;
    THREE.Light.prototype.clone.call(this, a);
    a.target = this.target.clone();
    a.intensity = this.intensity;
    a.distance = this.distance;
    a.angle = this.angle;
    a.exponent = this.exponent;
    a.castShadow = this.castShadow;
    a.onlyShadow = this.onlyShadow;
    return a
};
THREE.Loader = function (a) {
    this.statusDomElement = (this.showStatus = a) ? THREE.Loader.prototype.addStatusElement() : null;
    this.onLoadStart = function () {};
    this.onLoadProgress = function () {};
    this.onLoadComplete = function () {}
};
THREE.Loader.prototype = {
    constructor: THREE.Loader,
    crossOrigin: void 0,
    addStatusElement: function () {
        var a = document.createElement("div");
        a.style.position = "absolute";
        a.style.right = "0px";
        a.style.top = "0px";
        a.style.fontSize = "0.8em";
        a.style.textAlign = "left";
        a.style.background = "rgba(0,0,0,0.25)";
        a.style.color = "#fff";
        a.style.width = "120px";
        a.style.padding = "0.5em 0.5em 0.5em 0.5em";
        a.style.zIndex = 1E3;
        a.innerHTML = "Loading ...";
        return a
    },
    updateProgress: function (a) {
        var b = "Loaded ",
            b = a.total ? b + ((100 * a.loaded / a.total).toFixed(0) +
                "%") : b + ((a.loaded / 1E3).toFixed(2) + " KB");
        this.statusDomElement.innerHTML = b
    },
    extractUrlBase: function (a) {
        a = a.split("/");
        if (1 === a.length) return "./";
        a.pop();
        return a.join("/") + "/"
    },
    initMaterials: function (a, b) {
        for (var c = [], e = 0; e < a.length; ++e) c[e] = THREE.Loader.prototype.createMaterial(a[e], b);
        return c
    },
    needsTangents: function (a) {
        for (var b = 0, c = a.length; b < c; b++)
            if (a[b] instanceof THREE.ShaderMaterial) return !0;
        return !1
    },
    createMaterial: function (a, b) {
        function c(a) {
            a = Math.log(a) / Math.LN2;
            return Math.floor(a) ==
                a
        }

        function e(a) {
            a = Math.log(a) / Math.LN2;
            return Math.pow(2, Math.round(a))
        }

        function d(a, b) {
            var f = new Image;
            f.onload = function () {
                if (c(this.width) && c(this.height)) a.image = this;
                else {
                    var b = e(this.width),
                        f = e(this.height);
                    a.image.width = b;
                    a.image.height = f;
                    a.image.getContext("2d").drawImage(this, 0, 0, b, f)
                }
                a.needsUpdate = !0
            };
            void 0 !== k.crossOrigin && (f.crossOrigin = k.crossOrigin);
            f.src = b
        }

        function g(a, f, c, k, e, h, g) {
            var l = /\.dds$/i.test(c),
                m = b + c;
            if (l) {
                var x = THREE.ImageUtils.loadCompressedTexture(m);
                a[f] = x
            } else x = document.createElement("canvas"),
                a[f] = new THREE.Texture(x);
            a[f].sourceFile = c;
            k && (a[f].repeat.set(k[0], k[1]), 1 !== k[0] && (a[f].wrapS = THREE.RepeatWrapping), 1 !== k[1] && (a[f].wrapT = THREE.RepeatWrapping));
            e && a[f].offset.set(e[0], e[1]);
            h && (c = {
                repeat: THREE.RepeatWrapping,
                mirror: THREE.MirroredRepeatWrapping
            }, void 0 !== c[h[0]] && (a[f].wrapS = c[h[0]]), void 0 !== c[h[1]] && (a[f].wrapT = c[h[1]]));
            g && (a[f].anisotropy = g);
            l || d(a[f], m)
        }

        function f(a) {
            return (255 * a[0] << 16) + (255 * a[1] << 8) + 255 * a[2]
        }
        var k = this,
            h = "MeshLambertMaterial",
            l = {
                color: 15658734,
                opacity: 1,
                map: null,
                lightMap: null,
                normalMap: null,
                bumpMap: null,
                wireframe: !1
            };
        if (a.shading) {
            var m = a.shading.toLowerCase();
            "phong" === m ? h = "MeshPhongMaterial" : "basic" === m && (h = "MeshBasicMaterial")
        }
        void 0 !== a.blending && void 0 !== THREE[a.blending] && (l.blending = THREE[a.blending]);
        if (void 0 !== a.transparent || 1 > a.opacity) l.transparent = a.transparent;
        void 0 !== a.depthTest && (l.depthTest = a.depthTest);
        void 0 !== a.depthWrite && (l.depthWrite = a.depthWrite);
        void 0 !== a.visible && (l.visible = a.visible);
        void 0 !== a.flipSided && (l.side = THREE.BackSide);
        void 0 !== a.doubleSided && (l.side = THREE.DoubleSide);
        void 0 !== a.wireframe && (l.wireframe = a.wireframe);
        void 0 !== a.vertexColors && ("face" === a.vertexColors ? l.vertexColors = THREE.FaceColors : a.vertexColors && (l.vertexColors = THREE.VertexColors));
        a.colorDiffuse ? l.color = f(a.colorDiffuse) : a.DbgColor && (l.color = a.DbgColor);
        a.colorSpecular && (l.specular = f(a.colorSpecular));
        a.colorAmbient && (l.ambient = f(a.colorAmbient));
        a.transparency && (l.opacity = a.transparency);
        a.specularCoef && (l.shininess = a.specularCoef);
        a.mapDiffuse &&
            b && g(l, "map", a.mapDiffuse, a.mapDiffuseRepeat, a.mapDiffuseOffset, a.mapDiffuseWrap, a.mapDiffuseAnisotropy);
        a.mapLight && b && g(l, "lightMap", a.mapLight, a.mapLightRepeat, a.mapLightOffset, a.mapLightWrap, a.mapLightAnisotropy);
        a.mapBump && b && g(l, "bumpMap", a.mapBump, a.mapBumpRepeat, a.mapBumpOffset, a.mapBumpWrap, a.mapBumpAnisotropy);
        a.mapNormal && b && g(l, "normalMap", a.mapNormal, a.mapNormalRepeat, a.mapNormalOffset, a.mapNormalWrap, a.mapNormalAnisotropy);
        a.mapSpecular && b && g(l, "specularMap", a.mapSpecular, a.mapSpecularRepeat,
            a.mapSpecularOffset, a.mapSpecularWrap, a.mapSpecularAnisotropy);
        a.mapBumpScale && (l.bumpScale = a.mapBumpScale);
        a.mapNormal ? (h = THREE.ShaderLib.normalmap, m = THREE.UniformsUtils.clone(h.uniforms), m.tNormal.value = l.normalMap, a.mapNormalFactor && m.uNormalScale.value.set(a.mapNormalFactor, a.mapNormalFactor), l.map && (m.tDiffuse.value = l.map, m.enableDiffuse.value = !0), l.specularMap && (m.tSpecular.value = l.specularMap, m.enableSpecular.value = !0), l.lightMap && (m.tAO.value = l.lightMap, m.enableAO.value = !0), m.diffuse.value.setHex(l.color),
            m.specular.value.setHex(l.specular), m.ambient.value.setHex(l.ambient), m.shininess.value = l.shininess, void 0 !== l.opacity && (m.opacity.value = l.opacity), h = new THREE.ShaderMaterial({
                fragmentShader: h.fragmentShader,
                vertexShader: h.vertexShader,
                uniforms: m,
                lights: !0,
                fog: !0
            }), l.transparent && (h.transparent = !0)) : h = new THREE[h](l);
        void 0 !== a.DbgName && (h.name = a.DbgName);
        return h
    }
};
THREE.XHRLoader = function (a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
};
THREE.XHRLoader.prototype = {
    constructor: THREE.XHRLoader,
    load: function (a, b, c, e) {
        var d = this,
            g = new XMLHttpRequest;
        void 0 !== b && g.addEventListener("load", function (f) {
            b(f.target.responseText);
            d.manager.itemEnd(a)
        }, !1);
        void 0 !== c && g.addEventListener("progress", function (a) {
            c(a)
        }, !1);
        void 0 !== e && g.addEventListener("error", function (a) {
            e(a)
        }, !1);
        void 0 !== this.crossOrigin && (g.crossOrigin = this.crossOrigin);
        g.open("GET", a, !0);
        g.send(null);
        d.manager.itemStart(a)
    },
    setCrossOrigin: function (a) {
        this.crossOrigin = a
    }
};
THREE.ImageLoader = function (a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
};
THREE.ImageLoader.prototype = {
    constructor: THREE.ImageLoader,
    load: function (a, b, c, e) {
        var d = this,
            g = document.createElement("img");
        void 0 !== b && g.addEventListener("load", function (f) {
            d.manager.itemEnd(a);
            b(this)
        }, !1);
        void 0 !== c && g.addEventListener("progress", function (a) {
            c(a)
        }, !1);
        void 0 !== e && g.addEventListener("error", function (a) {
            e(a)
        }, !1);
        void 0 !== this.crossOrigin && (g.crossOrigin = this.crossOrigin);
        g.src = a;
        d.manager.itemStart(a);
        return g
    },
    setCrossOrigin: function (a) {
        this.crossOrigin = a
    }
};
THREE.LoadingManager = function (a, b, c) {
    var e = this,
        d = 0,
        g = 0;
    this.onLoad = a;
    this.onProgress = b;
    this.onError = c;
    this.itemStart = function (a) {
        g++
    };
    this.itemEnd = function (a) {
        d++;
        if (void 0 !== e.onProgress) e.onProgress(a, d, g);
        if (d === g && void 0 !== e.onLoad) e.onLoad()
    }
};
THREE.DefaultLoadingManager = new THREE.LoadingManager;
THREE.TextureLoader = function (a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
};
THREE.TextureLoader.prototype = {
    constructor: THREE.TextureLoader,
    load: function (a, b, c, e) {
        c = new THREE.ImageLoader(this.manager);
        c.setCrossOrigin(this.crossOrigin);
        c.load(a, function (a) {
            a = new THREE.Texture(a);
            a.needsUpdate = !0;
            void 0 !== b && b(a)
        })
    },
    setCrossOrigin: function (a) {
        this.crossOrigin = a
    }
};
THREE.Material = function () {
    this.id = THREE.MaterialIdCount++;
    this.uuid = THREE.Math.generateUUID();
    this.name = "";
    this.side = THREE.FrontSide;
    this.opacity = 1;
    this.transparent = !1;
    this.blending = THREE.NormalBlending;
    this.blendSrc = THREE.SrcAlphaFactor;
    this.blendDst = THREE.OneMinusSrcAlphaFactor;
    this.blendEquation = THREE.AddEquation;
    this.depthWrite = this.depthTest = !0;
    this.polygonOffset = !1;
    this.overdraw = this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
    this.needsUpdate = this.visible = !0
};
THREE.Material.prototype = {
    constructor: THREE.Material,
    setValues: function (a) {
        if (void 0 !== a)
            for (var b in a) {
                var c = a[b];
                if (void 0 === c) console.warn("THREE.Material: '" + b + "' parameter is undefined.");
                else if (b in this) {
                    var e = this[b];
                    e instanceof THREE.Color ? e.set(c) : e instanceof THREE.Vector3 && c instanceof THREE.Vector3 ? e.copy(c) : this[b] = "overdraw" == b ? Number(c) : c
                }
            }
    },
    clone: function (a) {
        void 0 === a && (a = new THREE.Material);
        a.name = this.name;
        a.side = this.side;
        a.opacity = this.opacity;
        a.transparent = this.transparent;
        a.blending = this.blending;
        a.blendSrc = this.blendSrc;
        a.blendDst = this.blendDst;
        a.blendEquation = this.blendEquation;
        a.depthTest = this.depthTest;
        a.depthWrite = this.depthWrite;
        a.polygonOffset = this.polygonOffset;
        a.polygonOffsetFactor = this.polygonOffsetFactor;
        a.polygonOffsetUnits = this.polygonOffsetUnits;
        a.alphaTest = this.alphaTest;
        a.overdraw = this.overdraw;
        a.visible = this.visible;
        return a
    },
    dispose: function () {
        this.dispatchEvent({
            type: "dispose"
        })
    }
};
THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);
THREE.MaterialIdCount = 0;
THREE.LineBasicMaterial = function (a) {
    THREE.Material.call(this);
    this.color = new THREE.Color(16777215);
    this.linewidth = 1;
    this.linejoin = this.linecap = "round";
    this.vertexColors = !1;
    this.fog = !0;
    this.setValues(a)
};
THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineBasicMaterial.prototype.clone = function () {
    var a = new THREE.LineBasicMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.color.copy(this.color);
    a.linewidth = this.linewidth;
    a.linecap = this.linecap;
    a.linejoin = this.linejoin;
    a.vertexColors = this.vertexColors;
    a.fog = this.fog;
    return a
};
THREE.LineDashedMaterial = function (a) {
    THREE.Material.call(this);
    this.color = new THREE.Color(16777215);
    this.scale = this.linewidth = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.vertexColors = !1;
    this.fog = !0;
    this.setValues(a)
};
THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineDashedMaterial.prototype.clone = function () {
    var a = new THREE.LineDashedMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.color.copy(this.color);
    a.linewidth = this.linewidth;
    a.scale = this.scale;
    a.dashSize = this.dashSize;
    a.gapSize = this.gapSize;
    a.vertexColors = this.vertexColors;
    a.fog = this.fog;
    return a
};
THREE.MeshBasicMaterial = function (a) {
    THREE.Material.call(this);
    this.color = new THREE.Color(16777215);
    this.envMap = this.specularMap = this.lightMap = this.map = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.fog = !0;
    this.shading = THREE.SmoothShading;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.vertexColors = THREE.NoColors;
    this.morphTargets = this.skinning = !1;
    this.setValues(a)
};
THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshBasicMaterial.prototype.clone = function () {
    var a = new THREE.MeshBasicMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.color.copy(this.color);
    a.map = this.map;
    a.lightMap = this.lightMap;
    a.specularMap = this.specularMap;
    a.envMap = this.envMap;
    a.combine = this.combine;
    a.reflectivity = this.reflectivity;
    a.refractionRatio = this.refractionRatio;
    a.fog = this.fog;
    a.shading = this.shading;
    a.wireframe = this.wireframe;
    a.wireframeLinewidth = this.wireframeLinewidth;
    a.wireframeLinecap = this.wireframeLinecap;
    a.wireframeLinejoin =
        this.wireframeLinejoin;
    a.vertexColors = this.vertexColors;
    a.skinning = this.skinning;
    a.morphTargets = this.morphTargets;
    return a
};
THREE.MeshLambertMaterial = function (a) {
    THREE.Material.call(this);
    this.color = new THREE.Color(16777215);
    this.ambient = new THREE.Color(16777215);
    this.emissive = new THREE.Color(0);
    this.wrapAround = !1;
    this.wrapRGB = new THREE.Vector3(1, 1, 1);
    this.envMap = this.specularMap = this.lightMap = this.map = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.fog = !0;
    this.shading = THREE.SmoothShading;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap =
        "round";
    this.vertexColors = THREE.NoColors;
    this.morphNormals = this.morphTargets = this.skinning = !1;
    this.setValues(a)
};
THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshLambertMaterial.prototype.clone = function () {
    var a = new THREE.MeshLambertMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.color.copy(this.color);
    a.ambient.copy(this.ambient);
    a.emissive.copy(this.emissive);
    a.wrapAround = this.wrapAround;
    a.wrapRGB.copy(this.wrapRGB);
    a.map = this.map;
    a.lightMap = this.lightMap;
    a.specularMap = this.specularMap;
    a.envMap = this.envMap;
    a.combine = this.combine;
    a.reflectivity = this.reflectivity;
    a.refractionRatio = this.refractionRatio;
    a.fog = this.fog;
    a.shading = this.shading;
    a.wireframe = this.wireframe;
    a.wireframeLinewidth = this.wireframeLinewidth;
    a.wireframeLinecap = this.wireframeLinecap;
    a.wireframeLinejoin = this.wireframeLinejoin;
    a.vertexColors = this.vertexColors;
    a.skinning = this.skinning;
    a.morphTargets = this.morphTargets;
    a.morphNormals = this.morphNormals;
    return a
};
THREE.MeshPhongMaterial = function (a) {
    THREE.Material.call(this);
    this.color = new THREE.Color(16777215);
    this.ambient = new THREE.Color(16777215);
    this.emissive = new THREE.Color(0);
    this.specular = new THREE.Color(1118481);
    this.shininess = 30;
    this.wrapAround = this.metal = !1;
    this.wrapRGB = new THREE.Vector3(1, 1, 1);
    this.bumpMap = this.lightMap = this.map = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalScale = new THREE.Vector2(1, 1);
    this.envMap = this.specularMap = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity =
        1;
    this.refractionRatio = 0.98;
    this.fog = !0;
    this.shading = THREE.SmoothShading;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.vertexColors = THREE.NoColors;
    this.morphNormals = this.morphTargets = this.skinning = !1;
    this.setValues(a)
};
THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshPhongMaterial.prototype.clone = function () {
    var a = new THREE.MeshPhongMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.color.copy(this.color);
    a.ambient.copy(this.ambient);
    a.emissive.copy(this.emissive);
    a.specular.copy(this.specular);
    a.shininess = this.shininess;
    a.metal = this.metal;
    a.wrapAround = this.wrapAround;
    a.wrapRGB.copy(this.wrapRGB);
    a.map = this.map;
    a.lightMap = this.lightMap;
    a.bumpMap = this.bumpMap;
    a.bumpScale = this.bumpScale;
    a.normalMap = this.normalMap;
    a.normalScale.copy(this.normalScale);
    a.specularMap = this.specularMap;
    a.envMap = this.envMap;
    a.combine = this.combine;
    a.reflectivity = this.reflectivity;
    a.refractionRatio = this.refractionRatio;
    a.fog = this.fog;
    a.shading = this.shading;
    a.wireframe = this.wireframe;
    a.wireframeLinewidth = this.wireframeLinewidth;
    a.wireframeLinecap = this.wireframeLinecap;
    a.wireframeLinejoin = this.wireframeLinejoin;
    a.vertexColors = this.vertexColors;
    a.skinning = this.skinning;
    a.morphTargets = this.morphTargets;
    a.morphNormals = this.morphNormals;
    return a
};
THREE.MeshDepthMaterial = function (a) {
    THREE.Material.call(this);
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.setValues(a)
};
THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshDepthMaterial.prototype.clone = function () {
    var a = new THREE.MeshDepthMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.wireframe = this.wireframe;
    a.wireframeLinewidth = this.wireframeLinewidth;
    return a
};
THREE.MeshNormalMaterial = function (a) {
    THREE.Material.call(this, a);
    this.shading = THREE.FlatShading;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.morphTargets = !1;
    this.setValues(a)
};
THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshNormalMaterial.prototype.clone = function () {
    var a = new THREE.MeshNormalMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.shading = this.shading;
    a.wireframe = this.wireframe;
    a.wireframeLinewidth = this.wireframeLinewidth;
    return a
};
THREE.MeshFaceMaterial = function (a) {
    this.materials = a instanceof Array ? a : []
};
THREE.MeshFaceMaterial.prototype.clone = function () {
    for (var a = new THREE.MeshFaceMaterial, b = 0; b < this.materials.length; b++) a.materials.push(this.materials[b].clone());
    return a
};
THREE.ShaderMaterial = function (a) {
    THREE.Material.call(this);
    this.vertexShader = this.fragmentShader = "void main() {}";
    this.uniforms = {};
    this.defines = {};
    this.attributes = null;
    this.shading = THREE.SmoothShading;
    this.linewidth = 1;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.lights = this.fog = !1;
    this.vertexColors = THREE.NoColors;
    this.morphNormals = this.morphTargets = this.skinning = !1;
    this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv2: [0, 0]
    };
    this.index0AttributeName = "position";
    this.setValues(a)
};
THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.ShaderMaterial.prototype.clone = function () {
    var a = new THREE.ShaderMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.fragmentShader = this.fragmentShader;
    a.vertexShader = this.vertexShader;
    a.uniforms = THREE.UniformsUtils.clone(this.uniforms);
    a.attributes = this.attributes;
    a.defines = this.defines;
    a.shading = this.shading;
    a.wireframe = this.wireframe;
    a.wireframeLinewidth = this.wireframeLinewidth;
    a.fog = this.fog;
    a.lights = this.lights;
    a.vertexColors = this.vertexColors;
    a.skinning = this.skinning;
    a.morphTargets =
        this.morphTargets;
    a.morphNormals = this.morphNormals;
    return a
};
THREE.Texture = function (a, b, c, e, d, g, f, k, h) {
    this.id = THREE.TextureIdCount++;
    this.uuid = THREE.Math.generateUUID();
    this.name = "";
    this.image = a;
    this.mipmaps = [];
    this.mapping = void 0 !== b ? b : new THREE.UVMapping;
    this.wrapS = void 0 !== c ? c : THREE.ClampToEdgeWrapping;
    this.wrapT = void 0 !== e ? e : THREE.ClampToEdgeWrapping;
    this.magFilter = void 0 !== d ? d : THREE.LinearFilter;
    this.minFilter = void 0 !== g ? g : THREE.LinearMipMapLinearFilter;
    this.anisotropy = void 0 !== h ? h : 1;
    this.format = void 0 !== f ? f : THREE.RGBAFormat;
    this.type = void 0 !== k ? k : THREE.UnsignedByteType;
    this.offset = new THREE.Vector2(0, 0);
    this.repeat = new THREE.Vector2(1, 1);
    this.generateMipmaps = !0;
    this.premultiplyAlpha = !1;
    this.flipY = !0;
    this.unpackAlignment = 4;
    this._needsUpdate = !1;
    this.onUpdate = null
};
THREE.Texture.prototype = {
    constructor: THREE.Texture,
    get needsUpdate() {
        return this._needsUpdate
    },
    set needsUpdate(a) {
        !0 === a && this.update();
        this._needsUpdate = a
    },
    clone: function (a) {
        void 0 === a && (a = new THREE.Texture);
        a.image = this.image;
        a.mipmaps = this.mipmaps.slice(0);
        a.mapping = this.mapping;
        a.wrapS = this.wrapS;
        a.wrapT = this.wrapT;
        a.magFilter = this.magFilter;
        a.minFilter = this.minFilter;
        a.anisotropy = this.anisotropy;
        a.format = this.format;
        a.type = this.type;
        a.offset.copy(this.offset);
        a.repeat.copy(this.repeat);
        a.generateMipmaps =
            this.generateMipmaps;
        a.premultiplyAlpha = this.premultiplyAlpha;
        a.flipY = this.flipY;
        a.unpackAlignment = this.unpackAlignment;
        return a
    },
    update: function () {
        this.dispatchEvent({
            type: "update"
        })
    },
    dispose: function () {
        this.dispatchEvent({
            type: "dispose"
        })
    }
};
THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);
THREE.TextureIdCount = 0;
THREE.CompressedTexture = function (a, b, c, e, d, g, f, k, h, l, m) {
    THREE.Texture.call(this, null, g, f, k, h, l, e, d, m);
    this.image = {
        width: b,
        height: c
    };
    this.mipmaps = a;
    this.generateMipmaps = !1
};
THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.CompressedTexture.prototype.clone = function () {
    var a = new THREE.CompressedTexture;
    THREE.Texture.prototype.clone.call(this, a);
    return a
};
THREE.DataTexture = function (a, b, c, e, d, g, f, k, h, l, m) {
    THREE.Texture.call(this, null, g, f, k, h, l, e, d, m);
    this.image = {
        data: a,
        width: b,
        height: c
    }
};
THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.DataTexture.prototype.clone = function () {
    var a = new THREE.DataTexture;
    THREE.Texture.prototype.clone.call(this, a);
    return a
};
THREE.Line = function (a, b, c) {
    THREE.Object3D.call(this);
    this.geometry = void 0 !== a ? a : new THREE.Geometry;
    this.material = void 0 !== b ? b : new THREE.LineBasicMaterial({
        color: 16777215 * Math.random()
    });
    this.type = void 0 !== c ? c : THREE.LineStrip
};
THREE.LineStrip = 0;
THREE.LinePieces = 1;
THREE.Line.prototype = Object.create(THREE.Object3D.prototype);
THREE.Line.prototype.clone = function (a) {
    void 0 === a && (a = new THREE.Line(this.geometry, this.material, this.type));
    THREE.Object3D.prototype.clone.call(this, a);
    return a
};
THREE.Mesh = function (a, b, c) {
    THREE.Object3D.call(this, c);
    this.geometry = void 0 !== a ? a : new THREE.Geometry;
    this.material = void 0 !== b ? b : new THREE.MeshBasicMaterial({
        color: 16777215 * Math.random()
    });
    this.updateMorphTargets()
};
THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);
THREE.Mesh.prototype.updateMorphTargets = function () {
    if (void 0 !== this.geometry.morphTargets && 0 < this.geometry.morphTargets.length) {
        this.morphTargetBase = -1;
        this.morphTargetForcedOrder = [];
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (var a = 0, b = this.geometry.morphTargets.length; a < b; a++) this.morphTargetInfluences.push(0), this.morphTargetDictionary[this.geometry.morphTargets[a].name] = a
    }
};
THREE.Mesh.prototype.getMorphTargetIndexByName = function (a) {
    if (void 0 !== this.morphTargetDictionary[a]) return this.morphTargetDictionary[a];
    console.log("THREE.Mesh.getMorphTargetIndexByName: morph target " + a + " does not exist. Returning 0.");
    return 0
};
THREE.Mesh.prototype.clone = function (a) {
    void 0 === a && (a = new THREE.Mesh(this.geometry, this.material));
    THREE.Object3D.prototype.clone.call(this, a);
    return a
};
THREE.Bone = function (a) {
    THREE.Object3D.call(this);
    this.skin = a;
    this.skinMatrix = new THREE.Matrix4
};
THREE.Bone.prototype = Object.create(THREE.Object3D.prototype);
THREE.Bone.prototype.update = function (a, b) {
    this.matrixAutoUpdate && (b |= this.updateMatrix());
    if (b || this.matrixWorldNeedsUpdate) a ? this.skinMatrix.multiplyMatrices(a, this.matrix) : this.skinMatrix.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, b = !0;
    var c, e = this.children.length;
    for (c = 0; c < e; c++) this.children[c].update(this.skinMatrix, b)
};
THREE.LOD = function () {
    THREE.Object3D.call(this);
    this.objects = []
};
THREE.LOD.prototype = Object.create(THREE.Object3D.prototype);
THREE.LOD.prototype.addLevel = function (a, b) {
    void 0 === b && (b = 0);
    b = Math.abs(b);
    for (var c = 0; c < this.objects.length && !(b < this.objects[c].distance); c++);
    this.objects.splice(c, 0, {
        distance: b,
        object: a
    });
    this.add(a)
};
THREE.LOD.prototype.getObjectForDistance = function (a) {
    for (var b = 1, c = this.objects.length; b < c && !(a < this.objects[b].distance); b++);
    return this.objects[b - 1].object
};
THREE.LOD.prototype.update = function () {
    var a = new THREE.Vector3,
        b = new THREE.Vector3;
    return function (c) {
        if (1 < this.objects.length) {
            a.setFromMatrixPosition(c.matrixWorld);
            b.setFromMatrixPosition(this.matrixWorld);
            c = a.distanceTo(b);
            this.objects[0].object.visible = !0;
            for (var e = 1, d = this.objects.length; e < d; e++)
                if (c >= this.objects[e].distance) this.objects[e - 1].object.visible = !1, this.objects[e].object.visible = !0;
                else break;
            for (; e < d; e++) this.objects[e].object.visible = !1
        }
    }
}();
THREE.LOD.prototype.clone = function (a) {
    void 0 === a && (a = new THREE.LOD);
    THREE.Object3D.prototype.clone.call(this, a);
    for (var b = 0, c = this.objects.length; b < c; b++) {
        var e = this.objects[b].object.clone();
        e.visible = 0 === b;
        a.addLevel(e, this.objects[b].distance)
    }
    return a
};
THREE.Sprite = function () {
    var a = new THREE.Geometry2(3);
    a.vertices.set([-0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0]);
    return function (b) {
        THREE.Object3D.call(this);
        this.geometry = a;
        this.material = void 0 !== b ? b : new THREE.SpriteMaterial
    }
}();
THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);
THREE.Sprite.prototype.updateMatrix = function () {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = !0
};
THREE.Sprite.prototype.clone = function (a) {
    void 0 === a && (a = new THREE.Sprite(this.material));
    THREE.Object3D.prototype.clone.call(this, a);
    return a
};
THREE.Particle = THREE.Sprite;
THREE.Scene = function (a) {
    THREE.Object3D.call(this, a);
    this.children = [];
    this.overrideMaterial = this.fog = null;
    this.autoUpdate = !0;
    this.matrixAutoUpdate = !1;
    this.__lights = [];
    this.__objectsAdded = [];
    this.__objectsRemoved = []
};
THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);
THREE.Scene.prototype.__addObject = function (a) {
    if (a instanceof THREE.Light) - 1 === this.__lights.indexOf(a) && this.__lights.push(a), a.target && void 0 === a.target.parent && this.add(a.target);
    else if (!(a instanceof THREE.Camera || a instanceof THREE.Bone)) {
        this.__objectsAdded.push(a);
        var b = this.__objectsRemoved.indexOf(a); - 1 !== b && this.__objectsRemoved.splice(b, 1)
    }
    this.dispatchEvent({
        type: "objectAdded",
        object: a
    });
    a.dispatchEvent({
        type: "addedToScene",
        scene: this
    });
    if (a.children)
        for (b = 0; b < a.children.length; b++) this.__addObject(a.children[b])
};
THREE.Scene.prototype.__removeObject = function (a) {
    if (a instanceof THREE.Light) {
        var b = this.__lights.indexOf(a); - 1 !== b && this.__lights.splice(b, 1);
        if (a.shadowCascadeArray)
            for (b = 0; b < a.shadowCascadeArray.length; b++) this.__removeObject(a.shadowCascadeArray[b])
    } else a instanceof THREE.Camera || (this.__objectsRemoved.push(a), b = this.__objectsAdded.indexOf(a), -1 !== b && this.__objectsAdded.splice(b, 1));
    this.dispatchEvent({
        type: "objectRemoved",
        object: a
    });
    a.dispatchEvent({
        type: "removedFromScene",
        scene: this
    });
    if (a.children)
        for (b =
            0; b < a.children.length; b++) this.__removeObject(a.children[b])
};
THREE.Scene.prototype.clone = function (a) {
    void 0 === a && (a = new THREE.Scene);
    THREE.Object3D.prototype.clone.call(this, a);
    null !== this.fog && (a.fog = this.fog.clone());
    null !== this.overrideMaterial && (a.overrideMaterial = this.overrideMaterial.clone());
    a.autoUpdate = this.autoUpdate;
    a.matrixAutoUpdate = this.matrixAutoUpdate;
    return a
};
THREE.Fog = function (a, b, c) {
    this.name = "";
    this.color = new THREE.Color(a);
    this.near = void 0 !== b ? b : 1;
    this.far = void 0 !== c ? c : 1E3
};
THREE.Fog.prototype.clone = function () {
    return new THREE.Fog(this.color.getHex(), this.near, this.far)
};
THREE.FogExp2 = function (a, b) {
    this.name = "";
    this.color = new THREE.Color(a);
    this.density = void 0 !== b ? b : 2.5E-4
};
THREE.FogExp2.prototype.clone = function () {
    return new THREE.FogExp2(this.color.getHex(), this.density)
};
THREE.ShaderChunk = {
    fog_pars_fragment: "#ifdef USE_FOG\nuniform vec3 fogColor;\n#ifdef FOG_EXP2\nuniform float fogDensity;\n#else\nuniform float fogNear;\nuniform float fogFar;\n#endif\n#endif",
    fog_fragment: "#ifdef USE_FOG\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n#ifdef FOG_EXP2\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n#else\nfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n#endif\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n#endif",
    envmap_pars_fragment: "#ifdef USE_ENVMAP\nuniform float reflectivity;\n#ifdef SPHERICAL_ENV\nuniform sampler2D envMap;\n#else\nuniform samplerCube envMap;\n#endif\nuniform float flipEnvMap;\nuniform int combine;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nuniform bool useRefract;\nuniform float refractionRatio;\n#else\nvarying vec3 vReflect;\n#endif\n#endif",
    envmap_fragment: "#ifdef USE_ENVMAP\nvec3 reflectVec;\n#ifdef DOUBLE_SIDED\nfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n#else\nfloat flipNormal = 1.0;\n#endif\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\nif ( useRefract ) {\nreflectVec = refract( cameraToVertex, normal, refractionRatio );\n} else { \nreflectVec = reflect( cameraToVertex, normal );\n}\n#else\nreflectVec = normalize(vReflect);\n#endif\n#ifdef SPHERICAL_ENV\nfloat r = (1.0 / 3.14159265) * acos(reflectVec.z) / length(reflectVec.xy);\nvec2 uv = (reflectVec.xy * r + 1.0) * 0.5;\nvec4 cubeColor = texture2D(envMap, uv);\n#else\nvec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n#endif\n#ifdef GAMMA_INPUT\ncubeColor.xyz *= cubeColor.xyz;\n#endif\nfloat facing = max(0.0, dot( viewPosition, normal ));\nif ( combine == 1 ) {\nfloat schlickRefl = reflectivity + ( 1.0 - reflectivity ) * pow( max(1.0 - facing, 0.0), 5.0 );\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * schlickRefl );\n} else if ( combine == 2 ) {\nvec3 schlickRefl = specular + ( 1.0 - specular ) * pow( max(1.0 - facing, 0.0), 5.0 );\ngl_FragColor.xyz += cubeColor.xyz * specularStrength * schlickRefl;\n} else {\nfloat schlickRefl = reflectivity + ( 1.0 - reflectivity ) * pow( max(1.0 - facing, 0.0), 5.0 );\ngl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * schlickRefl );\n}\n#endif",
    envmap_pars_vertex: "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\nvarying vec3 vReflect;\nuniform float refractionRatio;\nuniform bool useRefract;\n#endif",
    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n#ifdef USE_SKINNING\nvec4 worldPosition = modelMatrix * skinned;\n#endif\n#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\nvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n#endif\n#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n#endif\n#endif",
    envmap_vertex: "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\nvec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\nworldNormal = normalize( worldNormal );\nvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\nif ( useRefract ) {\nvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n} else {\nvReflect = reflect( cameraToVertex, worldNormal );\n}\n#endif",
    map_particle_pars_fragment: "#ifdef USE_MAP\nuniform sampler2D map;\n#endif",
    map_particle_fragment: "#ifdef USE_MAP\ngl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n#endif",
    map_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\nuniform vec4 offsetRepeat;\n#endif",
    map_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\nuniform sampler2D map;\n#endif",
    map_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",
    map_fragment: "#ifdef USE_MAP\nvec4 texelColor = texture2D( map, vUv );\n#ifdef GAMMA_INPUT\ntexelColor.xyz *= texelColor.xyz;\n#endif\ngl_FragColor = gl_FragColor * texelColor;\n#endif",
    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\nuniform sampler2D lightMap;\n#endif",
    lightmap_pars_vertex: "#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\n#endif",
    lightmap_fragment: "#ifdef USE_LIGHTMAP\ngl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n#endif",
    lightmap_vertex: "#ifdef USE_LIGHTMAP\nvUv2 = uv2;\n#endif",
    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\nuniform sampler2D bumpMap;\nuniform float bumpScale;\nvec2 dHdxy_fwd() {\nvec2 dSTdx = dFdx( vUv );\nvec2 dSTdy = dFdy( vUv );\nfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\nfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\nfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\nreturn vec2( dBx, dBy );\n}\nvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\nvec3 vSigmaX = dFdx( surf_pos );\nvec3 vSigmaY = dFdy( surf_pos );\nvec3 vN = surf_norm;\nvec3 R1 = cross( vSigmaY, vN );\nvec3 R2 = cross( vN, vSigmaX );\nfloat fDet = dot( vSigmaX, R1 );\nvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\nreturn normalize( abs( fDet ) * surf_norm - vGrad );\n}\n#endif",
    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\nuniform sampler2D normalMap;\nuniform vec2 normalScale;\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\nvec3 q0 = dFdx( eye_pos.xyz );\nvec3 q1 = dFdy( eye_pos.xyz );\nvec2 st0 = dFdx( vUv.st );\nvec2 st1 = dFdy( vUv.st );\nvec3 S = normalize(  q0 * st1.t - q1 * st0.t );\nvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\nvec3 N = normalize( surf_norm );\nvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\nmapN.xy = normalScale * mapN.xy;\nmat3 tsn = mat3( S, T, N );\nreturn normalize( tsn * mapN );\n}\n#endif",
    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\nuniform sampler2D specularMap;\n#endif",
    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\nvec4 texelSpecular = texture2D( specularMap, vUv );\nspecularStrength = texelSpecular.r;\n#else\nspecularStrength = 1.0;\n#endif",
    lights_lambert_pars_vertex: "uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif",
    lights_lambert_vertex: "vLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\nvLightBack = vec3( 0.0 );\n#endif\ntransformedNormal = normalize( transformedNormal );\n#if MAX_DIR_LIGHTS > 0\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( transformedNormal, dirVector );\nvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\ndirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\ndirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n#ifdef DOUBLE_SIDED\nvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n#endif\n}\n#endif\n#if MAX_POINT_LIGHTS > 0\nfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( transformedNormal, lVector );\nvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\npointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\npointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n#ifdef DOUBLE_SIDED\nvLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n#endif\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( transformedNormal, lVector );\nvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\nspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\nspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n#ifdef DOUBLE_SIDED\nvLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n#endif\n}\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( transformedNormal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\nvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n#ifdef DOUBLE_SIDED\nvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n#endif\n}\n#endif\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n#ifdef DOUBLE_SIDED\nvLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n#endif",
    lights_phong_pars_vertex: "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvarying vec3 vWorldPosition;\n#endif",
    lights_phong_vertex: "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvWorldPosition = worldPosition.xyz;\n#endif",
    lights_phong_pars_fragment: "uniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvarying vec3 vWorldPosition;\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;",
    lights_phong_fragment: "vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n#ifdef DOUBLE_SIDED\nnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n#endif\n#ifdef USE_NORMALMAP\nnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\nnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n#if MAX_POINT_LIGHTS > 0\nvec3 pointDiffuse  = vec3( 0.0 );\nvec3 pointSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n#else\nfloat pointDiffuseWeight = max( dotProduct, 0.0 );\n#endif\npointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\nvec3 pointHalfVector = normalize( lVector + viewPosition );\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\nfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = shininess * 0.125 + 0.25;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max(1.0 - dot( lVector, pointHalfVector ), 0.0), 5.0 );\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization ;\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nvec3 spotDiffuse  = vec3( 0.0 );\nvec3 spotSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n#else\nfloat spotDiffuseWeight = max( dotProduct, 0.0 );\n#endif\nspotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\nvec3 spotHalfVector = normalize( lVector + viewPosition );\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\nfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = shininess * 0.125 + 0.25;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max(1.0 - dot( lVector, spotHalfVector ), 0.0), 5.0 );\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n}\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nvec3 dirDiffuse  = vec3( 0.0 );\nvec3 dirSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, dirVector );\n#ifdef WRAP_AROUND\nfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n#else\nfloat dirDiffuseWeight = max( dotProduct, 0.0 );\n#endif\ndirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\nfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = shininess * 0.125 + 0.25;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max(1.0 - dot( dirVector, dirHalfVector ), 0.0), 5.0 );\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nvec3 hemiDiffuse  = vec3( 0.0 );\nvec3 hemiSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\nhemiDiffuse += diffuse * hemiColor;\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\nfloat hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\nvec3 lVectorGround = -lVector;\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\nfloat hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\nfloat dotProductGround = dot( normal, lVectorGround );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\nvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n}\n#endif\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n#if MAX_DIR_LIGHTS > 0\ntotalDiffuse += dirDiffuse;\ntotalSpecular += dirSpecular;\n#endif\n#if MAX_HEMI_LIGHTS > 0\ntotalDiffuse += hemiDiffuse;\ntotalSpecular += hemiSpecular;\n#endif\n#if MAX_POINT_LIGHTS > 0\ntotalDiffuse += pointDiffuse;\ntotalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\ntotalDiffuse += spotDiffuse;\ntotalSpecular += spotSpecular;\n#endif\n#ifdef METAL\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n#endif",
    color_pars_fragment: "#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif",
    color_fragment: "#ifdef USE_COLOR\ngl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n#endif",
    color_pars_vertex: "#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif",
    color_vertex: "#ifdef USE_COLOR\n#ifdef GAMMA_INPUT\nvColor = color * color;\n#else\nvColor = color;\n#endif\n#endif",
    skinning_pars_vertex: "#ifdef USE_SKINNING\n#ifdef BONE_TEXTURE\nuniform sampler2D boneTexture;\nuniform int boneTextureWidth;\nuniform int boneTextureHeight;\nmat4 getBoneMatrix( const in float i ) {\nfloat j = i * 4.0;\nfloat x = mod( j, float( boneTextureWidth ) );\nfloat y = floor( j / float( boneTextureWidth ) );\nfloat dx = 1.0 / float( boneTextureWidth );\nfloat dy = 1.0 / float( boneTextureHeight );\ny = dy * ( y + 0.5 );\nvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\nvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\nvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\nvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\nmat4 bone = mat4( v1, v2, v3, v4 );\nreturn bone;\n}\n#else\nuniform mat4 boneGlobalMatrices[ MAX_BONES ];\nmat4 getBoneMatrix( const in float i ) {\nmat4 bone = boneGlobalMatrices[ int(i) ];\nreturn bone;\n}\n#endif\n#endif",
    skinbase_vertex: "#ifdef USE_SKINNING\nmat4 boneMatX = getBoneMatrix( skinIndex.x );\nmat4 boneMatY = getBoneMatrix( skinIndex.y );\nmat4 boneMatZ = getBoneMatrix( skinIndex.z );\nmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
    skinning_vertex: "#ifdef USE_SKINNING\n#ifdef USE_MORPHTARGETS\nvec4 skinVertex = vec4( morphed, 1.0 );\n#else\nvec4 skinVertex = vec4( position, 1.0 );\n#endif\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned      += boneMatY * skinVertex * skinWeight.y;\nskinned      += boneMatZ * skinVertex * skinWeight.z;\nskinned      += boneMatW * skinVertex * skinWeight.w;\n#endif",
    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n#ifndef USE_MORPHNORMALS\nuniform float morphTargetInfluences[ 8 ];\n#else\nuniform float morphTargetInfluences[ 4 ];\n#endif\n#endif",
    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\nvec3 morphed = vec3( 0.0 );\nmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\nmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\nmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\nmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n#ifndef USE_MORPHNORMALS\nmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\nmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\nmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\nmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n#endif\nmorphed += position;\n#endif",
    default_vertex: "vec4 mvPosition;\n#ifdef USE_SKINNING\nmvPosition = modelViewMatrix * skinned;\n#endif\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\nmvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n#endif\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\nmvPosition = modelViewMatrix * vec4( position, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;",
    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\nvec3 morphedNormal = vec3( 0.0 );\nmorphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\nmorphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\nmorphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\nmorphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\nmorphedNormal += normal;\n#endif",
    skinnormal_vertex: "#ifdef USE_SKINNING\nmat4 skinMatrix = skinWeight.x * boneMatX;\nskinMatrix \t+= skinWeight.y * boneMatY;\n#ifdef USE_MORPHNORMALS\nvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n#else\nvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n#endif\n#endif",
    defaultnormal_vertex: "vec3 objectNormal;\n#ifdef USE_SKINNING\nobjectNormal = skinnedNormal.xyz;\n#endif\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\nobjectNormal = morphedNormal;\n#endif\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\nobjectNormal = normal;\n#endif\n#ifdef FLIP_SIDED\nobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;",
    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\nuniform sampler2D shadowMap[ MAX_SHADOWS ];\nuniform vec2 shadowMapSize[ MAX_SHADOWS ];\nuniform float shadowDarkness[ MAX_SHADOWS ];\nuniform float shadowBias[ MAX_SHADOWS ];\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\nfloat unpackDepth( const in vec4 rgba_depth ) {\nconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\nfloat depth = dot( rgba_depth, bit_shift );\nreturn depth;\n}\n#endif",
    shadowmap_fragment: "#ifdef USE_SHADOWMAP\n#ifdef SHADOWMAP_DEBUG\nvec3 frustumColors[3];\nfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\nfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\nfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n#endif\n#ifdef SHADOWMAP_CASCADE\nint inFrustumCount = 0;\n#endif\nfloat fDepth;\nvec3 shadowColor = vec3( 1.0 );\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\nbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\nbool inFrustum = all( inFrustumVec );\n#ifdef SHADOWMAP_CASCADE\ninFrustumCount += int( inFrustum );\nbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n#else\nbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n#endif\nbool frustumTest = all( frustumTestVec );\nif ( frustumTest ) {\nshadowCoord.z += shadowBias[ i ];\n#if defined( SHADOWMAP_TYPE_PCF )\nfloat shadow = 0.0;\nconst float shadowDelta = 1.0 / 9.0;\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\nfloat dx0 = -1.25 * xPixelOffset;\nfloat dy0 = -1.25 * yPixelOffset;\nfloat dx1 = 1.25 * xPixelOffset;\nfloat dy1 = 1.25 * yPixelOffset;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\nfloat shadow = 0.0;\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\nfloat dx0 = -1.0 * xPixelOffset;\nfloat dy0 = -1.0 * yPixelOffset;\nfloat dx1 = 1.0 * xPixelOffset;\nfloat dy1 = 1.0 * yPixelOffset;\nmat3 shadowKernel;\nmat3 depthKernel;\ndepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\ndepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\ndepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\ndepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\ndepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\ndepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\ndepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\ndepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\ndepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\nvec3 shadowZ = vec3( shadowCoord.z );\nshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\nshadowKernel[0] *= vec3(0.25);\nshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\nshadowKernel[1] *= vec3(0.25);\nshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\nshadowKernel[2] *= vec3(0.25);\nvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\nshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\nshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\nvec4 shadowValues;\nshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\nshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\nshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\nshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\nshadow = dot( shadowValues, vec4( 1.0 ) );\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n#else\nvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\nfloat fDepth = unpackDepth( rgbaDepth );\nif ( fDepth < shadowCoord.z )\nshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n#endif\n}\n#ifdef SHADOWMAP_DEBUG\n#ifdef SHADOWMAP_CASCADE\nif ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n#else\nif ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n#endif\n#endif\n}\n#ifdef GAMMA_OUTPUT\nshadowColor *= shadowColor;\n#endif\ngl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n#endif",
    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\nuniform mat4 shadowMatrix[ MAX_SHADOWS ];\n#endif",
    shadowmap_vertex: "#ifdef USE_SHADOWMAP\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n}\n#endif",
    alphatest_fragment: "#ifdef ALPHATEST\nif ( gl_FragColor.a < ALPHATEST ) discard;\n#endif",
    linear_to_gamma_fragment: "#ifdef GAMMA_OUTPUT\ngl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n#endif",
    mrt_normals_pars_vertex: "#ifdef MRT_NORMALS\nvarying float depth;\n#endif",
    mrt_normals_vertex: "#ifdef MRT_NORMALS\ndepth = mvPosition.z;\n#endif",
    mrt_normals_pars_fragment: ["#ifdef MRT_NORMALS", "undefined" !== typeof _isIE11 && _isIE11 ? "" : "#extension GL_EXT_draw_buffers : require", "varying float depth;\n#define gl_FragColor gl_FragData[0]\n#endif"].join("\n"),
    mrt_normals_fragment: "#ifdef MRT_NORMALS\ngl_FragData[1] = vec4(normal.x, normal.y, depth, gl_FragColor.a < 1.0 ? 0.0 : 1.0);\n#endif"
};
THREE.UniformsUtils = {
    merge: function (a) {
        var b, c, e, d = {};
        for (b = 0; b < a.length; b++)
            for (c in e = this.clone(a[b]), e) d[c] = e[c];
        return d
    },
    clone: function (a) {
        var b, c, e, d = {};
        for (b in a)
            for (c in d[b] = {}, a[b]) e = a[b][c], d[b][c] = e instanceof THREE.Color || e instanceof THREE.Vector2 || e instanceof THREE.Vector3 || e instanceof THREE.Vector4 || e instanceof THREE.Matrix4 || e instanceof THREE.Texture ? e.clone() : e instanceof Array ? e.slice() : e;
        return d
    }
};
THREE.UniformsLib = {
    common: {
        diffuse: {
            type: "c",
            value: new THREE.Color(15658734)
        },
        opacity: {
            type: "f",
            value: 1
        },
        map: {
            type: "t",
            value: null
        },
        offsetRepeat: {
            type: "v4",
            value: new THREE.Vector4(0, 0, 1, 1)
        },
        lightMap: {
            type: "t",
            value: null
        },
        specularMap: {
            type: "t",
            value: null
        },
        envMap: {
            type: "t",
            value: null
        },
        flipEnvMap: {
            type: "f",
            value: -1
        },
        useRefract: {
            type: "i",
            value: 0
        },
        reflectivity: {
            type: "f",
            value: 1
        },
        refractionRatio: {
            type: "f",
            value: 0.98
        },
        combine: {
            type: "i",
            value: 0
        },
        morphTargetInfluences: {
            type: "f",
            value: 0
        }
    },
    bump: {
        bumpMap: {
            type: "t",
            value: null
        },
        bumpScale: {
            type: "f",
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            type: "t",
            value: null
        },
        normalScale: {
            type: "v2",
            value: new THREE.Vector2(1, 1)
        }
    },
    fog: {
        fogDensity: {
            type: "f",
            value: 2.5E-4
        },
        fogNear: {
            type: "f",
            value: 1
        },
        fogFar: {
            type: "f",
            value: 2E3
        },
        fogColor: {
            type: "c",
            value: new THREE.Color(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            type: "fv",
            value: []
        },
        directionalLightDirection: {
            type: "fv",
            value: []
        },
        directionalLightColor: {
            type: "fv",
            value: []
        },
        hemisphereLightDirection: {
            type: "fv",
            value: []
        },
        hemisphereLightSkyColor: {
            type: "fv",
            value: []
        },
        hemisphereLightGroundColor: {
            type: "fv",
            value: []
        },
        pointLightColor: {
            type: "fv",
            value: []
        },
        pointLightPosition: {
            type: "fv",
            value: []
        },
        pointLightDistance: {
            type: "fv1",
            value: []
        },
        spotLightColor: {
            type: "fv",
            value: []
        },
        spotLightPosition: {
            type: "fv",
            value: []
        },
        spotLightDirection: {
            type: "fv",
            value: []
        },
        spotLightDistance: {
            type: "fv1",
            value: []
        },
        spotLightAngleCos: {
            type: "fv1",
            value: []
        },
        spotLightExponent: {
            type: "fv1",
            value: []
        }
    },
    particle: {
        psColor: {
            type: "c",
            value: new THREE.Color(15658734)
        },
        opacity: {
            type: "f",
            value: 1
        },
        size: {
            type: "f",
            value: 1
        },
        scale: {
            type: "f",
            value: 1
        },
        map: {
            type: "t",
            value: null
        },
        fogDensity: {
            type: "f",
            value: 2.5E-4
        },
        fogNear: {
            type: "f",
            value: 1
        },
        fogFar: {
            type: "f",
            value: 2E3
        },
        fogColor: {
            type: "c",
            value: new THREE.Color(16777215)
        }
    },
    shadowmap: {
        shadowMap: {
            type: "tv",
            value: []
        },
        shadowMapSize: {
            type: "v2v",
            value: []
        },
        shadowBias: {
            type: "fv1",
            value: []
        },
        shadowDarkness: {
            type: "fv1",
            value: []
        },
        shadowMatrix: {
            type: "m4v",
            value: []
        }
    }
};
THREE.ShaderLib = {
    basic: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.shadowmap]),
        vertexShader: [THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex,
            THREE.ShaderChunk.skinbase_vertex, "#ifdef USE_ENVMAP", THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "#endif", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"
        ].join("\n"),
        fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment,
            THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, "void main() {\ngl_FragColor = vec4( diffuse, opacity );", THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment,
            THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"
        ].join("\n")
    },
    lambert: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
            ambient: {
                type: "c",
                value: new THREE.Color(16777215)
            },
            emissive: {
                type: "c",
                value: new THREE.Color(0)
            },
            wrapRGB: {
                type: "v3",
                value: new THREE.Vector3(1, 1, 1)
            }
        }]),
        vertexShader: ["#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\n#endif",
            THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_lambert_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex,
            THREE.ShaderChunk.defaultnormal_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_lambert_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"
        ].join("\n"),
        fragmentShader: ["uniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\n#endif", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment,
            THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, "void main() {\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );", THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, "#ifdef DOUBLE_SIDED\nif ( gl_FrontFacing )\ngl_FragColor.xyz *= vLightFront;\nelse\ngl_FragColor.xyz *= vLightBack;\n#else\ngl_FragColor.xyz *= vLightFront;\n#endif", THREE.ShaderChunk.lightmap_fragment,
            THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"
        ].join("\n")
    },
    phong: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.bump, THREE.UniformsLib.normalmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
            ambient: {
                type: "c",
                value: new THREE.Color(16777215)
            },
            emissive: {
                type: "c",
                value: new THREE.Color(0)
            },
            specular: {
                type: "c",
                value: new THREE.Color(1118481)
            },
            shininess: {
                type: "f",
                value: 30
            },
            wrapRGB: {
                type: "v3",
                value: new THREE.Vector3(1, 1, 1)
            }
        }]),
        vertexShader: ["#define PHONG\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_phong_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex,
            THREE.ShaderChunk.mrt_normals_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "vNormal = normalize( transformedNormal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, "vViewPosition = -mvPosition.xyz;", THREE.ShaderChunk.worldpos_vertex,
            THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_phong_vertex, THREE.ShaderChunk.shadowmap_vertex, THREE.ShaderChunk.mrt_normals_vertex, "}"
        ].join("\n"),
        fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;\nuniform vec3 ambient;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment,
            THREE.ShaderChunk.lights_phong_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.bumpmap_pars_fragment, THREE.ShaderChunk.normalmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.mrt_normals_pars_fragment, "void main() {\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );", THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lights_phong_fragment, THREE.ShaderChunk.lightmap_fragment,
            THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, THREE.ShaderChunk.mrt_normals_fragment, "}"
        ].join("\n")
    },
    particle_basic: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.particle, THREE.UniformsLib.shadowmap]),
        vertexShader: ["uniform float size;\nuniform float scale;", THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex,
            "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n#ifdef USE_SIZEATTENUATION\ngl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n#else\ngl_PointSize = size;\n#endif\ngl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"
        ].join("\n"),
        fragmentShader: ["uniform vec3 psColor;\nuniform float opacity;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_particle_pars_fragment, THREE.ShaderChunk.fog_pars_fragment,
            THREE.ShaderChunk.shadowmap_pars_fragment, "void main() {\ngl_FragColor = vec4( psColor, opacity );", THREE.ShaderChunk.map_particle_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.fog_fragment, "}"
        ].join("\n")
    },
    dashed: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, {
            scale: {
                type: "f",
                value: 1
            },
            dashSize: {
                type: "f",
                value: 1
            },
            totalSize: {
                type: "f",
                value: 2
            }
        }]),
        vertexShader: ["uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;",
            THREE.ShaderChunk.color_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "vLineDistance = scale * lineDistance;\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n}"
        ].join("\n"),
        fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, "void main() {\nif ( mod( vLineDistance, totalSize ) > dashSize ) {\ndiscard;\n}\ngl_FragColor = vec4( diffuse, opacity );",
            THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.fog_fragment, "}"
        ].join("\n")
    },
    depth: {
        uniforms: {
            mNear: {
                type: "f",
                value: 1
            },
            mFar: {
                type: "f",
                value: 2E3
            },
            opacity: {
                type: "f",
                value: 1
            }
        },
        vertexShader: "void main() {\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        fragmentShader: "uniform float mNear;\nuniform float mFar;\nuniform float opacity;\nvoid main() {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat color = 1.0 - smoothstep( mNear, mFar, depth );\ngl_FragColor = vec4( vec3( color ), opacity );\n}"
    },
    normal: {
        uniforms: {
            opacity: {
                type: "f",
                value: 1
            }
        },
        vertexShader: ["varying vec3 vNormal;", THREE.ShaderChunk.morphtarget_pars_vertex, "void main() {\nvNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, "}"].join("\n"),
        fragmentShader: "uniform float opacity;\nvarying vec3 vNormal;\nvoid main() {\ngl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\n}"
    },
    normalmap: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.fog, THREE.UniformsLib.lights,
            THREE.UniformsLib.shadowmap, {
                enableAO: {
                    type: "i",
                    value: 0
                },
                enableDiffuse: {
                    type: "i",
                    value: 0
                },
                enableSpecular: {
                    type: "i",
                    value: 0
                },
                enableReflection: {
                    type: "i",
                    value: 0
                },
                enableDisplacement: {
                    type: "i",
                    value: 0
                },
                tDisplacement: {
                    type: "t",
                    value: null
                },
                tDiffuse: {
                    type: "t",
                    value: null
                },
                tCube: {
                    type: "t",
                    value: null
                },
                tNormal: {
                    type: "t",
                    value: null
                },
                tSpecular: {
                    type: "t",
                    value: null
                },
                tAO: {
                    type: "t",
                    value: null
                },
                uNormalScale: {
                    type: "v2",
                    value: new THREE.Vector2(1, 1)
                },
                uDisplacementBias: {
                    type: "f",
                    value: 0
                },
                uDisplacementScale: {
                    type: "f",
                    value: 1
                },
                diffuse: {
                    type: "c",
                    value: new THREE.Color(16777215)
                },
                specular: {
                    type: "c",
                    value: new THREE.Color(1118481)
                },
                ambient: {
                    type: "c",
                    value: new THREE.Color(16777215)
                },
                shininess: {
                    type: "f",
                    value: 30
                },
                opacity: {
                    type: "f",
                    value: 1
                },
                useRefract: {
                    type: "i",
                    value: 0
                },
                refractionRatio: {
                    type: "f",
                    value: 0.98
                },
                reflectivity: {
                    type: "f",
                    value: 0.5
                },
                uOffset: {
                    type: "v2",
                    value: new THREE.Vector2(0, 0)
                },
                uRepeat: {
                    type: "v2",
                    value: new THREE.Vector2(1, 1)
                },
                wrapRGB: {
                    type: "v3",
                    value: new THREE.Vector3(1, 1, 1)
                }
            }
        ]),
        fragmentShader: ["uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\nuniform bool enableDiffuse;\nuniform bool enableSpecular;\nuniform bool enableAO;\nuniform bool enableReflection;\nuniform sampler2D tDiffuse;\nuniform sampler2D tNormal;\nuniform sampler2D tSpecular;\nuniform sampler2D tAO;\nuniform samplerCube tCube;\nuniform vec2 uNormalScale;\nuniform bool useRefract;\nuniform float refractionRatio;\nuniform float reflectivity;\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;",
            THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, "void main() {\ngl_FragColor = vec4( vec3( 1.0 ), opacity );\nvec3 specularTex = vec3( 1.0 );\nvec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\nnormalTex.xy *= uNormalScale;\nnormalTex = normalize( normalTex );\nif( enableDiffuse ) {\n#ifdef GAMMA_INPUT\nvec4 texelColor = texture2D( tDiffuse, vUv );\ntexelColor.xyz *= texelColor.xyz;\ngl_FragColor = gl_FragColor * texelColor;\n#else\ngl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\n#endif\n}\nif( enableAO ) {\n#ifdef GAMMA_INPUT\nvec4 aoColor = texture2D( tAO, vUv );\naoColor.xyz *= aoColor.xyz;\ngl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\n#endif\n}\nif( enableSpecular )\nspecularTex = texture2D( tSpecular, vUv ).xyz;\nmat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\nvec3 finalNormal = tsb * normalTex;\n#ifdef FLIP_SIDED\nfinalNormal = -finalNormal;\n#endif\nvec3 normal = normalize( finalNormal );\nvec3 viewPosition = normalize( vViewPosition );\n#if MAX_POINT_LIGHTS > 0\nvec3 pointDiffuse = vec3( 0.0 );\nvec3 pointSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 pointVector = lPosition.xyz + vViewPosition.xyz;\nfloat pointDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\npointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\npointVector = normalize( pointVector );\n#ifdef WRAP_AROUND\nfloat pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\nfloat pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n#else\nfloat pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\n#endif\npointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;\nvec3 pointHalfVector = normalize( pointVector + viewPosition );\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\nfloat pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nvec3 spotDiffuse = vec3( 0.0 );\nvec3 spotSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 spotVector = lPosition.xyz + vViewPosition.xyz;\nfloat spotDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nspotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\nspotVector = normalize( spotVector );\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\n#ifdef WRAP_AROUND\nfloat spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\nfloat spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n#else\nfloat spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\n#endif\nspotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;\nvec3 spotHalfVector = normalize( spotVector + viewPosition );\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\nfloat spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\n}\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nvec3 dirDiffuse = vec3( 0.0 );\nvec3 dirSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\n#ifdef WRAP_AROUND\nfloat directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\nfloat directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\nvec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\n#else\nfloat dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\n#endif\ndirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\nfloat dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nvec3 hemiDiffuse  = vec3( 0.0 );\nvec3 hemiSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\nhemiDiffuse += diffuse * hemiColor;\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\nfloat hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\nvec3 lVectorGround = -lVector;\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\nfloat hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\nfloat dotProductGround = dot( normal, lVectorGround );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\nvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n}\n#endif\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n#if MAX_DIR_LIGHTS > 0\ntotalDiffuse += dirDiffuse;\ntotalSpecular += dirSpecular;\n#endif\n#if MAX_HEMI_LIGHTS > 0\ntotalDiffuse += hemiDiffuse;\ntotalSpecular += hemiSpecular;\n#endif\n#if MAX_POINT_LIGHTS > 0\ntotalDiffuse += pointDiffuse;\ntotalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\ntotalDiffuse += spotDiffuse;\ntotalSpecular += spotSpecular;\n#endif\n#ifdef METAL\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n#endif\nif ( enableReflection ) {\nvec3 vReflect;\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\nif ( useRefract ) {\nvReflect = refract( cameraToVertex, normal, refractionRatio );\n} else {\nvReflect = reflect( cameraToVertex, normal );\n}\nvec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\n#ifdef GAMMA_INPUT\ncubeColor.xyz *= cubeColor.xyz;\n#endif\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );\n}",
            THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"
        ].join("\n"),
        vertexShader: ["attribute vec4 tangent;\nuniform vec2 uOffset;\nuniform vec2 uRepeat;\nuniform bool enableDisplacement;\n#ifdef VERTEX_TEXTURES\nuniform sampler2D tDisplacement;\nuniform float uDisplacementScale;\nuniform float uDisplacementBias;\n#endif\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;",
            THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, "#ifdef USE_SKINNING\nvNormal = normalize( normalMatrix * skinnedNormal.xyz );\nvec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\nvTangent = normalize( normalMatrix * skinnedTangent.xyz );\n#else\nvNormal = normalize( normalMatrix * normal );\nvTangent = normalize( normalMatrix * tangent.xyz );\n#endif\nvBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\nvUv = uv * uRepeat + uOffset;\nvec3 displacedPosition;\n#ifdef VERTEX_TEXTURES\nif ( enableDisplacement ) {\nvec3 dv = texture2D( tDisplacement, uv ).xyz;\nfloat df = uDisplacementScale * dv.x + uDisplacementBias;\ndisplacedPosition = position + normalize( normal ) * df;\n} else {\n#ifdef USE_SKINNING\nvec4 skinVertex = vec4( position, 1.0 );\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned \t  += boneMatY * skinVertex * skinWeight.y;\ndisplacedPosition  = skinned.xyz;\n#else\ndisplacedPosition = position;\n#endif\n}\n#else\n#ifdef USE_SKINNING\nvec4 skinVertex = vec4( position, 1.0 );\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned \t  += boneMatY * skinVertex * skinWeight.y;\ndisplacedPosition  = skinned.xyz;\n#else\ndisplacedPosition = position;\n#endif\n#endif\nvec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\nvec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\nvWorldPosition = worldPosition.xyz;\nvViewPosition = -mvPosition.xyz;\n#ifdef USE_SHADOWMAP\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n}\n#endif\n}"
        ].join("\n")
    },
    cube: {
        uniforms: {
            tCube: {
                type: "t",
                value: null
            },
            tFlip: {
                type: "f",
                value: -1
            }
        },
        vertexShader: "varying vec3 vWorldPosition;\nvoid main() {\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\nvWorldPosition = worldPosition.xyz;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        fragmentShader: "uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\nvoid main() {\ngl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n}"
    },
    depthRGBA: {
        uniforms: {},
        vertexShader: [THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, "}"].join("\n"),
        fragmentShader: "vec4 pack_depth( const in float depth ) {\nconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\nconst vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\nvec4 res = fract( depth * bit_shift );\nres -= res.xxyz * bit_mask;\nreturn res;\n}\nvoid main() {\ngl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n}"
    }
};
THREE.WebGLRenderTarget = function (a, b, c) {
    this.width = a;
    this.height = b;
    c = c || {};
    this.wrapS = void 0 !== c.wrapS ? c.wrapS : THREE.ClampToEdgeWrapping;
    this.wrapT = void 0 !== c.wrapT ? c.wrapT : THREE.ClampToEdgeWrapping;
    this.magFilter = void 0 !== c.magFilter ? c.magFilter : THREE.LinearFilter;
    this.minFilter = void 0 !== c.minFilter ? c.minFilter : THREE.LinearMipMapLinearFilter;
    this.anisotropy = void 0 !== c.anisotropy ? c.anisotropy : 1;
    this.offset = new THREE.Vector2(0, 0);
    this.repeat = new THREE.Vector2(1, 1);
    this.format = void 0 !== c.format ? c.format :
        THREE.RGBAFormat;
    this.type = void 0 !== c.type ? c.type : THREE.UnsignedByteType;
    this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0;
    this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0;
    this.generateMipmaps = !0;
    this.shareDepthFrom = null
};
THREE.WebGLRenderTarget.prototype = {
    constructor: THREE.WebGLRenderTarget,
    clone: function () {
        var a = new THREE.WebGLRenderTarget(this.width, this.height);
        a.wrapS = this.wrapS;
        a.wrapT = this.wrapT;
        a.magFilter = this.magFilter;
        a.minFilter = this.minFilter;
        a.anisotropy = this.anisotropy;
        a.offset.copy(this.offset);
        a.repeat.copy(this.repeat);
        a.format = this.format;
        a.type = this.type;
        a.depthBuffer = this.depthBuffer;
        a.stencilBuffer = this.stencilBuffer;
        a.generateMipmaps = this.generateMipmaps;
        a.shareDepthFrom = this.shareDepthFrom;
        return a
    },
    dispose: function () {
        this.dispatchEvent({
            type: "dispose"
        })
    }
};
THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);
THREE.GeometryUtils = {
    merge: function (a, b, c) {
        var e, d, g = a.vertices.length,
            f = b instanceof THREE.Mesh ? b.geometry : b,
            k = a.vertices,
            h = f.vertices,
            l = a.faces,
            m = f.faces;
        a = a.faceVertexUvs[0];
        f = f.faceVertexUvs[0];
        void 0 === c && (c = 0);
        b instanceof THREE.Mesh && (b.matrixAutoUpdate && b.updateMatrix(), e = b.matrix, d = (new THREE.Matrix3).getNormalMatrix(e));
        b = 0;
        for (var n = h.length; b < n; b++) {
            var r = h[b].clone();
            e && r.applyMatrix4(e);
            k.push(r)
        }
        b = 0;
        for (n = m.length; b < n; b++) {
            var r = m[b],
                s, t, p = r.vertexNormals,
                u = r.vertexColors;
            s = new THREE.Face3(r.a +
                g, r.b + g, r.c + g);
            s.normal.copy(r.normal);
            d && s.normal.applyMatrix3(d).normalize();
            k = 0;
            for (h = p.length; k < h; k++) t = p[k].clone(), d && t.applyMatrix3(d).normalize(), s.vertexNormals.push(t);
            s.color.copy(r.color);
            k = 0;
            for (h = u.length; k < h; k++) t = u[k], s.vertexColors.push(t.clone());
            s.materialIndex = r.materialIndex + c;
            s.centroid.copy(r.centroid);
            e && s.centroid.applyMatrix4(e);
            l.push(s)
        }
        b = 0;
        for (n = f.length; b < n; b++) {
            c = f[b];
            e = [];
            k = 0;
            for (h = c.length; k < h; k++) e.push(new THREE.Vector2(c[k].x, c[k].y));
            a.push(e)
        }
    },
    randomPointInTriangle: function () {
        var a =
            new THREE.Vector3;
        return function (b, c, e) {
            var d = new THREE.Vector3,
                g = THREE.Math.random16(),
                f = THREE.Math.random16();
            1 < g + f && (g = 1 - g, f = 1 - f);
            var k = 1 - g - f;
            d.copy(b);
            d.multiplyScalar(g);
            a.copy(c);
            a.multiplyScalar(f);
            d.add(a);
            a.copy(e);
            a.multiplyScalar(k);
            d.add(a);
            return d
        }
    }(),
    randomPointInFace: function (a, b, c) {
        return THREE.GeometryUtils.randomPointInTriangle(b.vertices[a.a], b.vertices[a.b], b.vertices[a.c])
    },
    randomPointsInGeometry: function (a, b) {
        function c(a) {
            function b(f, d) {
                if (d < f) return f;
                var c = f + Math.floor((d -
                    f) / 2);
                return l[c] > a ? b(f, c - 1) : l[c] < a ? b(c + 1, d) : c
            }
            return b(0, l.length - 1)
        }
        var e, d, g = a.faces,
            f = a.vertices,
            k = g.length,
            h = 0,
            l = [],
            m, n, r;
        for (d = 0; d < k; d++) e = g[d], m = f[e.a], n = f[e.b], r = f[e.c], e._area = THREE.GeometryUtils.triangleArea(m, n, r), h += e._area, l[d] = h;
        e = [];
        for (d = 0; d < b; d++) f = THREE.Math.random16() * h, f = c(f), e[d] = THREE.GeometryUtils.randomPointInFace(g[f], a, !0);
        return e
    },
    triangleArea: function () {
        var a = new THREE.Vector3,
            b = new THREE.Vector3;
        return function (c, e, d) {
            a.subVectors(e, c);
            b.subVectors(d, c);
            a.cross(b);
            return 0.5 *
                a.length()
        }
    }(),
    center: function (a) {
        a.computeBoundingBox();
        var b = a.boundingBox,
            c = new THREE.Vector3;
        c.addVectors(b.min, b.max);
        c.multiplyScalar(-0.5);
        a.applyMatrix((new THREE.Matrix4).makeTranslation(c.x, c.y, c.z));
        a.computeBoundingBox();
        return c
    },
    triangulateQuads: function (a) {
        var b, c, e, d, g = [],
            f = [];
        b = 0;
        for (c = a.faceVertexUvs.length; b < c; b++) f[b] = [];
        b = 0;
        for (c = a.faces.length; b < c; b++)
            for (g.push(a.faces[b]), e = 0, d = a.faceVertexUvs.length; e < d; e++) f[e].push(a.faceVertexUvs[e][b]);
        a.faces = g;
        a.faceVertexUvs = f;
        a.computeCentroids();
        a.computeFaceNormals();
        a.computeVertexNormals();
        a.hasTangents && a.computeTangents()
    }
};
THREE.ImageUtils = {
    crossOrigin: "",
    loadTexture: function (a, b, c, e) {
        e = new THREE.ImageLoader;
        e.crossOrigin = this.crossOrigin;
        var d = new THREE.Texture(void 0, b);
        b = e.load(a, function () {
            d.needsUpdate = !0;
            c && c(d)
        });
        d.image = b;
        d.sourceFile = a;
        return d
    },
    loadCompressedTexture: function (a, b, c, e) {
        var d = new THREE.CompressedTexture;
        d.mapping = b;
        var g = new XMLHttpRequest;
        g.onload = function () {
            var a = THREE.ImageUtils.parseDDS(g.response, !0);
            d.format = a.format;
            d.mipmaps = a.mipmaps;
            d.image.width = a.width;
            d.image.height = a.height;
            d.generateMipmaps = !1;
            d.needsUpdate = !0;
            c && c(d)
        };
        g.onerror = e;
        g.open("GET", a, !0);
        g.responseType = "arraybuffer";
        g.send(null);
        return d
    },
    loadTextureCube: function (a, b, c, e) {
        var d = [];
        d.loadCount = 0;
        var g = new THREE.Texture;
        g.image = d;
        void 0 !== b && (g.mapping = b);
        g.flipY = !1;
        b = 0;
        for (var f = a.length; b < f; ++b) {
            var k = new Image;
            d[b] = k;
            k.onload = function () {
                d.loadCount += 1;
                6 === d.loadCount && (g.needsUpdate = !0, c && c(g))
            };
            k.onerror = e;
            k.crossOrigin = this.crossOrigin;
            k.src = a[b]
        }
        return g
    },
    loadCompressedTextureCube: function (a, b, c, e) {
        var d = [];
        d.loadCount =
            0;
        var g = new THREE.CompressedTexture;
        g.image = d;
        void 0 !== b && (g.mapping = b);
        g.flipY = !1;
        g.generateMipmaps = !1;
        b = function (a, b) {
            return function () {
                var f = THREE.ImageUtils.parseDDS(a.response, !0);
                b.format = f.format;
                b.mipmaps = f.mipmaps;
                b.width = f.width;
                b.height = f.height;
                d.loadCount += 1;
                6 === d.loadCount && (g.format = f.format, g.needsUpdate = !0, c && c(g))
            }
        };
        if (a instanceof Array)
            for (var f = 0, k = a.length; f < k; ++f) {
                var h = {};
                d[f] = h;
                var l = new XMLHttpRequest;
                l.onload = b(l, h);
                l.onerror = e;
                h = a[f];
                l.open("GET", h, !0);
                l.responseType = "arraybuffer";
                l.send(null)
            } else l = new XMLHttpRequest, l.onload = function () {
                var a = THREE.ImageUtils.parseDDS(l.response, !0);
                if (a.isCubemap) {
                    for (var b = a.mipmaps.length / a.mipmapCount, f = 0; f < b; f++) {
                        d[f] = {
                            mipmaps: []
                        };
                        for (var k = 0; k < a.mipmapCount; k++) d[f].mipmaps.push(a.mipmaps[f * a.mipmapCount + k]), d[f].format = a.format, d[f].width = a.width, d[f].height = a.height
                    }
                    g.format = a.format;
                    g.needsUpdate = !0;
                    c && c(g)
                }
            }, l.onerror = e, l.open("GET", a, !0), l.responseType = "arraybuffer", l.send(null);
        return g
    },
    loadDDSTexture: function (a, b, c, e) {
        var d = [];
        d.loadCount = 0;
        var g = new THREE.CompressedTexture;
        g.image = d;
        void 0 !== b && (g.mapping = b);
        g.flipY = !1;
        g.generateMipmaps = !1;
        var f = new XMLHttpRequest;
        f.onload = function () {
            var a = THREE.ImageUtils.parseDDS(f.response, !0);
            if (a.isCubemap)
                for (var b = a.mipmaps.length / a.mipmapCount, e = 0; e < b; e++) {
                    d[e] = {
                        mipmaps: []
                    };
                    for (var m = 0; m < a.mipmapCount; m++) d[e].mipmaps.push(a.mipmaps[e * a.mipmapCount + m]), d[e].format = a.format, d[e].width = a.width, d[e].height = a.height
                } else g.image.width = a.width, g.image.height = a.height, g.mipmaps = a.mipmaps;
            g.format = a.format;
            g.needsUpdate = !0;
            c && c(g)
        };
        f.onerror = e;
        f.open("GET", a, !0);
        f.responseType = "arraybuffer";
        f.send(null);
        return g
    },
    parseDDS: function (a, b) {
        function c(a) {
            return a.charCodeAt(0) + (a.charCodeAt(1) << 8) + (a.charCodeAt(2) << 16) + (a.charCodeAt(3) << 24)
        }

        function e(a, b, f, d) {
            var c = f * d * 4;
            a = new Uint8Array(a, b, c);
            for (var c = new Uint8Array(c), k = b = 0, e = 0; e < d; e++)
                for (var h = 0; h < f; h++) {
                    var g = a[k];
                    k++;
                    var l = a[k];
                    k++;
                    var m = a[k];
                    k++;
                    var n = a[k];
                    k++;
                    c[b] = m;
                    b++;
                    c[b] = l;
                    b++;
                    c[b] = g;
                    b++;
                    c[b] = n;
                    b++
                }
            return c
        }
        var d = {
                mipmaps: [],
                width: 0,
                height: 0,
                format: null,
                mipmapCount: 1
            },
            g = c("DXT1"),
            f = c("DXT3"),
            k = c("DXT5"),
            h = new Int32Array(a, 0, 31);
        if (542327876 !== h[0]) return console.error("ImageUtils.parseDDS(): Invalid magic number in DDS header"), d;
        if (!h[20] & 4) return console.error("ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code"), d;
        var l = h[21],
            m = !1;
        switch (l) {
        case g:
            g = 8;
            d.format = THREE.RGB_S3TC_DXT1_Format;
            break;
        case f:
            g = 16;
            d.format = THREE.RGBA_S3TC_DXT3_Format;
            break;
        case k:
            g = 16;
            d.format = THREE.RGBA_S3TC_DXT5_Format;
            break;
        default:
            if (32 == h[22] && h[23] & 16711680 && h[24] & 65280 && h[25] & 255 && h[26] & 4278190080) m = !0, g = 64, d.format = THREE.RGBAFormat;
            else return console.error("ImageUtils.parseDDS(): Unsupported FourCC code: ", String.fromCharCode(l & 255, l >> 8 & 255, l >> 16 & 255, l >> 24 & 255)), d
        }
        d.mipmapCount = 1;
        h[2] & 131072 && !1 !== b && (d.mipmapCount = Math.max(1, h[7]));
        d.isCubemap = h[28] & 512 ? !0 : !1;
        d.width = h[4];
        d.height = h[3];
        for (var h = h[1] + 4, f = d.width, k = d.height, l = d.isCubemap ? 6 : 1, n = 0; n < l; n++) {
            for (var r = 0; r < d.mipmapCount; r++) {
                if (m) var s = e(a, h,
                        f, k),
                    t = s.length;
                else t = Math.max(4, f) / 4 * Math.max(4, k) / 4 * g, s = new Uint8Array(a, h, t);
                d.mipmaps.push({
                    data: s,
                    width: f,
                    height: k
                });
                h += t;
                f = Math.max(0.5 * f, 1);
                k = Math.max(0.5 * k, 1)
            }
            f = d.width;
            k = d.height
        }
        return d
    },
    getNormalMap: function (a, b) {
        var c = function (a) {
            var b = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
            return [a[0] / b, a[1] / b, a[2] / b]
        };
        b |= 1;
        var e = a.width,
            d = a.height,
            g = document.createElement("canvas");
        g.width = e;
        g.height = d;
        var f = g.getContext("2d");
        f.drawImage(a, 0, 0);
        for (var k = f.getImageData(0, 0, e, d).data, h = f.createImageData(e,
            d), l = h.data, m = 0; m < e; m++)
            for (var n = 0; n < d; n++) {
                var r = 0 > n - 1 ? 0 : n - 1,
                    s = n + 1 > d - 1 ? d - 1 : n + 1,
                    t = 0 > m - 1 ? 0 : m - 1,
                    p = m + 1 > e - 1 ? e - 1 : m + 1,
                    u = [],
                    v = [0, 0, k[4 * (n * e + m)] / 255 * b];
                u.push([-1, 0, k[4 * (n * e + t)] / 255 * b]);
                u.push([-1, -1, k[4 * (r * e + t)] / 255 * b]);
                u.push([0, -1, k[4 * (r * e + m)] / 255 * b]);
                u.push([1, -1, k[4 * (r * e + p)] / 255 * b]);
                u.push([1, 0, k[4 * (n * e + p)] / 255 * b]);
                u.push([1, 1, k[4 * (s * e + p)] / 255 * b]);
                u.push([0, 1, k[4 * (s * e + m)] / 255 * b]);
                u.push([-1, 1, k[4 * (s * e + t)] / 255 * b]);
                r = [];
                t = u.length;
                for (s = 0; s < t; s++) {
                    var p = u[s],
                        w = u[(s + 1) % t],
                        p = [p[0] - v[0], p[1] - v[1], p[2] - v[2]],
                        w = [w[0] - v[0], w[1] - v[1], w[2] - v[2]];
                    r.push(c([p[1] * w[2] - p[2] * w[1], p[2] * w[0] - p[0] * w[2], p[0] * w[1] - p[1] * w[0]]))
                }
                u = [0, 0, 0];
                for (s = 0; s < r.length; s++) u[0] += r[s][0], u[1] += r[s][1], u[2] += r[s][2];
                u[0] /= r.length;
                u[1] /= r.length;
                u[2] /= r.length;
                v = 4 * (n * e + m);
                l[v] = (u[0] + 1) / 2 * 255 | 0;
                l[v + 1] = (u[1] + 1) / 2 * 255 | 0;
                l[v + 2] = 255 * u[2] | 0;
                l[v + 3] = 255
            }
        f.putImageData(h, 0, 0);
        return g
    },
    generateDataTexture: function (a, b, c) {
        var e = a * b,
            d = new Uint8Array(3 * e),
            g = Math.floor(255 * c.r),
            f = Math.floor(255 * c.g);
        c = Math.floor(255 * c.b);
        for (var k = 0; k < e; k++) d[3 *
            k] = g, d[3 * k + 1] = f, d[3 * k + 2] = c;
        a = new THREE.DataTexture(d, a, b, THREE.RGBFormat);
        a.needsUpdate = !0;
        return a
    }
};
THREE.SceneUtils = {
    createMultiMaterialObject: function (a, b) {
        for (var c = new THREE.Object3D, e = 0, d = b.length; e < d; e++) c.add(new THREE.Mesh(a, b[e]));
        return c
    },
    detach: function (a, b, c) {
        a.applyMatrix(b.matrixWorld);
        b.remove(a);
        c.add(a)
    },
    attach: function (a, b, c) {
        var e = new THREE.Matrix4;
        e.getInverse(c.matrixWorld);
        a.applyMatrix(e);
        b.remove(a);
        c.add(a)
    }
};
THREE.FontUtils = {
    faces: {},
    face: "helvetiker",
    weight: "normal",
    style: "normal",
    size: 150,
    divisions: 10,
    getFace: function () {
        return this.faces[this.face][this.weight][this.style]
    },
    loadFace: function (a) {
        var b = a.familyName.toLowerCase();
        this.faces[b] = this.faces[b] || {};
        this.faces[b][a.cssFontWeight] = this.faces[b][a.cssFontWeight] || {};
        this.faces[b][a.cssFontWeight][a.cssFontStyle] = a;
        return this.faces[b][a.cssFontWeight][a.cssFontStyle] = a
    },
    drawText: function (a) {
        var b = this.getFace(),
            c = this.size / b.resolution,
            e = 0,
            d =
            String(a).split(""),
            g = d.length,
            f = [];
        for (a = 0; a < g; a++) {
            var k = new THREE.Path,
                k = this.extractGlyphPoints(d[a], b, c, e, k),
                e = e + k.offset;
            f.push(k.path)
        }
        return {
            paths: f,
            offset: e / 2
        }
    },
    extractGlyphPoints: function (a, b, c, e, d) {
        var g = [],
            f, k, h, l, m, n, r, s, t, p, u, v = b.glyphs[a] || b.glyphs["?"];
        if (v) {
            if (v.o)
                for (b = v._cachedOutline || (v._cachedOutline = v.o.split(" ")), l = b.length, a = 0; a < l;) switch (h = b[a++], h) {
                case "m":
                    h = b[a++] * c + e;
                    m = b[a++] * c;
                    d.moveTo(h, m);
                    break;
                case "l":
                    h = b[a++] * c + e;
                    m = b[a++] * c;
                    d.lineTo(h, m);
                    break;
                case "q":
                    h = b[a++] *
                        c + e;
                    m = b[a++] * c;
                    s = b[a++] * c + e;
                    t = b[a++] * c;
                    d.quadraticCurveTo(s, t, h, m);
                    if (f = g[g.length - 1])
                        for (n = f.x, r = f.y, f = 1, k = this.divisions; f <= k; f++) {
                            var w = f / k;
                            THREE.Shape.Utils.b2(w, n, s, h);
                            THREE.Shape.Utils.b2(w, r, t, m)
                        }
                    break;
                case "b":
                    if (h = b[a++] * c + e, m = b[a++] * c, s = b[a++] * c + e, t = b[a++] * -c, p = b[a++] * c + e, u = b[a++] * -c, d.bezierCurveTo(h, m, s, t, p, u), f = g[g.length - 1])
                        for (n = f.x, r = f.y, f = 1, k = this.divisions; f <= k; f++) w = f / k, THREE.Shape.Utils.b3(w, n, s, p, h), THREE.Shape.Utils.b3(w, r, t, u, m)
                }
            return {
                offset: v.ha * c,
                path: d
            }
        }
    }
};
THREE.FontUtils.generateShapes = function (a, b) {
    b = b || {};
    var c = void 0 !== b.curveSegments ? b.curveSegments : 4,
        e = void 0 !== b.font ? b.font : "helvetiker",
        d = void 0 !== b.weight ? b.weight : "normal",
        g = void 0 !== b.style ? b.style : "normal";
    THREE.FontUtils.size = void 0 !== b.size ? b.size : 100;
    THREE.FontUtils.divisions = c;
    THREE.FontUtils.face = e;
    THREE.FontUtils.weight = d;
    THREE.FontUtils.style = g;
    c = THREE.FontUtils.drawText(a).paths;
    e = [];
    d = 0;
    for (g = c.length; d < g; d++) Array.prototype.push.apply(e, c[d].toShapes());
    return e
};
(function (a) {
    var b = function (a) {
        for (var b = a.length, d = 0, g = b - 1, f = 0; f < b; g = f++) d += a[g].x * a[f].y - a[f].x * a[g].y;
        return 0.5 * d
    };
    a.Triangulate = function (a, e) {
        var d = a.length;
        if (3 > d) return null;
        var g = [],
            f = [],
            k = [],
            h, l, m;
        if (0 < b(a))
            for (l = 0; l < d; l++) f[l] = l;
        else
            for (l = 0; l < d; l++) f[l] = d - 1 - l;
        var n = 2 * d;
        for (l = d - 1; 2 < d;) {
            if (0 >= n--) {
                console.log("Warning, unable to triangulate polygon!");
                break
            }
            h = l;
            d <= h && (h = 0);
            l = h + 1;
            d <= l && (l = 0);
            m = l + 1;
            d <= m && (m = 0);
            var r;
            a: {
                var s = void 0,
                    t = void 0,
                    p = void 0,
                    u = void 0,
                    v = void 0,
                    w = void 0,
                    y = void 0,
                    x = void 0,
                    s = a[f[h]].x,
                    t = a[f[h]].y,
                    p = a[f[l]].x,
                    u = a[f[l]].y,
                    v = a[f[m]].x,
                    w = a[f[m]].y;
                if (1E-10 > (p - s) * (w - t) - (u - t) * (v - s)) r = !1;
                else {
                    var A = void 0,
                        N = void 0,
                        B = void 0,
                        G = void 0,
                        C = void 0,
                        P = void 0,
                        z = void 0,
                        Q = void 0,
                        F = void 0,
                        O = void 0,
                        F = Q = z = x = y = void 0,
                        A = v - p,
                        N = w - u,
                        B = s - v,
                        G = t - w,
                        C = p - s,
                        P = u - t;
                    for (r = 0; r < d; r++)
                        if (y = a[f[r]].x, x = a[f[r]].y, !(y === s && x === t || y === p && x === u || y === v && x === w) && (z = y - s, Q = x - t, F = y - p, O = x - u, y -= v, x -= w, F = A * O - N * F, z = C * Q - P * z, Q = B * x - G * y, -1E-10 <= F && -1E-10 <= Q && -1E-10 <= z)) {
                            r = !1;
                            break a
                        }
                    r = !0
                }
            }
            if (r) {
                g.push([a[f[h]], a[f[l]], a[f[m]]]);
                k.push([f[h], f[l], f[m]]);
                h = l;
                for (m = l + 1; m < d; h++, m++) f[h] = f[m];
                d--;
                n = 2 * d
            }
        }
        return e ? k : g
    };
    a.Triangulate.area = b;
    return a
})(THREE.FontUtils);
self._typeface_js = {
    faces: THREE.FontUtils.faces,
    loadFace: THREE.FontUtils.loadFace
};
THREE.typeface_js = self._typeface_js;
THREE.Gyroscope = function () {
    THREE.Object3D.call(this)
};
THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype);
THREE.Gyroscope.prototype.updateMatrixWorld = function (a) {
    this.matrixAutoUpdate && this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || a) this.parent ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorld.decompose(this.translationWorld, this.quaternionWorld, this.scaleWorld), this.matrix.decompose(this.translationObject, this.quaternionObject, this.scaleObject), this.matrixWorld.compose(this.translationWorld, this.quaternionObject, this.scaleWorld)) : this.matrixWorld.copy(this.matrix),
        this.matrixWorldNeedsUpdate = !1, a = !0;
    for (var b = 0, c = this.children.length; b < c; b++) this.children[b].updateMatrixWorld(a)
};
THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3;
THREE.Gyroscope.prototype.translationObject = new THREE.Vector3;
THREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion;
THREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion;
THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3;
THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3;
THREE.AnimationHandler = function () {
    var a = [],
        b = {},
        c = {
            update: function (b) {
                for (var c = 0; c < a.length; c++) a[c].update(b)
            },
            addToUpdate: function (b) {
                -1 === a.indexOf(b) && a.push(b)
            },
            removeFromUpdate: function (b) {
                b = a.indexOf(b); - 1 !== b && a.splice(b, 1)
            },
            add: function (a) {
                void 0 !== b[a.name] && console.log("THREE.AnimationHandler.add: Warning! " + a.name + " already exists in library. Overwriting.");
                b[a.name] = a;
                if (!0 !== a.initialized) {
                    for (var c = 0; c < a.hierarchy.length; c++) {
                        for (var f = 0; f < a.hierarchy[c].keys.length; f++)
                            if (0 > a.hierarchy[c].keys[f].time &&
                                (a.hierarchy[c].keys[f].time = 0), void 0 !== a.hierarchy[c].keys[f].rot && !(a.hierarchy[c].keys[f].rot instanceof THREE.Quaternion)) {
                                var k = a.hierarchy[c].keys[f].rot;
                                a.hierarchy[c].keys[f].rot = new THREE.Quaternion(k[0], k[1], k[2], k[3])
                            }
                        if (a.hierarchy[c].keys.length && void 0 !== a.hierarchy[c].keys[0].morphTargets) {
                            k = {};
                            for (f = 0; f < a.hierarchy[c].keys.length; f++)
                                for (var e = 0; e < a.hierarchy[c].keys[f].morphTargets.length; e++) {
                                    var l = a.hierarchy[c].keys[f].morphTargets[e];
                                    k[l] = -1
                                }
                            a.hierarchy[c].usedMorphTargets = k;
                            for (f = 0; f < a.hierarchy[c].keys.length; f++) {
                                var m = {};
                                for (l in k) {
                                    for (e = 0; e < a.hierarchy[c].keys[f].morphTargets.length; e++)
                                        if (a.hierarchy[c].keys[f].morphTargets[e] === l) {
                                            m[l] = a.hierarchy[c].keys[f].morphTargetsInfluences[e];
                                            break
                                        }
                                    e === a.hierarchy[c].keys[f].morphTargets.length && (m[l] = 0)
                                }
                                a.hierarchy[c].keys[f].morphTargetsInfluences = m
                            }
                        }
                        for (f = 1; f < a.hierarchy[c].keys.length; f++) a.hierarchy[c].keys[f].time === a.hierarchy[c].keys[f - 1].time && (a.hierarchy[c].keys.splice(f, 1), f--);
                        for (f = 0; f < a.hierarchy[c].keys.length; f++) a.hierarchy[c].keys[f].index =
                            f
                    }
                    a.initialized = !0
                }
            },
            get: function (a) {
                if ("string" === typeof a) {
                    if (b[a]) return b[a];
                    console.log("THREE.AnimationHandler.get: Couldn't find animation " + a);
                    return null
                }
            },
            parse: function (a) {
                var b = [];
                if (a instanceof THREE.SkinnedMesh)
                    for (var f = 0; f < a.bones.length; f++) b.push(a.bones[f]);
                else e(a, b);
                return b
            }
        },
        e = function (a, b) {
            b.push(a);
            for (var f = 0; f < a.children.length; f++) e(a.children[f], b)
        };
    c.LINEAR = 0;
    c.CATMULLROM = 1;
    c.CATMULLROM_FORWARD = 2;
    return c
}();
THREE.Animation = function (a, b) {
    this.root = a;
    this.data = THREE.AnimationHandler.get(b);
    this.hierarchy = THREE.AnimationHandler.parse(a);
    this.currentTime = 0;
    this.timeScale = 1;
    this.isPlaying = !1;
    this.loop = this.isPaused = !0;
    this.interpolationType = THREE.AnimationHandler.LINEAR
};
THREE.Animation.prototype.play = function (a) {
    this.currentTime = void 0 !== a ? a : 0;
    !1 === this.isPlaying && (this.isPlaying = !0, this.reset(), this.update(0));
    this.isPaused = !1;
    THREE.AnimationHandler.addToUpdate(this)
};
THREE.Animation.prototype.pause = function () {
    !0 === this.isPaused ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this);
    this.isPaused = !this.isPaused
};
THREE.Animation.prototype.stop = function () {
    this.isPaused = this.isPlaying = !1;
    THREE.AnimationHandler.removeFromUpdate(this)
};
THREE.Animation.prototype.reset = function () {
    for (var a = 0, b = this.hierarchy.length; a < b; a++) {
        var c = this.hierarchy[a];
        c.matrixAutoUpdate = !0;
        void 0 === c.animationCache && (c.animationCache = {}, c.animationCache.prevKey = {
            pos: 0,
            rot: 0,
            scl: 0
        }, c.animationCache.nextKey = {
            pos: 0,
            rot: 0,
            scl: 0
        }, c.animationCache.originalMatrix = c instanceof THREE.Bone ? c.skinMatrix : c.matrix);
        var e = c.animationCache.prevKey,
            c = c.animationCache.nextKey;
        e.pos = this.data.hierarchy[a].keys[0];
        e.rot = this.data.hierarchy[a].keys[0];
        e.scl = this.data.hierarchy[a].keys[0];
        c.pos = this.getNextKeyWith("pos", a, 1);
        c.rot = this.getNextKeyWith("rot", a, 1);
        c.scl = this.getNextKeyWith("scl", a, 1)
    }
};
THREE.Animation.prototype.update = function () {
    var a = [],
        b = new THREE.Vector3,
        c = function (a, b) {
            var f = [],
                c = [],
                h, l, m, n, r, s;
            h = (a.length - 1) * b;
            l = Math.floor(h);
            h -= l;
            f[0] = 0 === l ? l : l - 1;
            f[1] = l;
            f[2] = l > a.length - 2 ? l : l + 1;
            f[3] = l > a.length - 3 ? l : l + 2;
            l = a[f[0]];
            n = a[f[1]];
            r = a[f[2]];
            s = a[f[3]];
            f = h * h;
            m = h * f;
            c[0] = e(l[0], n[0], r[0], s[0], h, f, m);
            c[1] = e(l[1], n[1], r[1], s[1], h, f, m);
            c[2] = e(l[2], n[2], r[2], s[2], h, f, m);
            return c
        },
        e = function (a, b, f, c, e, l, m) {
            a = 0.5 * (f - a);
            c = 0.5 * (c - b);
            return (2 * (b - f) + a + c) * m + (-3 * (b - f) - 2 * a - c) * l + a * e + b
        };
    return function (d) {
        if (!1 !==
            this.isPlaying) {
            this.currentTime += d * this.timeScale;
            var e;
            d = ["pos", "rot", "scl"];
            var f = this.data.length;
            if (!0 === this.loop && this.currentTime > f) this.currentTime %= f, this.reset();
            else if (!1 === this.loop && this.currentTime > f) {
                this.stop();
                return
            }
            this.currentTime = Math.min(this.currentTime, f);
            for (var f = 0, k = this.hierarchy.length; f < k; f++)
                for (var h = this.hierarchy[f], l = h.animationCache, m = 0; 3 > m; m++) {
                    e = d[m];
                    var n = l.prevKey[e],
                        r = l.nextKey[e];
                    if (r.time <= this.currentTime) {
                        n = this.data.hierarchy[f].keys[0];
                        for (r = this.getNextKeyWith(e,
                            f, 1); r.time < this.currentTime && r.index > n.index;) n = r, r = this.getNextKeyWith(e, f, r.index + 1);
                        l.prevKey[e] = n;
                        l.nextKey[e] = r
                    }
                    h.matrixAutoUpdate = !0;
                    h.matrixWorldNeedsUpdate = !0;
                    var s = (this.currentTime - n.time) / (r.time - n.time),
                        t = n[e],
                        p = r[e];
                    0 > s && (s = 0);
                    1 < s && (s = 1);
                    if ("pos" === e)
                        if (e = h.position, this.interpolationType === THREE.AnimationHandler.LINEAR) e.x = t[0] + (p[0] - t[0]) * s, e.y = t[1] + (p[1] - t[1]) * s, e.z = t[2] + (p[2] - t[2]) * s;
                        else {
                            if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) a[0] =
                                this.getPrevKeyWith("pos", f, n.index - 1).pos, a[1] = t, a[2] = p, a[3] = this.getNextKeyWith("pos", f, r.index + 1).pos, s = 0.33 * s + 0.33, n = c(a, s), e.x = n[0], e.y = n[1], e.z = n[2], this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD && (s = c(a, 1.01 * s), b.set(s[0], s[1], s[2]), b.sub(e), b.y = 0, b.normalize(), e = Math.atan2(b.x, b.z), h.rotation.set(0, e, 0))
                        } else "rot" === e ? THREE.Quaternion.slerp(t, p, h.quaternion, s) : "scl" === e && (e = h.scale, e.x = t[0] + (p[0] - t[0]) * s, e.y = t[1] + (p[1] - t[1]) * s, e.z = t[2] + (p[2] - t[2]) * s)
                }
        }
    }
}();
THREE.Animation.prototype.getNextKeyWith = function (a, b, c) {
    var e = this.data.hierarchy[b].keys;
    for (c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? c < e.length - 1 ? c : e.length - 1 : c % e.length; c < e.length; c++)
        if (void 0 !== e[c][a]) return e[c];
    return this.data.hierarchy[b].keys[0]
};
THREE.Animation.prototype.getPrevKeyWith = function (a, b, c) {
    var e = this.data.hierarchy[b].keys;
    for (c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? 0 < c ? c : 0 : 0 <= c ? c : c + e.length; 0 <= c; c--)
        if (void 0 !== e[c][a]) return e[c];
    return this.data.hierarchy[b].keys[e.length - 1]
};
THREE.KeyFrameAnimation = function (a, b) {
    this.root = a;
    this.data = THREE.AnimationHandler.get(b);
    this.hierarchy = THREE.AnimationHandler.parse(a);
    this.currentTime = 0;
    this.timeScale = 0.001;
    this.isPlaying = !1;
    this.loop = this.isPaused = !0;
    for (var c = 0, e = this.hierarchy.length; c < e; c++) {
        var d = this.data.hierarchy[c].sids,
            g = this.hierarchy[c];
        if (this.data.hierarchy[c].keys.length && d) {
            for (var f = 0; f < d.length; f++) {
                var k = d[f],
                    h = this.getNextKeyWith(k, c, 0);
                h && h.apply(k)
            }
            g.matrixAutoUpdate = !1;
            this.data.hierarchy[c].node.updateMatrix();
            g.matrixWorldNeedsUpdate = !0
        }
    }
};
THREE.KeyFrameAnimation.prototype.play = function (a) {
    this.currentTime = void 0 !== a ? a : 0;
    if (!1 === this.isPlaying) {
        this.isPlaying = !0;
        var b = this.hierarchy.length,
            c, e;
        for (a = 0; a < b; a++) c = this.hierarchy[a], e = this.data.hierarchy[a], void 0 === e.animationCache && (e.animationCache = {}, e.animationCache.prevKey = null, e.animationCache.nextKey = null, e.animationCache.originalMatrix = c instanceof THREE.Bone ? c.skinMatrix : c.matrix), c = this.data.hierarchy[a].keys, c.length && (e.animationCache.prevKey = c[0], e.animationCache.nextKey =
            c[1], this.startTime = Math.min(c[0].time, this.startTime), this.endTime = Math.max(c[c.length - 1].time, this.endTime));
        this.update(0)
    }
    this.isPaused = !1;
    THREE.AnimationHandler.addToUpdate(this)
};
THREE.KeyFrameAnimation.prototype.pause = function () {
    this.isPaused ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this);
    this.isPaused = !this.isPaused
};
THREE.KeyFrameAnimation.prototype.stop = function () {
    this.isPaused = this.isPlaying = !1;
    THREE.AnimationHandler.removeFromUpdate(this);
    for (var a = 0; a < this.data.hierarchy.length; a++) {
        var b = this.hierarchy[a],
            c = this.data.hierarchy[a];
        if (void 0 !== c.animationCache) {
            var e = c.animationCache.originalMatrix;
            b instanceof THREE.Bone ? (e.copy(b.skinMatrix), b.skinMatrix = e) : (e.copy(b.matrix), b.matrix = e);
            delete c.animationCache
        }
    }
};
THREE.KeyFrameAnimation.prototype.update = function (a) {
    if (!1 !== this.isPlaying) {
        this.currentTime += a * this.timeScale;
        a = this.data.length;
        !0 === this.loop && this.currentTime > a && (this.currentTime %= a);
        this.currentTime = Math.min(this.currentTime, a);
        a = 0;
        for (var b = this.hierarchy.length; a < b; a++) {
            var c = this.hierarchy[a],
                e = this.data.hierarchy[a],
                d = e.keys,
                e = e.animationCache;
            if (d.length) {
                var g = e.prevKey,
                    f = e.nextKey;
                if (f.time <= this.currentTime) {
                    for (; f.time < this.currentTime && f.index > g.index;) g = f, f = d[g.index + 1];
                    e.prevKey =
                        g;
                    e.nextKey = f
                }
                f.time >= this.currentTime ? g.interpolate(f, this.currentTime) : g.interpolate(f, f.time);
                this.data.hierarchy[a].node.updateMatrix();
                c.matrixWorldNeedsUpdate = !0
            }
        }
    }
};
THREE.KeyFrameAnimation.prototype.getNextKeyWith = function (a, b, c) {
    b = this.data.hierarchy[b].keys;
    for (c %= b.length; c < b.length; c++)
        if (b[c].hasTarget(a)) return b[c];
    return b[0]
};
THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function (a, b, c) {
    b = this.data.hierarchy[b].keys;
    for (c = 0 <= c ? c : c + b.length; 0 <= c; c--)
        if (b[c].hasTarget(a)) return b[c];
    return b[b.length - 1]
};
THREE.CubeCamera = function (a, b, c) {
    THREE.Object3D.call(this);
    var e = new THREE.PerspectiveCamera(90, 1, a, b);
    e.up.set(0, -1, 0);
    e.lookAt(new THREE.Vector3(1, 0, 0));
    this.add(e);
    var d = new THREE.PerspectiveCamera(90, 1, a, b);
    d.up.set(0, -1, 0);
    d.lookAt(new THREE.Vector3(-1, 0, 0));
    this.add(d);
    var g = new THREE.PerspectiveCamera(90, 1, a, b);
    g.up.set(0, 0, 1);
    g.lookAt(new THREE.Vector3(0, 1, 0));
    this.add(g);
    var f = new THREE.PerspectiveCamera(90, 1, a, b);
    f.up.set(0, 0, -1);
    f.lookAt(new THREE.Vector3(0, -1, 0));
    this.add(f);
    var k = new THREE.PerspectiveCamera(90,
        1, a, b);
    k.up.set(0, -1, 0);
    k.lookAt(new THREE.Vector3(0, 0, 1));
    this.add(k);
    var h = new THREE.PerspectiveCamera(90, 1, a, b);
    h.up.set(0, -1, 0);
    h.lookAt(new THREE.Vector3(0, 0, -1));
    this.add(h);
    this.renderTarget = new THREE.WebGLRenderTargetCube(c, c, {
        format: THREE.RGBFormat,
        magFilter: THREE.LinearFilter,
        minFilter: THREE.LinearFilter
    });
    this.updateCubeMap = function (a, b) {
        var c = this.renderTarget,
            r = c.generateMipmaps;
        c.generateMipmaps = !1;
        c.activeCubeFace = 0;
        a.render(b, e, c);
        c.activeCubeFace = 1;
        a.render(b, d, c);
        c.activeCubeFace =
            2;
        a.render(b, g, c);
        c.activeCubeFace = 3;
        a.render(b, f, c);
        c.activeCubeFace = 4;
        a.render(b, k, c);
        c.generateMipmaps = r;
        c.activeCubeFace = 5;
        a.render(b, h, c)
    }
};
THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);
THREE.CombinedCamera = function (a, b, c, e, d, g, f) {
    THREE.Camera.call(this);
    this.fov = c;
    this.left = -a / 2;
    this.right = a / 2;
    this.top = b / 2;
    this.bottom = -b / 2;
    this.cameraO = new THREE.OrthographicCamera(a / -2, a / 2, b / 2, b / -2, g, f);
    this.cameraP = new THREE.PerspectiveCamera(c, a / b, e, d);
    this.zoom = 1;
    this.toPerspective()
};
THREE.CombinedCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.CombinedCamera.prototype.toPerspective = function () {
    this.near = this.cameraP.near;
    this.far = this.cameraP.far;
    this.cameraP.fov = this.fov / this.zoom;
    this.cameraP.updateProjectionMatrix();
    this.projectionMatrix = this.cameraP.projectionMatrix;
    this.inPerspectiveMode = !0;
    this.inOrthographicMode = !1
};
THREE.CombinedCamera.prototype.toOrthographic = function () {
    var a = this.cameraP.aspect,
        b = (this.cameraP.near + this.cameraP.far) / 2,
        b = Math.tan(this.fov / 2) * b,
        a = 2 * b * a / 2,
        b = b / this.zoom,
        a = a / this.zoom;
    this.cameraO.left = -a;
    this.cameraO.right = a;
    this.cameraO.top = b;
    this.cameraO.bottom = -b;
    this.cameraO.updateProjectionMatrix();
    this.near = this.cameraO.near;
    this.far = this.cameraO.far;
    this.projectionMatrix = this.cameraO.projectionMatrix;
    this.inPerspectiveMode = !1;
    this.inOrthographicMode = !0
};
THREE.CombinedCamera.prototype.setSize = function (a, b) {
    this.cameraP.aspect = a / b;
    this.left = -a / 2;
    this.right = a / 2;
    this.top = b / 2;
    this.bottom = -b / 2
};
THREE.CombinedCamera.prototype.setFov = function (a) {
    this.fov = a;
    this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic()
};
THREE.CombinedCamera.prototype.updateProjectionMatrix = function () {
    this.inPerspectiveMode ? this.toPerspective() : (this.toPerspective(), this.toOrthographic())
};
THREE.CombinedCamera.prototype.setLens = function (a, b) {
    void 0 === b && (b = 24);
    var c = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a)));
    this.setFov(c);
    return c
};
THREE.CombinedCamera.prototype.setZoom = function (a) {
    this.zoom = a;
    this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic()
};
THREE.CombinedCamera.prototype.toFrontView = function () {
    this.rotation.x = 0;
    this.rotation.y = 0;
    this.rotation.z = 0;
    this.rotationAutoUpdate = !1
};
THREE.CombinedCamera.prototype.toBackView = function () {
    this.rotation.x = 0;
    this.rotation.y = Math.PI;
    this.rotation.z = 0;
    this.rotationAutoUpdate = !1
};
THREE.CombinedCamera.prototype.toLeftView = function () {
    this.rotation.x = 0;
    this.rotation.y = -Math.PI / 2;
    this.rotation.z = 0;
    this.rotationAutoUpdate = !1
};
THREE.CombinedCamera.prototype.toRightView = function () {
    this.rotation.x = 0;
    this.rotation.y = Math.PI / 2;
    this.rotation.z = 0;
    this.rotationAutoUpdate = !1
};
THREE.CombinedCamera.prototype.toTopView = function () {
    this.rotation.x = -Math.PI / 2;
    this.rotation.y = 0;
    this.rotation.z = 0;
    this.rotationAutoUpdate = !1
};
THREE.CombinedCamera.prototype.toBottomView = function () {
    this.rotation.x = Math.PI / 2;
    this.rotation.y = 0;
    this.rotation.z = 0;
    this.rotationAutoUpdate = !1
};
THREE.BoxGeometry = function (a, b, c, e, d, g) {
    function f(a, b, f, c, d, e, g, p) {
        var u, v = k.widthSegments,
            w = k.heightSegments,
            y = d / 2,
            x = e / 2,
            A = k.vertices.length;
        if ("x" === a && "y" === b || "y" === a && "x" === b) u = "z";
        else if ("x" === a && "z" === b || "z" === a && "x" === b) u = "y", w = k.depthSegments;
        else if ("z" === a && "y" === b || "y" === a && "z" === b) u = "x", v = k.depthSegments;
        var N = v + 1,
            B = w + 1,
            G = d / v,
            C = e / w,
            P = new THREE.Vector3;
        P[u] = 0 < g ? 1 : -1;
        for (d = 0; d < B; d++)
            for (e = 0; e < N; e++) {
                var z = new THREE.Vector3;
                z[a] = (e * G - y) * f;
                z[b] = (d * C - x) * c;
                z[u] = g;
                k.vertices.push(z)
            }
        for (d =
            0; d < w; d++)
            for (e = 0; e < v; e++) x = e + N * d, a = e + N * (d + 1), b = e + 1 + N * (d + 1), f = e + 1 + N * d, c = new THREE.Vector2(e / v, 1 - d / w), g = new THREE.Vector2(e / v, 1 - (d + 1) / w), u = new THREE.Vector2((e + 1) / v, 1 - (d + 1) / w), y = new THREE.Vector2((e + 1) / v, 1 - d / w), x = new THREE.Face3(x + A, a + A, f + A), x.normal.copy(P), x.vertexNormals.push(P.clone(), P.clone(), P.clone()), x.materialIndex = p, k.faces.push(x), k.faceVertexUvs[0].push([c, g, y]), x = new THREE.Face3(a + A, b + A, f + A), x.normal.copy(P), x.vertexNormals.push(P.clone(), P.clone(), P.clone()), x.materialIndex = p, k.faces.push(x),
                k.faceVertexUvs[0].push([g.clone(), u, y.clone()])
    }
    THREE.Geometry.call(this);
    var k = this;
    this.width = a;
    this.height = b;
    this.depth = c;
    this.widthSegments = e || 1;
    this.heightSegments = d || 1;
    this.depthSegments = g || 1;
    a = this.width / 2;
    b = this.height / 2;
    c = this.depth / 2;
    f("z", "y", -1, -1, this.depth, this.height, a, 0);
    f("z", "y", 1, -1, this.depth, this.height, -a, 1);
    f("x", "z", 1, 1, this.width, this.depth, b, 2);
    f("x", "z", 1, -1, this.width, this.depth, -b, 3);
    f("x", "y", 1, -1, this.width, this.height, c, 4);
    f("x", "y", -1, -1, this.width, this.height, -c,
        5);
    this.computeCentroids();
    this.mergeVertices()
};
THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CircleGeometry = function (a, b, c, e) {
    THREE.Geometry.call(this);
    this.radius = a = a || 50;
    this.segments = b = void 0 !== b ? Math.max(3, b) : 8;
    this.thetaStart = c = void 0 !== c ? c : 0;
    this.thetaLength = e = void 0 !== e ? e : 2 * Math.PI;
    var d, g = [];
    d = new THREE.Vector3;
    var f = new THREE.Vector2(0.5, 0.5);
    this.vertices.push(d);
    g.push(f);
    for (d = 0; d <= b; d++) {
        var k = new THREE.Vector3,
            h = c + d / b * e;
        k.x = a * Math.cos(h);
        k.y = a * Math.sin(h);
        this.vertices.push(k);
        g.push(new THREE.Vector2((k.x / a + 1) / 2, (k.y / a + 1) / 2))
    }
    c = new THREE.Vector3(0, 0, 1);
    for (d = 1; d <= b; d++) this.faces.push(new THREE.Face3(d,
        d + 1, 0, [c.clone(), c.clone(), c.clone()])), this.faceVertexUvs[0].push([g[d].clone(), g[d + 1].clone(), f.clone()]);
    this.computeCentroids();
    this.computeFaceNormals();
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3, a)
};
THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CylinderGeometry = function (a, b, c, e, d, g) {
    THREE.Geometry.call(this);
    this.radiusTop = a = void 0 !== a ? a : 20;
    this.radiusBottom = b = void 0 !== b ? b : 20;
    this.height = c = void 0 !== c ? c : 100;
    this.radialSegments = e = e || 8;
    this.heightSegments = d = d || 1;
    this.openEnded = g = void 0 !== g ? g : !1;
    var f = c / 2,
        k, h, l = [],
        m = [];
    for (h = 0; h <= d; h++) {
        var n = [],
            r = [],
            s = h / d,
            t = s * (b - a) + a;
        for (k = 0; k <= e; k++) {
            var p = k / e,
                u = new THREE.Vector3;
            u.x = t * Math.sin(p * Math.PI * 2);
            u.y = -s * c + f;
            u.z = t * Math.cos(p * Math.PI * 2);
            this.vertices.push(u);
            n.push(this.vertices.length - 1);
            r.push(new THREE.Vector2(p,
                1 - s))
        }
        l.push(n);
        m.push(r)
    }
    c = (b - a) / c;
    for (k = 0; k < e; k++)
        for (0 !== a ? (n = this.vertices[l[0][k]].clone(), r = this.vertices[l[0][k + 1]].clone()) : (n = this.vertices[l[1][k]].clone(), r = this.vertices[l[1][k + 1]].clone()), n.setY(Math.sqrt(n.x * n.x + n.z * n.z) * c).normalize(), r.setY(Math.sqrt(r.x * r.x + r.z * r.z) * c).normalize(), h = 0; h < d; h++) {
            var s = l[h][k],
                t = l[h + 1][k],
                p = l[h + 1][k + 1],
                u = l[h][k + 1],
                v = n.clone(),
                w = n.clone(),
                y = r.clone(),
                x = r.clone(),
                A = m[h][k].clone(),
                N = m[h + 1][k].clone(),
                B = m[h + 1][k + 1].clone(),
                G = m[h][k + 1].clone();
            this.faces.push(new THREE.Face3(s,
                t, u, [v, w, x]));
            this.faceVertexUvs[0].push([A, N, G]);
            this.faces.push(new THREE.Face3(t, p, u, [w.clone(), y, x.clone()]));
            this.faceVertexUvs[0].push([N.clone(), B, G.clone()])
        }
    if (!1 === g && 0 < a)
        for (this.vertices.push(new THREE.Vector3(0, f, 0)), k = 0; k < e; k++) s = l[0][k], t = l[0][k + 1], p = this.vertices.length - 1, v = new THREE.Vector3(0, 1, 0), w = new THREE.Vector3(0, 1, 0), y = new THREE.Vector3(0, 1, 0), A = m[0][k].clone(), N = m[0][k + 1].clone(), B = new THREE.Vector2(N.x, 0), this.faces.push(new THREE.Face3(s, t, p, [v, w, y])), this.faceVertexUvs[0].push([A,
            N, B
        ]);
    if (!1 === g && 0 < b)
        for (this.vertices.push(new THREE.Vector3(0, -f, 0)), k = 0; k < e; k++) s = l[h][k + 1], t = l[h][k], p = this.vertices.length - 1, v = new THREE.Vector3(0, -1, 0), w = new THREE.Vector3(0, -1, 0), y = new THREE.Vector3(0, -1, 0), A = m[h][k + 1].clone(), N = m[h][k].clone(), B = new THREE.Vector2(N.x, 1), this.faces.push(new THREE.Face3(s, t, p, [v, w, y])), this.faceVertexUvs[0].push([A, N, B]);
    this.computeCentroids();
    this.computeFaceNormals()
};
THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ExtrudeGeometry = function (a, b) {
    "undefined" !== typeof a && (THREE.Geometry.call(this), a = a instanceof Array ? a : [a], this.shapebb = a[a.length - 1].getBoundingBox(), this.addShapeList(a, b), this.computeCentroids(), this.computeFaceNormals())
};
THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ExtrudeGeometry.prototype.addShapeList = function (a, b) {
    for (var c = a.length, e = 0; e < c; e++) this.addShape(a[e], b)
};
THREE.ExtrudeGeometry.prototype.addShape = function (a, b) {
    function c(a, b, f) {
        b || console.log("die");
        return b.clone().multiplyScalar(f).add(a)
    }

    function e(a, b, f) {
        var c = THREE.Math.sign,
            d = 1,
            d = a.x - b.x,
            k = a.y - b.y,
            e = f.x - a.x,
            h = f.y - a.y,
            g = d * d + k * k;
        if (1E-10 < Math.abs(d * h - k * e)) {
            var l = Math.sqrt(g),
                c = Math.sqrt(e * e + h * h),
                g = b.x - k / l;
            b = b.y + d / l;
            e = ((f.x - h / c - g) * h - (f.y + e / c - b) * e) / (d * h - k * e);
            f = g + d * e - a.x;
            a = b + k * e - a.y;
            d = f * f + a * a;
            if (2 >= d) return new THREE.Vector2(f, a);
            d = Math.sqrt(d / 2)
        } else a = !1, 1E-10 < d ? 1E-10 < e && (a = !0) : -1E-10 > d ? -1E-10 > e &&
            (a = !0) : c(k) == c(h) && (a = !0), a ? (f = -k, a = d, d = Math.sqrt(g)) : (f = d, a = k, d = Math.sqrt(g / 2));
        return new THREE.Vector2(f / d, a / d)
    }

    function d(f, c) {
        var d, k;
        for (K = f.length; 0 <= --K;) {
            d = K;
            k = K - 1;
            0 > k && (k = f.length - 1);
            for (var e = 0, h = s + 2 * m, e = 0; e < h; e++) {
                var g = Y * e,
                    l = Y * (e + 1),
                    n = c + d + g,
                    g = c + k + g,
                    r = c + k + l,
                    l = c + d + l,
                    p = f,
                    t = e,
                    u = h,
                    J = d,
                    x = k,
                    n = n + Q,
                    g = g + Q,
                    r = r + Q,
                    l = l + Q;
                z.faces.push(new THREE.Face3(n, g, l, null, null, w));
                z.faces.push(new THREE.Face3(g, r, l, null, null, w));
                n = y.generateSideWallUV(z, a, p, b, n, g, r, l, t, u, J, x);
                z.faceVertexUvs[0].push([n[0], n[1],
                    n[3]
                ]);
                z.faceVertexUvs[0].push([n[1], n[2], n[3]])
            }
        }
    }

    function g(a, b, f) {
        z.vertices.push(new THREE.Vector3(a, b, f))
    }

    function f(f, c, d, k) {
        f += Q;
        c += Q;
        d += Q;
        z.faces.push(new THREE.Face3(f, c, d, null, null, v));
        f = k ? y.generateBottomUV(z, a, b, f, c, d) : y.generateTopUV(z, a, b, f, c, d);
        z.faceVertexUvs[0].push(f)
    }
    var k = void 0 !== b.amount ? b.amount : 100,
        h = void 0 !== b.bevelThickness ? b.bevelThickness : 6,
        l = void 0 !== b.bevelSize ? b.bevelSize : h - 2,
        m = void 0 !== b.bevelSegments ? b.bevelSegments : 3,
        n = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0,
        r =
        void 0 !== b.curveSegments ? b.curveSegments : 12,
        s = void 0 !== b.steps ? b.steps : 1,
        t = b.extrudePath,
        p, u = !1,
        v = b.material,
        w = b.extrudeMaterial,
        y = void 0 !== b.UVGenerator ? b.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator,
        x, A, N, B;
    t && (p = t.getSpacedPoints(s), u = !0, n = !1, x = void 0 !== b.frames ? b.frames : new THREE.TubeGeometry.FrenetFrames(t, s, !1), A = new THREE.Vector3, N = new THREE.Vector3, B = new THREE.Vector3);
    n || (l = h = m = 0);
    var G, C, P, z = this,
        Q = this.vertices.length,
        t = a.extractPoints(r),
        r = t.shape,
        F = t.holes;
    if (t = !THREE.Shape.Utils.isClockWise(r)) {
        r =
            r.reverse();
        C = 0;
        for (P = F.length; C < P; C++) G = F[C], THREE.Shape.Utils.isClockWise(G) && (F[C] = G.reverse());
        t = !1
    }
    var O = THREE.Shape.Utils.triangulateShape(r, F),
        T = r;
    C = 0;
    for (P = F.length; C < P; C++) G = F[C], r = r.concat(G);
    var D, J, I, U, M, Y = r.length,
        S, X = O.length,
        t = [],
        K = 0;
    I = T.length;
    D = I - 1;
    for (J = K + 1; K < I; K++, D++, J++) D === I && (D = 0), J === I && (J = 0), t[K] = e(T[K], T[D], T[J]);
    var ca = [],
        ba, aa = t.concat();
    C = 0;
    for (P = F.length; C < P; C++) {
        G = F[C];
        ba = [];
        K = 0;
        I = G.length;
        D = I - 1;
        for (J = K + 1; K < I; K++, D++, J++) D === I && (D = 0), J === I && (J = 0), ba[K] = e(G[K], G[D], G[J]);
        ca.push(ba);
        aa = aa.concat(ba)
    }
    for (D = 0; D < m; D++) {
        I = D / m;
        U = h * (1 - I);
        J = l * Math.sin(I * Math.PI / 2);
        K = 0;
        for (I = T.length; K < I; K++) M = c(T[K], t[K], J), g(M.x, M.y, -U);
        C = 0;
        for (P = F.length; C < P; C++)
            for (G = F[C], ba = ca[C], K = 0, I = G.length; K < I; K++) M = c(G[K], ba[K], J), g(M.x, M.y, -U)
    }
    J = l;
    for (K = 0; K < Y; K++) M = n ? c(r[K], aa[K], J) : r[K], u ? (N.copy(x.normals[0]).multiplyScalar(M.x), A.copy(x.binormals[0]).multiplyScalar(M.y), B.copy(p[0]).add(N).add(A), g(B.x, B.y, B.z)) : g(M.x, M.y, 0);
    for (I = 1; I <= s; I++)
        for (K = 0; K < Y; K++) M = n ? c(r[K], aa[K], J) : r[K], u ? (N.copy(x.normals[I]).multiplyScalar(M.x),
            A.copy(x.binormals[I]).multiplyScalar(M.y), B.copy(p[I]).add(N).add(A), g(B.x, B.y, B.z)) : g(M.x, M.y, k / s * I);
    for (D = m - 1; 0 <= D; D--) {
        I = D / m;
        U = h * (1 - I);
        J = l * Math.sin(I * Math.PI / 2);
        K = 0;
        for (I = T.length; K < I; K++) M = c(T[K], t[K], J), g(M.x, M.y, k + U);
        C = 0;
        for (P = F.length; C < P; C++)
            for (G = F[C], ba = ca[C], K = 0, I = G.length; K < I; K++) M = c(G[K], ba[K], J), u ? g(M.x, M.y + p[s - 1].y, p[s - 1].x + U) : g(M.x, M.y, k + U)
    }(function () {
        if (n) {
            var a;
            a = 0 * Y;
            for (K = 0; K < X; K++) S = O[K], f(S[2] + a, S[1] + a, S[0] + a, !0);
            a = s + 2 * m;
            a *= Y;
            for (K = 0; K < X; K++) S = O[K], f(S[0] + a, S[1] + a, S[2] + a, !1)
        } else {
            for (K =
                0; K < X; K++) S = O[K], f(S[2], S[1], S[0], !0);
            for (K = 0; K < X; K++) S = O[K], f(S[0] + Y * s, S[1] + Y * s, S[2] + Y * s, !1)
        }
    })();
    (function () {
        var a = 0;
        d(T, a);
        a += T.length;
        C = 0;
        for (P = F.length; C < P; C++) G = F[C], d(G, a), a += G.length
    })()
};
THREE.ExtrudeGeometry.WorldUVGenerator = {
    generateTopUV: function (a, b, c, e, d, g) {
        b = a.vertices[d].x;
        d = a.vertices[d].y;
        c = a.vertices[g].x;
        g = a.vertices[g].y;
        return [new THREE.Vector2(a.vertices[e].x, a.vertices[e].y), new THREE.Vector2(b, d), new THREE.Vector2(c, g)]
    },
    generateBottomUV: function (a, b, c, e, d, g) {
        return this.generateTopUV(a, b, c, e, d, g)
    },
    generateSideWallUV: function (a, b, c, e, d, g, f, k, h, l, m, n) {
        b = a.vertices[d].x;
        c = a.vertices[d].y;
        d = a.vertices[d].z;
        e = a.vertices[g].x;
        h = a.vertices[g].y;
        g = a.vertices[g].z;
        l = a.vertices[f].x;
        m = a.vertices[f].y;
        f = a.vertices[f].z;
        n = a.vertices[k].x;
        var r = a.vertices[k].y;
        a = a.vertices[k].z;
        return 0.01 > Math.abs(c - h) ? [new THREE.Vector2(b, 1 - d), new THREE.Vector2(e, 1 - g), new THREE.Vector2(l, 1 - f), new THREE.Vector2(n, 1 - a)] : [new THREE.Vector2(c, 1 - d), new THREE.Vector2(h, 1 - g), new THREE.Vector2(m, 1 - f), new THREE.Vector2(r, 1 - a)]
    }
};
THREE.ExtrudeGeometry.__v1 = new THREE.Vector2;
THREE.ExtrudeGeometry.__v2 = new THREE.Vector2;
THREE.ExtrudeGeometry.__v3 = new THREE.Vector2;
THREE.ExtrudeGeometry.__v4 = new THREE.Vector2;
THREE.ExtrudeGeometry.__v5 = new THREE.Vector2;
THREE.ExtrudeGeometry.__v6 = new THREE.Vector2;
THREE.ShapeGeometry = function (a, b) {
    THREE.Geometry.call(this);
    !1 === a instanceof Array && (a = [a]);
    this.shapebb = a[a.length - 1].getBoundingBox();
    this.addShapeList(a, b);
    this.computeCentroids();
    this.computeFaceNormals()
};
THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ShapeGeometry.prototype.addShapeList = function (a, b) {
    for (var c = 0, e = a.length; c < e; c++) this.addShape(a[c], b);
    return this
};
THREE.ShapeGeometry.prototype.addShape = function (a, b) {
    void 0 === b && (b = {});
    var c = b.material,
        e = void 0 === b.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : b.UVGenerator,
        d, g, f, k = this.vertices.length;
    d = a.extractPoints(void 0 !== b.curveSegments ? b.curveSegments : 12);
    var h = d.shape,
        l = d.holes;
    if (!THREE.Shape.Utils.isClockWise(h))
        for (h = h.reverse(), d = 0, g = l.length; d < g; d++) f = l[d], THREE.Shape.Utils.isClockWise(f) && (l[d] = f.reverse());
    var m = THREE.Shape.Utils.triangulateShape(h, l);
    d = 0;
    for (g = l.length; d < g; d++) f = l[d],
        h = h.concat(f);
    l = h.length;
    g = m.length;
    for (d = 0; d < l; d++) f = h[d], this.vertices.push(new THREE.Vector3(f.x, f.y, 0));
    for (d = 0; d < g; d++) l = m[d], h = l[0] + k, f = l[1] + k, l = l[2] + k, this.faces.push(new THREE.Face3(h, f, l, null, null, c)), this.faceVertexUvs[0].push(e.generateBottomUV(this, a, b, h, f, l))
};
THREE.LatheGeometry = function (a, b, c, e) {
    THREE.Geometry.call(this);
    b = b || 12;
    c = c || 0;
    e = e || 2 * Math.PI;
    for (var d = 1 / (a.length - 1), g = 1 / b, f = 0, k = b; f <= k; f++)
        for (var h = c + f * g * e, l = Math.cos(h), m = Math.sin(h), h = 0, n = a.length; h < n; h++) {
            var r = a[h],
                s = new THREE.Vector3;
            s.x = l * r.x - m * r.y;
            s.y = m * r.x + l * r.y;
            s.z = r.z;
            this.vertices.push(s)
        }
    c = a.length;
    f = 0;
    for (k = b; f < k; f++)
        for (h = 0, n = a.length - 1; h < n; h++) {
            b = m = h + c * f;
            e = m + c;
            var l = m + 1 + c,
                m = m + 1,
                r = f * g,
                s = h * d,
                t = r + g,
                p = s + d;
            this.faces.push(new THREE.Face3(b, e, m));
            this.faceVertexUvs[0].push([new THREE.Vector2(r,
                s), new THREE.Vector2(t, s), new THREE.Vector2(r, p)]);
            this.faces.push(new THREE.Face3(e, l, m));
            this.faceVertexUvs[0].push([new THREE.Vector2(t, s), new THREE.Vector2(t, p), new THREE.Vector2(r, p)])
        }
    this.mergeVertices();
    this.computeCentroids();
    this.computeFaceNormals();
    this.computeVertexNormals()
};
THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.PlaneGeometry = function (a, b, c, e) {
    THREE.Geometry.call(this);
    this.width = a;
    this.height = b;
    this.widthSegments = c || 1;
    this.heightSegments = e || 1;
    var d = a / 2,
        g = b / 2;
    c = this.widthSegments;
    e = this.heightSegments;
    var f = c + 1,
        k = e + 1,
        h = this.width / c,
        l = this.height / e,
        m = new THREE.Vector3(0, 0, 1);
    for (a = 0; a < k; a++)
        for (b = 0; b < f; b++) this.vertices.push(new THREE.Vector3(b * h - d, -(a * l - g), 0));
    for (a = 0; a < e; a++)
        for (b = 0; b < c; b++) {
            var n = b + f * a,
                d = b + f * (a + 1),
                g = b + 1 + f * (a + 1),
                k = b + 1 + f * a,
                h = new THREE.Vector2(b / c, 1 - a / e),
                l = new THREE.Vector2(b / c, 1 - (a +
                    1) / e),
                r = new THREE.Vector2((b + 1) / c, 1 - (a + 1) / e),
                s = new THREE.Vector2((b + 1) / c, 1 - a / e),
                n = new THREE.Face3(n, d, k);
            n.normal.copy(m);
            n.vertexNormals.push(m.clone(), m.clone(), m.clone());
            this.faces.push(n);
            this.faceVertexUvs[0].push([h, l, s]);
            n = new THREE.Face3(d, g, k);
            n.normal.copy(m);
            n.vertexNormals.push(m.clone(), m.clone(), m.clone());
            this.faces.push(n);
            this.faceVertexUvs[0].push([l.clone(), r, s.clone()])
        }
    this.computeCentroids()
};
THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.RingGeometry = function (a, b, c, e, d, g) {
    THREE.Geometry.call(this);
    a = a || 0;
    b = b || 50;
    d = void 0 !== d ? d : 0;
    g = void 0 !== g ? g : 2 * Math.PI;
    c = void 0 !== c ? Math.max(3, c) : 8;
    e = void 0 !== e ? Math.max(3, e) : 8;
    var f, k = [],
        h = a,
        l = (b - a) / e;
    for (a = 0; a <= e; a++) {
        for (f = 0; f <= c; f++) {
            var m = new THREE.Vector3,
                n = d + f / c * g;
            m.x = h * Math.cos(n);
            m.y = h * Math.sin(n);
            this.vertices.push(m);
            k.push(new THREE.Vector2((m.x / b + 1) / 2, (m.y / b + 1) / 2))
        }
        h += l
    }
    b = new THREE.Vector3(0, 0, 1);
    for (a = 0; a < e; a++)
        for (d = a * c, f = 0; f <= c; f++) n = f + d, g = n + a, l = n + c + a, m = n + c + 1 + a, this.faces.push(new THREE.Face3(g,
            l, m, [b.clone(), b.clone(), b.clone()])), this.faceVertexUvs[0].push([k[g].clone(), k[l].clone(), k[m].clone()]), g = n + a, l = n + c + 1 + a, m = n + 1 + a, this.faces.push(new THREE.Face3(g, l, m, [b.clone(), b.clone(), b.clone()])), this.faceVertexUvs[0].push([k[g].clone(), k[l].clone(), k[m].clone()]);
    this.computeCentroids();
    this.computeFaceNormals();
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3, h)
};
THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.SphereGeometry = function (a, b, c, e, d, g, f) {
    THREE.Geometry.call(this);
    this.radius = a = a || 50;
    this.widthSegments = b = Math.max(3, Math.floor(b) || 8);
    this.heightSegments = c = Math.max(2, Math.floor(c) || 6);
    this.phiStart = e = void 0 !== e ? e : 0;
    this.phiLength = d = void 0 !== d ? d : 2 * Math.PI;
    this.thetaStart = g = void 0 !== g ? g : 0;
    this.thetaLength = f = void 0 !== f ? f : Math.PI;
    var k, h, l = [],
        m = [];
    for (h = 0; h <= c; h++) {
        var n = [],
            r = [];
        for (k = 0; k <= b; k++) {
            var s = k / b,
                t = h / c,
                p = new THREE.Vector3;
            p.x = -a * Math.cos(e + s * d) * Math.sin(g + t * f);
            p.y = a * Math.cos(g + t * f);
            p.z = a * Math.sin(e + s * d) * Math.sin(g + t * f);
            this.vertices.push(p);
            n.push(this.vertices.length - 1);
            r.push(new THREE.Vector2(s, 1 - t))
        }
        l.push(n);
        m.push(r)
    }
    for (h = 0; h < this.heightSegments; h++)
        for (k = 0; k < this.widthSegments; k++) {
            b = l[h][k + 1];
            c = l[h][k];
            e = l[h + 1][k];
            d = l[h + 1][k + 1];
            g = this.vertices[b].clone().normalize();
            f = this.vertices[c].clone().normalize();
            var n = this.vertices[e].clone().normalize(),
                r = this.vertices[d].clone().normalize(),
                s = m[h][k + 1].clone(),
                t = m[h][k].clone(),
                p = m[h + 1][k].clone(),
                u = m[h + 1][k + 1].clone();
            Math.abs(this.vertices[b].y) ===
                this.radius ? (s.x = (s.x + t.x) / 2, this.faces.push(new THREE.Face3(b, e, d, [g, n, r])), this.faceVertexUvs[0].push([s, p, u])) : Math.abs(this.vertices[e].y) === this.radius ? (p.x = (p.x + u.x) / 2, this.faces.push(new THREE.Face3(b, c, e, [g, f, n])), this.faceVertexUvs[0].push([s, t, p])) : (this.faces.push(new THREE.Face3(b, c, d, [g, f, r])), this.faceVertexUvs[0].push([s, t, u]), this.faces.push(new THREE.Face3(c, e, d, [f.clone(), n, r.clone()])), this.faceVertexUvs[0].push([t.clone(), p, u.clone()]))
        }
    this.computeCentroids();
    this.computeFaceNormals();
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3, a)
};
THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TextGeometry = function (a, b) {
    b = b || {};
    var c = THREE.FontUtils.generateShapes(a, b);
    b.amount = void 0 !== b.height ? b.height : 50;
    void 0 === b.bevelThickness && (b.bevelThickness = 10);
    void 0 === b.bevelSize && (b.bevelSize = 8);
    void 0 === b.bevelEnabled && (b.bevelEnabled = !1);
    THREE.ExtrudeGeometry.call(this, c, b)
};
THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype);
THREE.TorusGeometry = function (a, b, c, e, d) {
    THREE.Geometry.call(this);
    this.radius = a || 100;
    this.tube = b || 40;
    this.radialSegments = c || 8;
    this.tubularSegments = e || 6;
    this.arc = d || 2 * Math.PI;
    d = new THREE.Vector3;
    a = [];
    b = [];
    for (c = 0; c <= this.radialSegments; c++)
        for (e = 0; e <= this.tubularSegments; e++) {
            var g = e / this.tubularSegments * this.arc,
                f = c / this.radialSegments * Math.PI * 2;
            d.x = this.radius * Math.cos(g);
            d.y = this.radius * Math.sin(g);
            var k = new THREE.Vector3;
            k.x = (this.radius + this.tube * Math.cos(f)) * Math.cos(g);
            k.y = (this.radius + this.tube *
                Math.cos(f)) * Math.sin(g);
            k.z = this.tube * Math.sin(f);
            this.vertices.push(k);
            a.push(new THREE.Vector2(e / this.tubularSegments, c / this.radialSegments));
            b.push(k.clone().sub(d).normalize())
        }
    for (c = 1; c <= this.radialSegments; c++)
        for (e = 1; e <= this.tubularSegments; e++) {
            d = (this.tubularSegments + 1) * c + e - 1;
            var g = (this.tubularSegments + 1) * (c - 1) + e - 1,
                f = (this.tubularSegments + 1) * (c - 1) + e,
                k = (this.tubularSegments + 1) * c + e,
                h = new THREE.Face3(d, g, k, [b[d].clone(), b[g].clone(), b[k].clone()]);
            this.faces.push(h);
            this.faceVertexUvs[0].push([a[d].clone(),
                a[g].clone(), a[k].clone()
            ]);
            h = new THREE.Face3(g, f, k, [b[g].clone(), b[f].clone(), b[k].clone()]);
            this.faces.push(h);
            this.faceVertexUvs[0].push([a[g].clone(), a[f].clone(), a[k].clone()])
        }
    this.computeCentroids();
    this.computeFaceNormals()
};
THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry = function (a, b, c, e, d) {
    THREE.Geometry.call(this);
    this.path = a;
    this.segments = b || 64;
    this.radius = c || 1;
    this.radialSegments = e || 8;
    this.closed = d || !1;
    this.grid = [];
    var g, f;
    e = this.segments + 1;
    var k, h, l;
    d = new THREE.Vector3;
    var m, n;
    b = new THREE.TubeGeometry.FrenetFrames(this.path, this.segments, this.closed);
    m = b.normals;
    n = b.binormals;
    this.tangents = b.tangents;
    this.normals = m;
    this.binormals = n;
    for (b = 0; b < e; b++)
        for (this.grid[b] = [], c = b / (e - 1), l = a.getPointAt(c), g = m[b], f = n[b], c = 0; c < this.radialSegments; c++) k =
            c / this.radialSegments * 2 * Math.PI, h = -this.radius * Math.cos(k), k = this.radius * Math.sin(k), d.copy(l), d.x += h * g.x + k * f.x, d.y += h * g.y + k * f.y, d.z += h * g.z + k * f.z, this.grid[b][c] = this.vertices.push(new THREE.Vector3(d.x, d.y, d.z)) - 1;
    for (b = 0; b < this.segments; b++)
        for (c = 0; c < this.radialSegments; c++) d = this.closed ? (b + 1) % this.segments : b + 1, m = (c + 1) % this.radialSegments, a = this.grid[b][c], e = this.grid[d][c], d = this.grid[d][m], m = this.grid[b][m], n = new THREE.Vector2(b / this.segments, c / this.radialSegments), g = new THREE.Vector2((b + 1) / this.segments,
            c / this.radialSegments), f = new THREE.Vector2((b + 1) / this.segments, (c + 1) / this.radialSegments), h = new THREE.Vector2(b / this.segments, (c + 1) / this.radialSegments), this.faces.push(new THREE.Face3(a, e, m)), this.faceVertexUvs[0].push([n, g, h]), this.faces.push(new THREE.Face3(e, d, m)), this.faceVertexUvs[0].push([g.clone(), f, h.clone()]);
    this.computeCentroids();
    this.computeFaceNormals();
    this.computeVertexNormals()
};
THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry.FrenetFrames = function (a, b, c) {
    new THREE.Vector3;
    var e = new THREE.Vector3;
    new THREE.Vector3;
    var d = [],
        g = [],
        f = [],
        k = new THREE.Vector3,
        h = new THREE.Matrix4;
    b += 1;
    var l, m, n;
    this.tangents = d;
    this.normals = g;
    this.binormals = f;
    for (l = 0; l < b; l++) m = l / (b - 1), d[l] = a.getTangentAt(m), d[l].normalize();
    g[0] = new THREE.Vector3;
    f[0] = new THREE.Vector3;
    a = Number.MAX_VALUE;
    l = Math.abs(d[0].x);
    m = Math.abs(d[0].y);
    n = Math.abs(d[0].z);
    l <= a && (a = l, e.set(1, 0, 0));
    m <= a && (a = m, e.set(0, 1, 0));
    n <= a && e.set(0, 0, 1);
    k.crossVectors(d[0],
        e).normalize();
    g[0].crossVectors(d[0], k);
    f[0].crossVectors(d[0], g[0]);
    for (l = 1; l < b; l++) g[l] = g[l - 1].clone(), f[l] = f[l - 1].clone(), k.crossVectors(d[l - 1], d[l]), 1E-4 < k.length() && (k.normalize(), e = Math.acos(THREE.Math.clamp(d[l - 1].dot(d[l]), -1, 1)), g[l].applyMatrix4(h.makeRotationAxis(k, e))), f[l].crossVectors(d[l], g[l]);
    if (c)
        for (e = Math.acos(THREE.Math.clamp(g[0].dot(g[b - 1]), -1, 1)), e /= b - 1, 0 < d[0].dot(k.crossVectors(g[0], g[b - 1])) && (e = -e), l = 1; l < b; l++) g[l].applyMatrix4(h.makeRotationAxis(d[l], e * l)), f[l].crossVectors(d[l],
            g[l])
};
THREE.ParametricGeometry = function (a, b, c) {
    THREE.Geometry.call(this);
    var e = this.vertices,
        d = this.faces,
        g = this.faceVertexUvs[0],
        f, k, h, l, m = b + 1;
    for (f = 0; f <= c; f++)
        for (l = f / c, k = 0; k <= b; k++) h = k / b, h = a(h, l), e.push(h);
    var n, r, s, t;
    for (f = 0; f < c; f++)
        for (k = 0; k < b; k++) a = f * m + k, e = f * m + k + 1, l = (f + 1) * m + k + 1, h = (f + 1) * m + k, n = new THREE.Vector2(k / b, f / c), r = new THREE.Vector2((k + 1) / b, f / c), s = new THREE.Vector2((k + 1) / b, (f + 1) / c), t = new THREE.Vector2(k / b, (f + 1) / c), d.push(new THREE.Face3(a, e, h)), g.push([n, r, t]), d.push(new THREE.Face3(e, l, h)),
            g.push([r.clone(), s, t.clone()]);
    this.computeCentroids();
    this.computeFaceNormals();
    this.computeVertexNormals()
};
THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.AxisHelper = function (a) {
    a = a || 1;
    var b = new THREE.Geometry;
    b.vertices.push(new THREE.Vector3, new THREE.Vector3(a, 0, 0), new THREE.Vector3, new THREE.Vector3(0, a, 0), new THREE.Vector3, new THREE.Vector3(0, 0, a));
    b.colors.push(new THREE.Color(16711680), new THREE.Color(16755200), new THREE.Color(65280), new THREE.Color(11206400), new THREE.Color(255), new THREE.Color(43775));
    a = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors
    });
    THREE.Line.call(this, b, a, THREE.LinePieces)
};
THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype);
THREE.ArrowHelper = function (a, b, c, e, d, g) {
    THREE.Object3D.call(this);
    void 0 === e && (e = 16776960);
    void 0 === c && (c = 1);
    void 0 === d && (d = 0.2 * c);
    void 0 === g && (g = 0.2 * d);
    this.position = b;
    b = new THREE.Geometry;
    b.vertices.push(new THREE.Vector3(0, 0, 0));
    b.vertices.push(new THREE.Vector3(0, 1, 0));
    this.line = new THREE.Line(b, new THREE.LineBasicMaterial({
        color: e
    }));
    this.line.matrixAutoUpdate = !1;
    this.add(this.line);
    b = new THREE.CylinderGeometry(0, 0.5, 1, 5, 1);
    b.applyMatrix((new THREE.Matrix4).makeTranslation(0, -0.5, 0));
    this.cone =
        new THREE.Mesh(b, new THREE.MeshBasicMaterial({
            color: e
        }));
    this.cone.matrixAutoUpdate = !1;
    this.add(this.cone);
    this.setDirection(a);
    this.setLength(c, d, g)
};
THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.ArrowHelper.prototype.setDirection = function () {
    var a = new THREE.Vector3,
        b;
    return function (c) {
        0.99999 < c.y ? this.quaternion.set(0, 0, 0, 1) : -0.99999 > c.y ? this.quaternion.set(1, 0, 0, 0) : (a.set(c.z, 0, -c.x).normalize(), b = Math.acos(c.y), this.quaternion.setFromAxisAngle(a, b))
    }
}();
THREE.ArrowHelper.prototype.setLength = function (a, b, c) {
    void 0 === b && (b = 0.2 * a);
    void 0 === c && (c = 0.2 * b);
    this.line.scale.set(1, a, 1);
    this.line.updateMatrix();
    this.cone.scale.set(c, b, c);
    this.cone.position.y = a;
    this.cone.updateMatrix()
};
THREE.ArrowHelper.prototype.setColor = function (a) {
    this.line.material.color.setHex(a);
    this.cone.material.color.setHex(a)
};
THREE.BoxHelper = function (a) {
    var b = [new THREE.Vector3(1, 1, 1), new THREE.Vector3(-1, 1, 1), new THREE.Vector3(-1, -1, 1), new THREE.Vector3(1, -1, 1), new THREE.Vector3(1, 1, -1), new THREE.Vector3(-1, 1, -1), new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, -1, -1)];
    this.vertices = b;
    var c = new THREE.Geometry;
    c.vertices.push(b[0], b[1], b[1], b[2], b[2], b[3], b[3], b[0], b[4], b[5], b[5], b[6], b[6], b[7], b[7], b[4], b[0], b[4], b[1], b[5], b[2], b[6], b[3], b[7]);
    THREE.Line.call(this, c, new THREE.LineBasicMaterial({
        color: 16776960
    }), THREE.LinePieces);
    void 0 !== a && this.update(a)
};
THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype);
THREE.BoxHelper.prototype.update = function (a) {
    var b = a.geometry;
    null === b.boundingBox && b.computeBoundingBox();
    var c = b.boundingBox.min,
        b = b.boundingBox.max,
        e = this.vertices;
    e[0].set(b.x, b.y, b.z);
    e[1].set(c.x, b.y, b.z);
    e[2].set(c.x, c.y, b.z);
    e[3].set(b.x, c.y, b.z);
    e[4].set(b.x, b.y, c.z);
    e[5].set(c.x, b.y, c.z);
    e[6].set(c.x, c.y, c.z);
    e[7].set(b.x, c.y, c.z);
    this.geometry.computeBoundingSphere();
    this.geometry.verticesNeedUpdate = !0;
    this.matrixAutoUpdate = !1;
    this.matrixWorld = a.matrixWorld
};
THREE.BoundingBoxHelper = function (a, b) {
    var c = void 0 !== b ? b : 8947848;
    this.object = a;
    this.box = new THREE.Box3;
    THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
        color: c,
        wireframe: !0
    }))
};
THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.BoundingBoxHelper.prototype.update = function () {
    this.box.setFromObject(this.object);
    this.box.size(this.scale);
    this.box.center(this.position)
};
THREE.CameraHelper = function (a) {
    function b(a, b, d) {
        c(a, d);
        c(b, d)
    }

    function c(a, b) {
        e.vertices.push(new THREE.Vector3);
        e.colors.push(new THREE.Color(b));
        void 0 === g[a] && (g[a] = []);
        g[a].push(e.vertices.length - 1)
    }
    var e = new THREE.Geometry,
        d = new THREE.LineBasicMaterial({
            color: 16777215,
            vertexColors: THREE.FaceColors
        }),
        g = {};
    b("n1", "n2", 16755200);
    b("n2", "n4", 16755200);
    b("n4", "n3", 16755200);
    b("n3", "n1", 16755200);
    b("f1", "f2", 16755200);
    b("f2", "f4", 16755200);
    b("f4", "f3", 16755200);
    b("f3", "f1", 16755200);
    b("n1", "f1", 16755200);
    b("n2", "f2", 16755200);
    b("n3", "f3", 16755200);
    b("n4", "f4", 16755200);
    b("p", "n1", 16711680);
    b("p", "n2", 16711680);
    b("p", "n3", 16711680);
    b("p", "n4", 16711680);
    b("u1", "u2", 43775);
    b("u2", "u3", 43775);
    b("u3", "u1", 43775);
    b("c", "t", 16777215);
    b("p", "c", 3355443);
    b("cn1", "cn2", 3355443);
    b("cn3", "cn4", 3355443);
    b("cf1", "cf2", 3355443);
    b("cf3", "cf4", 3355443);
    THREE.Line.call(this, e, d, THREE.LinePieces);
    this.camera = a;
    this.matrixWorld = a.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.pointMap = g;
    this.update()
};
THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype);
THREE.CameraHelper.prototype.update = function () {
    var a = new THREE.Vector3,
        b = new THREE.Camera,
        c = new THREE.Projector;
    return function () {
        function e(e, f, k, h) {
            a.set(f, k, h);
            c.unprojectVector(a, b);
            e = d.pointMap[e];
            if (void 0 !== e)
                for (f = 0, k = e.length; f < k; f++) d.geometry.vertices[e[f]].copy(a)
        }
        var d = this;
        b.projectionMatrix.copy(this.camera.projectionMatrix);
        e("c", 0, 0, -1);
        e("t", 0, 0, 1);
        e("n1", -1, -1, -1);
        e("n2", 1, -1, -1);
        e("n3", -1, 1, -1);
        e("n4", 1, 1, -1);
        e("f1", -1, -1, 1);
        e("f2", 1, -1, 1);
        e("f3", -1, 1, 1);
        e("f4", 1, 1, 1);
        e("u1", 0.7,
            1.1, -1);
        e("u2", -0.7, 1.1, -1);
        e("u3", 0, 2, -1);
        e("cf1", -1, 0, 1);
        e("cf2", 1, 0, 1);
        e("cf3", 0, -1, 1);
        e("cf4", 0, 1, 1);
        e("cn1", -1, 0, -1);
        e("cn2", 1, 0, -1);
        e("cn3", 0, -1, -1);
        e("cn4", 0, 1, -1);
        this.geometry.verticesNeedUpdate = !0
    }
}();
THREE.DirectionalLightHelper = function (a, b) {
    THREE.Object3D.call(this);
    this.light = a;
    this.light.updateMatrixWorld();
    this.matrixWorld = a.matrixWorld;
    this.matrixAutoUpdate = !1;
    b = b || 1;
    var c = new THREE.PlaneGeometry(b, b),
        e = new THREE.MeshBasicMaterial({
            wireframe: !0,
            fog: !1
        });
    e.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    this.lightPlane = new THREE.Mesh(c, e);
    this.add(this.lightPlane);
    c = new THREE.Geometry;
    c.vertices.push(new THREE.Vector3);
    c.vertices.push(new THREE.Vector3);
    e = new THREE.LineBasicMaterial({
        fog: !1
    });
    e.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    this.targetLine = new THREE.Line(c, e);
    this.add(this.targetLine);
    this.update()
};
THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.DirectionalLightHelper.prototype.dispose = function () {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose()
};
THREE.DirectionalLightHelper.prototype.update = function () {
    var a = new THREE.Vector3,
        b = new THREE.Vector3,
        c = new THREE.Vector3;
    return function () {
        a.setFromMatrixPosition(this.light.matrixWorld);
        b.setFromMatrixPosition(this.light.target.matrixWorld);
        c.subVectors(b, a);
        this.lightPlane.lookAt(c);
        this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        this.targetLine.geometry.vertices[1].copy(c);
        this.targetLine.geometry.verticesNeedUpdate = !0;
        this.targetLine.material.color.copy(this.lightPlane.material.color)
    }
}();
THREE.EdgesHelper = function (a, b) {
    var c = void 0 !== b ? b : 16777215,
        e = [0, 0],
        d = {},
        g = function (a, b) {
            return a - b
        },
        f = ["a", "b", "c"],
        k = new THREE.BufferGeometry,
        h = a.geometry.clone();
    h.mergeVertices();
    h.computeFaceNormals();
    for (var l = h.vertices, h = h.faces, m = 0, n = 0, r = h.length; n < r; n++)
        for (var s = h[n], t = 0; 3 > t; t++) {
            e[0] = s[f[t]];
            e[1] = s[f[(t + 1) % 3]];
            e.sort(g);
            var p = e.toString();
            void 0 === d[p] ? (d[p] = {
                vert1: e[0],
                vert2: e[1],
                face1: n,
                face2: void 0
            }, m++) : d[p].face2 = n
        }
    k.addAttribute("position", Float32Array, 2 * m, 3);
    e = k.attributes.position.array;
    g = 0;
    for (p in d)
        if (f = d[p], void 0 === f.face2 || 0.9999 > h[f.face1].normal.dot(h[f.face2].normal)) m = l[f.vert1], e[g++] = m.x, e[g++] = m.y, e[g++] = m.z, m = l[f.vert2], e[g++] = m.x, e[g++] = m.y, e[g++] = m.z;
    THREE.Line.call(this, k, new THREE.LineBasicMaterial({
        color: c
    }), THREE.LinePieces);
    this.matrixAutoUpdate = !1;
    this.matrixWorld = a.matrixWorld
};
THREE.EdgesHelper.prototype = Object.create(THREE.Line.prototype);
THREE.FaceNormalsHelper = function (a, b, c, e) {
    this.object = a;
    this.size = void 0 !== b ? b : 1;
    a = void 0 !== c ? c : 16776960;
    e = void 0 !== e ? e : 1;
    b = new THREE.Geometry;
    c = 0;
    for (var d = this.object.geometry.faces.length; c < d; c++) b.vertices.push(new THREE.Vector3), b.vertices.push(new THREE.Vector3);
    THREE.Line.call(this, b, new THREE.LineBasicMaterial({
        color: a,
        linewidth: e
    }), THREE.LinePieces);
    this.matrixAutoUpdate = !1;
    this.normalMatrix = new THREE.Matrix3;
    this.update()
};
THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.FaceNormalsHelper.prototype.update = function (a) {
    var b = new THREE.Vector3;
    return function (a) {
        this.object.updateMatrixWorld(!0);
        this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
        a = this.geometry.vertices;
        for (var e = this.object.geometry.faces, d = this.object.matrixWorld, g = 0, f = e.length; g < f; g++) {
            var k = e[g];
            b.copy(k.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
            var h = 2 * g;
            a[h].copy(k.centroid).applyMatrix4(d);
            a[h + 1].addVectors(a[h], b)
        }
        this.geometry.verticesNeedUpdate = !0;
        return this
    }
}();
THREE.GridHelper = function (a, b) {
    var c = new THREE.Geometry,
        e = new THREE.LineBasicMaterial({
            vertexColors: THREE.VertexColors
        });
    this.color1 = new THREE.Color(4473924);
    this.color2 = new THREE.Color(8947848);
    for (var d = -a; d <= a; d += b) {
        c.vertices.push(new THREE.Vector3(-a, 0, d), new THREE.Vector3(a, 0, d), new THREE.Vector3(d, 0, -a), new THREE.Vector3(d, 0, a));
        var g = 0 === d ? this.color1 : this.color2;
        c.colors.push(g, g, g, g)
    }
    THREE.Line.call(this, c, e, THREE.LinePieces)
};
THREE.GridHelper.prototype = Object.create(THREE.Line.prototype);
THREE.GridHelper.prototype.setColors = function (a, b) {
    this.color1.set(a);
    this.color2.set(b);
    this.geometry.colorsNeedUpdate = !0
};
THREE.HemisphereLightHelper = function (a, b, c, e) {
    THREE.Object3D.call(this);
    this.light = a;
    this.light.updateMatrixWorld();
    this.matrixWorld = a.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.colors = [new THREE.Color, new THREE.Color];
    a = new THREE.SphereGeometry(b, 4, 2);
    a.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
    for (b = 0; 8 > b; b++) a.faces[b].color = this.colors[4 > b ? 0 : 1];
    b = new THREE.MeshBasicMaterial({
        vertexColors: THREE.FaceColors,
        wireframe: !0
    });
    this.lightSphere = new THREE.Mesh(a, b);
    this.add(this.lightSphere);
    this.update()
};
THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.HemisphereLightHelper.prototype.dispose = function () {
    this.lightSphere.geometry.dispose();
    this.lightSphere.material.dispose()
};
THREE.HemisphereLightHelper.prototype.update = function () {
    var a = new THREE.Vector3;
    return function () {
        this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
        this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
        this.lightSphere.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate());
        this.lightSphere.geometry.colorsNeedUpdate = !0
    }
}();
THREE.PointLightHelper = function (a, b) {
    this.light = a;
    this.light.updateMatrixWorld();
    var c = new THREE.SphereGeometry(b, 4, 2),
        e = new THREE.MeshBasicMaterial({
            wireframe: !0,
            fog: !1
        });
    e.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    THREE.Mesh.call(this, c, e);
    this.matrixWorld = this.light.matrixWorld;
    this.matrixAutoUpdate = !1
};
THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.PointLightHelper.prototype.dispose = function () {
    this.geometry.dispose();
    this.material.dispose()
};
THREE.PointLightHelper.prototype.update = function () {
    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
};
THREE.SpotLightHelper = function (a) {
    THREE.Object3D.call(this);
    this.light = a;
    this.light.updateMatrixWorld();
    this.matrixWorld = a.matrixWorld;
    this.matrixAutoUpdate = !1;
    a = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0);
    a.applyMatrix((new THREE.Matrix4).makeTranslation(0, -0.5, 0));
    a.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
    var b = new THREE.MeshBasicMaterial({
        wireframe: !0,
        fog: !1
    });
    this.cone = new THREE.Mesh(a, b);
    this.add(this.cone);
    this.update()
};
THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.SpotLightHelper.prototype.dispose = function () {
    this.cone.geometry.dispose();
    this.cone.material.dispose()
};
THREE.SpotLightHelper.prototype.update = function () {
    var a = new THREE.Vector3,
        b = new THREE.Vector3;
    return function () {
        var c = this.light.distance ? this.light.distance : 1E4,
            e = c * Math.tan(this.light.angle);
        this.cone.scale.set(e, e, c);
        a.setFromMatrixPosition(this.light.matrixWorld);
        b.setFromMatrixPosition(this.light.target.matrixWorld);
        this.cone.lookAt(b.sub(a));
        this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
    }
}();
THREE.VertexNormalsHelper = function (a, b, c, e) {
    this.object = a;
    this.size = void 0 !== b ? b : 1;
    b = void 0 !== c ? c : 16711680;
    e = void 0 !== e ? e : 1;
    c = new THREE.Geometry;
    a = a.geometry.faces;
    for (var d = 0, g = a.length; d < g; d++)
        for (var f = 0, k = a[d].vertexNormals.length; f < k; f++) c.vertices.push(new THREE.Vector3), c.vertices.push(new THREE.Vector3);
    THREE.Line.call(this, c, new THREE.LineBasicMaterial({
        color: b,
        linewidth: e
    }), THREE.LinePieces);
    this.matrixAutoUpdate = !1;
    this.normalMatrix = new THREE.Matrix3;
    this.update()
};
THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.VertexNormalsHelper.prototype.update = function (a) {
    var b = new THREE.Vector3;
    return function (a) {
        a = ["a", "b", "c", "d"];
        this.object.updateMatrixWorld(!0);
        this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
        for (var e = this.geometry.vertices, d = this.object.geometry.vertices, g = this.object.geometry.faces, f = this.object.matrixWorld, k = 0, h = 0, l = g.length; h < l; h++)
            for (var m = g[h], n = 0, r = m.vertexNormals.length; n < r; n++) {
                var s = m.vertexNormals[n];
                e[k].copy(d[m[a[n]]]).applyMatrix4(f);
                b.copy(s).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
                b.add(e[k]);
                k += 1;
                e[k].copy(b);
                k += 1
            }
        this.geometry.verticesNeedUpdate = !0;
        return this
    }
}();
THREE.VertexTangentsHelper = function (a, b, c, e) {
    this.object = a;
    this.size = void 0 !== b ? b : 1;
    b = void 0 !== c ? c : 255;
    e = void 0 !== e ? e : 1;
    c = new THREE.Geometry;
    a = a.geometry.faces;
    for (var d = 0, g = a.length; d < g; d++)
        for (var f = 0, k = a[d].vertexTangents.length; f < k; f++) c.vertices.push(new THREE.Vector3), c.vertices.push(new THREE.Vector3);
    THREE.Line.call(this, c, new THREE.LineBasicMaterial({
        color: b,
        linewidth: e
    }), THREE.LinePieces);
    this.matrixAutoUpdate = !1;
    this.update()
};
THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.VertexTangentsHelper.prototype.update = function (a) {
    var b = new THREE.Vector3;
    return function (a) {
        a = ["a", "b", "c", "d"];
        this.object.updateMatrixWorld(!0);
        for (var e = this.geometry.vertices, d = this.object.geometry.vertices, g = this.object.geometry.faces, f = this.object.matrixWorld, k = 0, h = 0, l = g.length; h < l; h++)
            for (var m = g[h], n = 0, r = m.vertexTangents.length; n < r; n++) {
                var s = m.vertexTangents[n];
                e[k].copy(d[m[a[n]]]).applyMatrix4(f);
                b.copy(s).transformDirection(f).multiplyScalar(this.size);
                b.add(e[k]);
                k += 1;
                e[k].copy(b);
                k += 1
            }
        this.geometry.verticesNeedUpdate = !0;
        return this
    }
}();
THREE.WireframeHelper = function (a, b) {
    var c = void 0 !== b ? b : 16777215,
        e = [0, 0],
        d = {},
        g = function (a, b) {
            return a - b
        },
        f = ["a", "b", "c"],
        k = new THREE.BufferGeometry;
    if (a.geometry instanceof THREE.Geometry) {
        for (var h = a.geometry.vertices, l = a.geometry.faces, m = 0, n = new Uint32Array(6 * l.length), r = 0, s = l.length; r < s; r++)
            for (var t = l[r], p = 0; 3 > p; p++) {
                e[0] = t[f[p]];
                e[1] = t[f[(p + 1) % 3]];
                e.sort(g);
                var u = e.toString();
                void 0 === d[u] && (n[2 * m] = e[0], n[2 * m + 1] = e[1], d[u] = !0, m++)
            }
        k.addAttribute("position", Float32Array, 2 * m, 3);
        e = k.attributes.position.array;
        r = 0;
        for (s = m; r < s; r++)
            for (p = 0; 2 > p; p++) m = h[n[2 * r + p]], f = 6 * r + 3 * p, e[f + 0] = m.x, e[f + 1] = m.y, e[f + 2] = m.z
    } else if (a.geometry instanceof THREE.BufferGeometry && void 0 !== a.geometry.attributes.index) {
        for (var h = a.geometry.attributes.position.array, s = a.geometry.attributes.index.array, l = a.geometry.offsets, m = 0, n = new Uint32Array(2 * s.length), t = 0, v = l.length; t < v; ++t)
            for (var p = l[t].start, u = l[t].count, f = l[t].index, r = p, w = p + u; r < w; r += 3)
                for (p = 0; 3 > p; p++) e[0] = f + s[r + p], e[1] = f + s[r + (p + 1) % 3], e.sort(g), u = e.toString(), void 0 === d[u] && (n[2 *
                    m] = e[0], n[2 * m + 1] = e[1], d[u] = !0, m++);
        k.addAttribute("position", Float32Array, 2 * m, 3);
        e = k.attributes.position.array;
        r = 0;
        for (s = m; r < s; r++)
            for (p = 0; 2 > p; p++) f = 6 * r + 3 * p, m = 3 * n[2 * r + p], e[f + 0] = h[m], e[f + 1] = h[m + 1], e[f + 2] = h[m + 2]
    } else if (a.geometry instanceof THREE.BufferGeometry)
        for (h = a.geometry.attributes.position.array, m = h.length / 3, n = m / 3, k.addAttribute("position", Float32Array, 2 * m, 3), e = k.attributes.position.array, r = 0, s = n; r < s; r++)
            for (p = 0; 3 > p; p++) f = 18 * r + 6 * p, n = 9 * r + 3 * p, e[f + 0] = h[n], e[f + 1] = h[n + 1], e[f + 2] = h[n + 2], m = 9 * r + (p +
                1) % 3 * 3, e[f + 3] = h[m], e[f + 4] = h[m + 1], e[f + 5] = h[m + 2];
    THREE.Line.call(this, k, new THREE.LineBasicMaterial({
        color: c
    }), THREE.LinePieces);
    this.matrixAutoUpdate = !1;
    this.matrixWorld = a.matrixWorld
};
THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype);
THREE.ShadowMapPlugin = function () {
    var a, b, c, e, d, g, f = new THREE.Frustum,
        k = new THREE.Matrix4,
        h = new THREE.Vector3,
        l = new THREE.Vector3,
        m = new THREE.Vector3;
    this.init = function (f) {
        a = f.context;
        b = f;
        f = THREE.ShaderLib.depthRGBA;
        var k = THREE.UniformsUtils.clone(f.uniforms);
        c = new THREE.ShaderMaterial({
            fragmentShader: f.fragmentShader,
            vertexShader: f.vertexShader,
            uniforms: k
        });
        e = new THREE.ShaderMaterial({
            fragmentShader: f.fragmentShader,
            vertexShader: f.vertexShader,
            uniforms: k,
            morphTargets: !0
        });
        d = new THREE.ShaderMaterial({
            fragmentShader: f.fragmentShader,
            vertexShader: f.vertexShader,
            uniforms: k,
            skinning: !0
        });
        g = new THREE.ShaderMaterial({
            fragmentShader: f.fragmentShader,
            vertexShader: f.vertexShader,
            uniforms: k,
            morphTargets: !0,
            skinning: !0
        });
        c._shadowPass = !0;
        e._shadowPass = !0;
        d._shadowPass = !0;
        g._shadowPass = !0
    };
    this.render = function (a, f) {
        b.shadowMapEnabled && b.shadowMapAutoUpdate && this.update(a, f)
    };
    this.update = function (n, r) {
        var s, t, p, u, v, w, y, x, A, N = [];
        u = 0;
        a.clearColor(1, 1, 1, 1);
        a.disable(a.BLEND);
        a.enable(a.CULL_FACE);
        a.frontFace(a.CCW);
        b.shadowMapCullFace === THREE.CullFaceFront ?
            a.cullFace(a.FRONT) : a.cullFace(a.BACK);
        b.setDepthTest(!0);
        s = 0;
        for (t = n.__lights.length; s < t; s++)
            if (p = n.__lights[s], p.castShadow)
                if (p instanceof THREE.DirectionalLight && p.shadowCascade)
                    for (v = 0; v < p.shadowCascadeCount; v++) {
                        var B;
                        if (p.shadowCascadeArray[v]) B = p.shadowCascadeArray[v];
                        else {
                            A = p;
                            y = v;
                            B = new THREE.DirectionalLight;
                            B.isVirtual = !0;
                            B.onlyShadow = !0;
                            B.castShadow = !0;
                            B.shadowCameraNear = A.shadowCameraNear;
                            B.shadowCameraFar = A.shadowCameraFar;
                            B.shadowCameraLeft = A.shadowCameraLeft;
                            B.shadowCameraRight = A.shadowCameraRight;
                            B.shadowCameraBottom = A.shadowCameraBottom;
                            B.shadowCameraTop = A.shadowCameraTop;
                            B.shadowCameraVisible = A.shadowCameraVisible;
                            B.shadowDarkness = A.shadowDarkness;
                            B.shadowBias = A.shadowCascadeBias[y];
                            B.shadowMapWidth = A.shadowCascadeWidth[y];
                            B.shadowMapHeight = A.shadowCascadeHeight[y];
                            B.pointsWorld = [];
                            B.pointsFrustum = [];
                            x = B.pointsWorld;
                            w = B.pointsFrustum;
                            for (var G = 0; 8 > G; G++) x[G] = new THREE.Vector3, w[G] = new THREE.Vector3;
                            x = A.shadowCascadeNearZ[y];
                            A = A.shadowCascadeFarZ[y];
                            w[0].set(-1, -1, x);
                            w[1].set(1, -1, x);
                            w[2].set(-1,
                                1, x);
                            w[3].set(1, 1, x);
                            w[4].set(-1, -1, A);
                            w[5].set(1, -1, A);
                            w[6].set(-1, 1, A);
                            w[7].set(1, 1, A);
                            B.originalCamera = r;
                            w = new THREE.Gyroscope;
                            w.position = p.shadowCascadeOffset;
                            w.add(B);
                            w.add(B.target);
                            r.add(w);
                            p.shadowCascadeArray[v] = B;
                            console.log("Created virtualLight", B)
                        }
                        y = p;
                        x = v;
                        A = y.shadowCascadeArray[x];
                        A.position.copy(y.position);
                        A.target.position.copy(y.target.position);
                        A.lookAt(A.target);
                        A.shadowCameraVisible = y.shadowCameraVisible;
                        A.shadowDarkness = y.shadowDarkness;
                        A.shadowBias = y.shadowCascadeBias[x];
                        w = y.shadowCascadeNearZ[x];
                        y = y.shadowCascadeFarZ[x];
                        A = A.pointsFrustum;
                        A[0].z = w;
                        A[1].z = w;
                        A[2].z = w;
                        A[3].z = w;
                        A[4].z = y;
                        A[5].z = y;
                        A[6].z = y;
                        A[7].z = y;
                        N[u] = B;
                        u++
                    } else N[u] = p, u++;
        s = 0;
        for (t = N.length; s < t; s++) {
            p = N[s];
            p.shadowMap || (v = THREE.LinearFilter, b.shadowMapType === THREE.PCFSoftShadowMap && (v = THREE.NearestFilter), p.shadowMap = new THREE.WebGLRenderTarget(p.shadowMapWidth, p.shadowMapHeight, {
                minFilter: v,
                magFilter: v,
                format: THREE.RGBAFormat
            }), p.shadowMapSize = new THREE.Vector2(p.shadowMapWidth, p.shadowMapHeight), p.shadowMatrix = new THREE.Matrix4);
            if (!p.shadowCamera) {
                if (p instanceof THREE.SpotLight) p.shadowCamera = new THREE.PerspectiveCamera(p.shadowCameraFov, p.shadowMapWidth / p.shadowMapHeight, p.shadowCameraNear, p.shadowCameraFar);
                else if (p instanceof THREE.DirectionalLight) p.shadowCamera = new THREE.OrthographicCamera(p.shadowCameraLeft, p.shadowCameraRight, p.shadowCameraTop, p.shadowCameraBottom, p.shadowCameraNear, p.shadowCameraFar);
                else {
                    console.error("Unsupported light type for shadow");
                    continue
                }
                n.add(p.shadowCamera);
                !0 === n.autoUpdate && n.updateMatrixWorld()
            }
            p.shadowCameraVisible &&
                !p.cameraHelper && (p.cameraHelper = new THREE.CameraHelper(p.shadowCamera), p.shadowCamera.add(p.cameraHelper));
            if (p.isVirtual && B.originalCamera == r) {
                v = r;
                u = p.shadowCamera;
                w = p.pointsFrustum;
                A = p.pointsWorld;
                h.set(Infinity, Infinity, Infinity);
                l.set(-Infinity, -Infinity, -Infinity);
                for (y = 0; 8 > y; y++) x = A[y], x.copy(w[y]), THREE.ShadowMapPlugin.__projector.unprojectVector(x, v), x.applyMatrix4(u.matrixWorldInverse), x.x < h.x && (h.x = x.x), x.x > l.x && (l.x = x.x), x.y < h.y && (h.y = x.y), x.y > l.y && (l.y = x.y), x.z < h.z && (h.z = x.z), x.z > l.z &&
                    (l.z = x.z);
                u.left = h.x;
                u.right = l.x;
                u.top = l.y;
                u.bottom = h.y;
                u.updateProjectionMatrix()
            }
            u = p.shadowMap;
            w = p.shadowMatrix;
            v = p.shadowCamera;
            v.position.setFromMatrixPosition(p.matrixWorld);
            m.setFromMatrixPosition(p.target.matrixWorld);
            v.lookAt(m);
            v.updateMatrixWorld();
            v.matrixWorldInverse.getInverse(v.matrixWorld);
            p.cameraHelper && (p.cameraHelper.visible = p.shadowCameraVisible);
            p.shadowCameraVisible && p.cameraHelper.update();
            w.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
            w.multiply(v.projectionMatrix);
            w.multiply(v.matrixWorldInverse);
            k.multiplyMatrices(v.projectionMatrix, v.matrixWorldInverse);
            f.setFromMatrix(k);
            b.setRenderTarget(u);
            b.clear();
            A = n.__webglObjects;
            p = 0;
            for (u = A.length; p < u; p++) y = A[p], w = y.object, y.render = !1, !w.visible || !w.castShadow || (w instanceof THREE.Mesh || w instanceof THREE.ParticleSystem) && w.frustumCulled && !f.intersectsObject(w) || (w._modelViewMatrix.multiplyMatrices(v.matrixWorldInverse, w.matrixWorld), y.render = !0);
            p = 0;
            for (u = A.length; p < u; p++) y = A[p], y.render && (w = y.object, y = y.buffer, G = w.material instanceof THREE.MeshFaceMaterial ?
                w.material.materials[0] : w.material, x = void 0 !== w.geometry.morphTargets && 0 < w.geometry.morphTargets.length && G.morphTargets, G = w instanceof THREE.SkinnedMesh && G.skinning, x = w.customDepthMaterial ? w.customDepthMaterial : G ? x ? g : d : x ? e : c, y instanceof THREE.BufferGeometry ? b.renderBufferDirect(v, n.__lights, null, x, y, w) : b.renderBuffer(v, n.__lights, null, x, y, w));
            A = n.__webglObjectsImmediate;
            p = 0;
            for (u = A.length; p < u; p++) y = A[p], w = y.object, w.visible && w.castShadow && (w._modelViewMatrix.multiplyMatrices(v.matrixWorldInverse,
                w.matrixWorld), b.renderImmediateObject(v, n.__lights, null, c, w))
        }
        s = b.getClearColor();
        t = b.getClearAlpha();
        a.clearColor(s.r, s.g, s.b, t);
        a.enable(a.BLEND);
        b.shadowMapCullFace === THREE.CullFaceFront && a.cullFace(a.BACK)
    }
};
THREE.ShadowMapPlugin.__projector = new THREE.Projector;
THREE.DepthPassPlugin = function () {
    this.enabled = !1;
    this.renderTarget = null;
    var a, b, c, e, d, g, f = new THREE.Frustum,
        k = new THREE.Matrix4;
    this.init = function (f) {
        a = f.context;
        b = f;
        f = THREE.ShaderLib.depthRGBA;
        var k = THREE.UniformsUtils.clone(f.uniforms);
        c = new THREE.ShaderMaterial({
            fragmentShader: f.fragmentShader,
            vertexShader: f.vertexShader,
            uniforms: k
        });
        e = new THREE.ShaderMaterial({
            fragmentShader: f.fragmentShader,
            vertexShader: f.vertexShader,
            uniforms: k,
            morphTargets: !0
        });
        d = new THREE.ShaderMaterial({
            fragmentShader: f.fragmentShader,
            vertexShader: f.vertexShader,
            uniforms: k,
            skinning: !0
        });
        g = new THREE.ShaderMaterial({
            fragmentShader: f.fragmentShader,
            vertexShader: f.vertexShader,
            uniforms: k,
            morphTargets: !0,
            skinning: !0
        });
        c._shadowPass = !0;
        e._shadowPass = !0;
        d._shadowPass = !0;
        g._shadowPass = !0
    };
    this.render = function (a, b) {
        this.enabled && this.update(a, b)
    };
    this.update = function (h, l) {
        var m, n, r, s, t, p;
        a.clearColor(1, 1, 1, 1);
        a.disable(a.BLEND);
        b.setDepthTest(!0);
        !0 === h.autoUpdate && h.updateMatrixWorld();
        l.matrixWorldInverse.getInverse(l.matrixWorld);
        k.multiplyMatrices(l.projectionMatrix,
            l.matrixWorldInverse);
        f.setFromMatrix(k);
        b.setRenderTarget(this.renderTarget);
        b.clear();
        p = h.__webglObjects;
        m = 0;
        for (n = p.length; m < n; m++) r = p[m], t = r.object, r.render = !1, !t.visible || (t instanceof THREE.Mesh || t instanceof THREE.ParticleSystem) && t.frustumCulled && !f.intersectsObject(t) || (t._modelViewMatrix.multiplyMatrices(l.matrixWorldInverse, t.matrixWorld), r.render = !0);
        var u;
        m = 0;
        for (n = p.length; m < n; m++) r = p[m], r.render && (t = r.object, r = r.buffer, t instanceof THREE.ParticleSystem && !t.customDepthMaterial || ((u =
            t.material instanceof THREE.MeshFaceMaterial ? t.material.materials[0] : t.material) && b.setMaterialFaces(t.material), s = 0 < t.geometry.morphTargets.length && u.morphTargets, u = t instanceof THREE.SkinnedMesh && u.skinning, s = t.customDepthMaterial ? t.customDepthMaterial : u ? s ? g : d : s ? e : c, r instanceof THREE.BufferGeometry ? b.renderBufferDirect(l, h.__lights, null, s, r, t) : b.renderBuffer(l, h.__lights, null, s, r, t)));
        p = h.__webglObjectsImmediate;
        m = 0;
        for (n = p.length; m < n; m++) r = p[m], t = r.object, t.visible && (t._modelViewMatrix.multiplyMatrices(l.matrixWorldInverse,
            t.matrixWorld), b.renderImmediateObject(l, h.__lights, null, c, t));
        m = b.getClearColor();
        n = b.getClearAlpha();
        a.clearColor(m.r, m.g, m.b, n);
        a.enable(a.BLEND)
    }
};
/*
 zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
(function () {
    function a(a) {
        throw a;
    }

    function b(a, b) {
        var f = a.split("."),
            c = p;
        f[0] in c || !c.execScript || c.execScript("var " + f[0]);
        for (var d; f.length && (d = f.shift());) f.length || b === s ? c = c[d] ? c[d] : c[d] = {} : c[d] = b
    }

    function c(a) {
        var b = a.length,
            f = 0,
            c = Number.POSITIVE_INFINITY,
            d, k, e, h, g, l, m, n, r;
        for (n = 0; n < b; ++n) a[n] > f && (f = a[n]), a[n] < c && (c = a[n]);
        d = 1 << f;
        k = new(u ? Uint32Array : Array)(d);
        e = 1;
        h = 0;
        for (g = 2; e <= f;) {
            for (n = 0; n < b; ++n)
                if (a[n] === e) {
                    l = 0;
                    m = h;
                    for (r = 0; r < e; ++r) l = l << 1 | m & 1, m >>= 1;
                    for (r = l; r < d; r += g) k[r] = e << 16 | n;
                    ++h
                }++e;
            h <<=
                1;
            g <<= 1
        }
        return [k, f, c]
    }

    function e(b, f) {
        this.l = [];
        this.m = 32768;
        this.d = this.f = this.c = this.t = 0;
        this.input = u ? new Uint8Array(b) : b;
        this.u = !1;
        this.n = A;
        this.K = !1;
        if (f || !(f = {})) f.index && (this.c = f.index), f.bufferSize && (this.m = f.bufferSize), f.bufferType && (this.n = f.bufferType), f.resize && (this.K = f.resize);
        switch (this.n) {
        case x:
            this.a = 32768;
            this.b = new(u ? Uint8Array : Array)(32768 + this.m + 258);
            break;
        case A:
            this.a = 0;
            this.b = new(u ? Uint8Array : Array)(this.m);
            this.e = this.W;
            this.B = this.R;
            this.q = this.V;
            break;
        default:
            a(Error("invalid inflate mode"))
        }
    }

    function d(b, f) {
        for (var c = b.f, d = b.d, k = b.input, e = b.c, h; d < f;) h = k[e++], h === s && a(Error("input buffer is broken")), c |= h << d, d += 8;
        b.f = c >>> f;
        b.d = d - f;
        b.c = e;
        return c & (1 << f) - 1
    }

    function g(a, b) {
        for (var f = a.f, c = a.d, d = a.input, k = a.c, e = b[0], h = b[1], g; c < h;) {
            g = d[k++];
            if (g === s) break;
            f |= g << c;
            c += 8
        }
        d = e[f & (1 << h) - 1];
        e = d >>> 16;
        a.f = f >> e;
        a.d = c - e;
        a.c = k;
        return d & 65535
    }

    function f(a) {
        function b(a, f, c) {
            var k, e, h, l;
            for (l = 0; l < a;) switch (k = g(this, f), k) {
            case 16:
                for (h = 3 + d(this, 2); h--;) c[l++] = e;
                break;
            case 17:
                for (h = 3 + d(this, 3); h--;) c[l++] =
                    0;
                e = 0;
                break;
            case 18:
                for (h = 11 + d(this, 7); h--;) c[l++] = 0;
                e = 0;
                break;
            default:
                e = c[l++] = k
            }
            return c
        }
        var f = d(a, 5) + 257,
            k = d(a, 5) + 1,
            e = d(a, 4) + 4,
            h = new(u ? Uint8Array : Array)(N.length),
            l;
        for (l = 0; l < e; ++l) h[N[l]] = d(a, 3);
        e = c(h);
        h = new(u ? Uint8Array : Array)(f);
        l = new(u ? Uint8Array : Array)(k);
        a.q(c(b.call(a, f, e, h)), c(b.call(a, k, e, l)))
    }

    function k(a) {
        a = a || {};
        this.files = [];
        this.v = a.comment
    }

    function h(a, b) {
        b = b || {};
        this.input = u && a instanceof Array ? new Uint8Array(a) : a;
        this.c = 0;
        this.ba = b.verify || !1;
        this.j = b.password
    }

    function l(a,
        b) {
        this.input = a;
        this.offset = b
    }

    function m(a, b) {
        this.input = a;
        this.offset = b
    }

    function n(b) {
        var f = [],
            c = {},
            d, k, e, h;
        if (!b.i) {
            if (b.o === s) {
                d = b.input;
                if (!b.D) a: {
                    k = b.input;
                    for (e = k.length - 12; 0 < e; --e)
                        if (k[e] === T[0] && k[e + 1] === T[1] && k[e + 2] === T[2] && k[e + 3] === T[3]) {
                            b.D = e;
                            break a
                        }
                    a(Error("End of Central Directory Record not found"))
                }
                k = b.D;
                d[k++] === T[0] && d[k++] === T[1] && d[k++] === T[2] && d[k++] === T[3] || a(Error("invalid signature"));
                b.ha = d[k++] | d[k++] << 8;
                b.ja = d[k++] | d[k++] << 8;
                b.ka = d[k++] | d[k++] << 8;
                b.aa = d[k++] | d[k++] << 8;
                b.Q =
                    (d[k++] | d[k++] << 8 | d[k++] << 16 | d[k++] << 24) >>> 0;
                b.o = (d[k++] | d[k++] << 8 | d[k++] << 16 | d[k++] << 24) >>> 0;
                b.w = d[k++] | d[k++] << 8;
                b.v = u ? d.subarray(k, k + b.w) : d.slice(k, k + b.w)
            }
            d = b.o;
            e = 0;
            for (h = b.aa; e < h; ++e) k = new l(b.input, d), k.parse(), d += k.length, f[e] = k, c[k.filename] = e;
            b.Q < d - b.o && a(Error("invalid file header size"));
            b.i = f;
            b.G = c
        }
    }

    function r(a, b, f) {
        f ^= a.s(b);
        a.k(b, f);
        return f
    }
    var s = void 0,
        t, p = this,
        u = "undefined" !== typeof Uint8Array && "undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array;
    new(u ? Uint8Array : Array)(256);
    for (t = 0; 256 > t; ++t)
        for (var v = t, w = 7, v = v >>> 1; v; v >>>= 1)--w;
    t = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684,
        3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902,
        314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523,
        3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233,
        1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263,
        1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918E3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117
    ];
    var y = u ? new Uint32Array(t) : t;
    t = [];
    for (v = 0; 288 > v; v++) switch (!0) {
    case 143 >= v:
        t.push([v + 48, 8]);
        break;
    case 255 >= v:
        t.push([v - 144 + 400, 9]);
        break;
    case 279 >= v:
        t.push([v - 256 + 0, 7]);
        break;
    case 287 >= v:
        t.push([v - 280 + 192, 8]);
        break;
    default:
        a("invalid literal: " +
            v)
    }
    t = function () {
        function b(f) {
            switch (!0) {
            case 3 === f:
                return [257, f - 3, 0];
            case 4 === f:
                return [258, f - 4, 0];
            case 5 === f:
                return [259, f - 5, 0];
            case 6 === f:
                return [260, f - 6, 0];
            case 7 === f:
                return [261, f - 7, 0];
            case 8 === f:
                return [262, f - 8, 0];
            case 9 === f:
                return [263, f - 9, 0];
            case 10 === f:
                return [264, f - 10, 0];
            case 12 >= f:
                return [265, f - 11, 1];
            case 14 >= f:
                return [266, f - 13, 1];
            case 16 >= f:
                return [267, f - 15, 1];
            case 18 >= f:
                return [268, f - 17, 1];
            case 22 >= f:
                return [269, f - 19, 2];
            case 26 >= f:
                return [270, f - 23, 2];
            case 30 >= f:
                return [271, f - 27, 2];
            case 34 >= f:
                return [272,
                    f - 31, 2
                ];
            case 42 >= f:
                return [273, f - 35, 3];
            case 50 >= f:
                return [274, f - 43, 3];
            case 58 >= f:
                return [275, f - 51, 3];
            case 66 >= f:
                return [276, f - 59, 3];
            case 82 >= f:
                return [277, f - 67, 4];
            case 98 >= f:
                return [278, f - 83, 4];
            case 114 >= f:
                return [279, f - 99, 4];
            case 130 >= f:
                return [280, f - 115, 4];
            case 162 >= f:
                return [281, f - 131, 5];
            case 194 >= f:
                return [282, f - 163, 5];
            case 226 >= f:
                return [283, f - 195, 5];
            case 257 >= f:
                return [284, f - 227, 5];
            case 258 === f:
                return [285, f - 258, 0];
            default:
                a("invalid length: " + f)
            }
        }
        var f = [],
            c, d;
        for (c = 3; 258 >= c; c++) d = b(c), f[c] = d[2] << 24 | d[1] <<
            16 | d[0];
        return f
    }();
    u && new Uint32Array(t);
    var x = 0,
        A = 1;
    e.prototype.r = function () {
        for (; !this.u;) {
            var b = d(this, 3);
            b & 1 && (this.u = !0);
            b >>>= 1;
            switch (b) {
            case 0:
                var b = this.input,
                    c = this.c,
                    k = this.b,
                    e = this.a,
                    h = s,
                    g = s,
                    l = s,
                    m = k.length,
                    h = s;
                this.d = this.f = 0;
                h = b[c++];
                h === s && a(Error("invalid uncompressed block header: LEN (first byte)"));
                g = h;
                h = b[c++];
                h === s && a(Error("invalid uncompressed block header: LEN (second byte)"));
                g |= h << 8;
                h = b[c++];
                h === s && a(Error("invalid uncompressed block header: NLEN (first byte)"));
                l = h;
                h = b[c++];
                h === s && a(Error("invalid uncompressed block header: NLEN (second byte)"));
                l |= h << 8;
                g === ~l && a(Error("invalid uncompressed block header: length verify"));
                c + g > b.length && a(Error("input buffer is broken"));
                switch (this.n) {
                case x:
                    for (; e + g > k.length;) {
                        h = m - e;
                        g -= h;
                        if (u) k.set(b.subarray(c, c + h), e), e += h, c += h;
                        else
                            for (; h--;) k[e++] = b[c++];
                        this.a = e;
                        k = this.e();
                        e = this.a
                    }
                    break;
                case A:
                    for (; e + g > k.length;) k = this.e({
                        H: 2
                    });
                    break;
                default:
                    a(Error("invalid inflate mode"))
                }
                if (u) k.set(b.subarray(c, c + g), e), e += g, c += g;
                else
                    for (; g--;) k[e++] =
                        b[c++];
                this.c = c;
                this.a = e;
                this.b = k;
                break;
            case 1:
                this.q(z, Q);
                break;
            case 2:
                f(this);
                break;
            default:
                a(Error("unknown BTYPE: " + b))
            }
        }
        return this.B()
    };
    t = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var N = u ? new Uint16Array(t) : t;
    t = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258];
    var B = u ? new Uint16Array(t) : t;
    t = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
    var G = u ? new Uint8Array(t) : t;
    t = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513,
        769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577
    ];
    var C = u ? new Uint16Array(t) : t;
    t = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    var P = u ? new Uint8Array(t) : t;
    t = new(u ? Uint8Array : Array)(288);
    v = 0;
    for (w = t.length; v < w; ++v) t[v] = 143 >= v ? 8 : 255 >= v ? 9 : 279 >= v ? 7 : 8;
    var z = c(t);
    t = new(u ? Uint8Array : Array)(30);
    v = 0;
    for (w = t.length; v < w; ++v) t[v] = 5;
    var Q = c(t);
    t = e.prototype;
    t.q = function (a, b) {
        var f = this.b,
            c = this.a;
        this.C = a;
        for (var k = f.length - 258, e, h, l; 256 !== (e = g(this, a));)
            if (256 > e) c >= k && (this.a =
                c, f = this.e(), c = this.a), f[c++] = e;
            else
                for (e -= 257, l = B[e], 0 < G[e] && (l += d(this, G[e])), e = g(this, b), h = C[e], 0 < P[e] && (h += d(this, P[e])), c >= k && (this.a = c, f = this.e(), c = this.a); l--;) f[c] = f[c++-h];
        for (; 8 <= this.d;) this.d -= 8, this.c--;
        this.a = c
    };
    t.V = function (a, b) {
        var f = this.b,
            c = this.a;
        this.C = a;
        for (var k = f.length, e, h, l; 256 !== (e = g(this, a));)
            if (256 > e) c >= k && (f = this.e(), k = f.length), f[c++] = e;
            else
                for (e -= 257, l = B[e], 0 < G[e] && (l += d(this, G[e])), e = g(this, b), h = C[e], 0 < P[e] && (h += d(this, P[e])), c + l > k && (f = this.e(), k = f.length); l--;) f[c] =
                    f[c++-h];
        for (; 8 <= this.d;) this.d -= 8, this.c--;
        this.a = c
    };
    t.e = function () {
        var a = new(u ? Uint8Array : Array)(this.a - 32768),
            b = this.a - 32768,
            f, c, d = this.b;
        if (u) a.set(d.subarray(32768, a.length));
        else
            for (f = 0, c = a.length; f < c; ++f) a[f] = d[f + 32768];
        this.l.push(a);
        this.t += a.length;
        if (u) d.set(d.subarray(b, b + 32768));
        else
            for (f = 0; 32768 > f; ++f) d[f] = d[b + f];
        this.a = 32768;
        return d
    };
    t.W = function (a) {
        var b, f = this.input.length / this.c + 1 | 0,
            c, d, k, e = this.input,
            h = this.b;
        a && ("number" === typeof a.H && (f = a.H), "number" === typeof a.P && (f += a.P));
        2 > f ? (c = (e.length - this.c) / this.C[2], k = c / 2 * 258 | 0, d = k < h.length ? h.length + k : h.length << 1) : d = h.length * f;
        u ? (b = new Uint8Array(d), b.set(h)) : b = h;
        return this.b = b
    };
    t.B = function () {
        var a = 0,
            b = this.b,
            f = this.l,
            c, d = new(u ? Uint8Array : Array)(this.t + (this.a - 32768)),
            k, e, h, g;
        if (0 === f.length) return u ? this.b.subarray(32768, this.a) : this.b.slice(32768, this.a);
        k = 0;
        for (e = f.length; k < e; ++k)
            for (c = f[k], h = 0, g = c.length; h < g; ++h) d[a++] = c[h];
        k = 32768;
        for (e = this.a; k < e; ++k) d[a++] = b[k];
        this.l = [];
        return this.buffer = d
    };
    t.R = function () {
        var a,
            b = this.a;
        u ? this.K ? (a = new Uint8Array(b), a.set(this.b.subarray(0, b))) : a = this.b.subarray(0, b) : (this.b.length > b && (this.b.length = b), a = this.b);
        return this.buffer = a
    };
    k.prototype.L = function (a) {
        this.j = a
    };
    k.prototype.s = function (a) {
        a = a[2] & 65535 | 2;
        return a * (a ^ 1) >> 8 & 255
    };
    k.prototype.k = function (a, b) {
        a[0] = (y[(a[0] ^ b) & 255] ^ a[0] >>> 8) >>> 0;
        a[1] = (6681 * (20173 * (a[1] + (a[0] & 255)) >>> 0) >>> 0) + 1 >>> 0;
        a[2] = (y[(a[2] ^ a[1] >>> 24) & 255] ^ a[2] >>> 8) >>> 0
    };
    k.prototype.T = function (a) {
        var b = [305419896, 591751049, 878082192],
            f, c;
        u && (b = new Uint32Array(b));
        f = 0;
        for (c = a.length; f < c; ++f) this.k(b, a[f] & 255);
        return b
    };
    var F = [80, 75, 1, 2],
        O = [80, 75, 3, 4],
        T = [80, 75, 5, 6];
    l.prototype.parse = function () {
        var b = this.input,
            f = this.offset;
        b[f++] === F[0] && b[f++] === F[1] && b[f++] === F[2] && b[f++] === F[3] || a(Error("invalid file header signature"));
        this.version = b[f++];
        this.ia = b[f++];
        this.Z = b[f++] | b[f++] << 8;
        this.I = b[f++] | b[f++] << 8;
        this.A = b[f++] | b[f++] << 8;
        this.time = b[f++] | b[f++] << 8;
        this.U = b[f++] | b[f++] << 8;
        this.p = (b[f++] | b[f++] << 8 | b[f++] << 16 | b[f++] << 24) >>> 0;
        this.z = (b[f++] | b[f++] << 8 | b[f++] <<
            16 | b[f++] << 24) >>> 0;
        this.J = (b[f++] | b[f++] << 8 | b[f++] << 16 | b[f++] << 24) >>> 0;
        this.h = b[f++] | b[f++] << 8;
        this.g = b[f++] | b[f++] << 8;
        this.F = b[f++] | b[f++] << 8;
        this.ea = b[f++] | b[f++] << 8;
        this.ga = b[f++] | b[f++] << 8;
        this.fa = b[f++] | b[f++] << 8 | b[f++] << 16 | b[f++] << 24;
        this.$ = (b[f++] | b[f++] << 8 | b[f++] << 16 | b[f++] << 24) >>> 0;
        this.filename = String.fromCharCode.apply(null, u ? b.subarray(f, f += this.h) : b.slice(f, f += this.h));
        this.X = u ? b.subarray(f, f += this.g) : b.slice(f, f += this.g);
        this.v = u ? b.subarray(f, f + this.F) : b.slice(f, f + this.F);
        this.length =
            f - this.offset
    };
    m.prototype.parse = function () {
        var b = this.input,
            f = this.offset;
        b[f++] === O[0] && b[f++] === O[1] && b[f++] === O[2] && b[f++] === O[3] || a(Error("invalid local file header signature"));
        this.Z = b[f++] | b[f++] << 8;
        this.I = b[f++] | b[f++] << 8;
        this.A = b[f++] | b[f++] << 8;
        this.time = b[f++] | b[f++] << 8;
        this.U = b[f++] | b[f++] << 8;
        this.p = (b[f++] | b[f++] << 8 | b[f++] << 16 | b[f++] << 24) >>> 0;
        this.z = (b[f++] | b[f++] << 8 | b[f++] << 16 | b[f++] << 24) >>> 0;
        this.J = (b[f++] | b[f++] << 8 | b[f++] << 16 | b[f++] << 24) >>> 0;
        this.h = b[f++] | b[f++] << 8;
        this.g = b[f++] | b[f++] <<
            8;
        this.filename = String.fromCharCode.apply(null, u ? b.subarray(f, f += this.h) : b.slice(f, f += this.h));
        this.X = u ? b.subarray(f, f += this.g) : b.slice(f, f += this.g);
        this.length = f - this.offset
    };
    t = h.prototype;
    t.Y = function () {
        var a = [],
            f, b, c;
        this.i || n(this);
        c = this.i;
        f = 0;
        for (b = c.length; f < b; ++f) a[f] = c[f].filename;
        return a
    };
    t.r = function (f, b) {
        var c;
        this.G || n(this);
        c = this.G[f];
        c === s && a(Error(f + " not found"));
        var d;
        d = b || {};
        var k = this.input,
            h = this.i,
            g, l, p, t;
        h || n(this);
        h[c] === s && a(Error("wrong index"));
        h = h[c].$;
        c = new m(this.input,
            h);
        c.parse();
        h += c.length;
        g = c.z;
        if (0 !== (c.I & 1)) {
            d.password || this.j || a(Error("please set password"));
            d = this.S(d.password || this.j);
            p = h;
            for (t = h + 12; p < t; ++p) r(this, d, k[p]);
            h += 12;
            g -= 12;
            p = h;
            for (t = h + g; p < t; ++p) k[p] = r(this, d, k[p])
        }
        switch (c.A) {
        case 0:
            l = u ? this.input.subarray(h, h + g) : this.input.slice(h, h + g);
            break;
        case 8:
            l = (new e(this.input, {
                index: h,
                bufferSize: c.J
            })).r();
            break;
        default:
            a(Error("unknown compression type"))
        }
        if (this.ba) {
            k = s;
            g = "number" === typeof k ? k : k = 0;
            d = l.length;
            h = -1;
            for (g = d & 7; g--; ++k) h = h >>> 8 ^ y[(h ^ l[k]) &
                255];
            for (g = d >> 3; g--; k += 8) h = h >>> 8 ^ y[(h ^ l[k]) & 255], h = h >>> 8 ^ y[(h ^ l[k + 1]) & 255], h = h >>> 8 ^ y[(h ^ l[k + 2]) & 255], h = h >>> 8 ^ y[(h ^ l[k + 3]) & 255], h = h >>> 8 ^ y[(h ^ l[k + 4]) & 255], h = h >>> 8 ^ y[(h ^ l[k + 5]) & 255], h = h >>> 8 ^ y[(h ^ l[k + 6]) & 255], h = h >>> 8 ^ y[(h ^ l[k + 7]) & 255];
            k = (h ^ 4294967295) >>> 0;
            c.p !== k && a(Error("wrong crc: file=0x" + c.p.toString(16) + ", data=0x" + k.toString(16)))
        }
        return l
    };
    t.L = function (a) {
        this.j = a
    };
    t.k = k.prototype.k;
    t.S = k.prototype.T;
    t.s = k.prototype.s;
    b("Zlib.Unzip", h);
    b("Zlib.Unzip.prototype.decompress", h.prototype.r);
    b("Zlib.Unzip.prototype.getFilenames",
        h.prototype.Y);
    b("Zlib.Unzip.prototype.setPassword", h.prototype.L)
}).call(this);
/*
 zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
(function () {
    function a(a) {
        throw a;
    }

    function b(a, f) {
        var b = a.split("."),
            c = n;
        b[0] in c || !c.execScript || c.execScript("var " + b[0]);
        for (var d; b.length && (d = b.shift());) b.length || f === m ? c = c[d] ? c[d] : c[d] = {} : c[d] = f
    }

    function c(a, f, b) {
        var c = "number" === typeof f ? f : f = 0,
            d = "number" === typeof b ? b : a.length;
        b = -1;
        for (c = d & 7; c--; ++f) b = b >>> 8 ^ u[(b ^ a[f]) & 255];
        for (c = d >> 3; c--; f += 8) b = b >>> 8 ^ u[(b ^ a[f]) & 255], b = b >>> 8 ^ u[(b ^ a[f + 1]) & 255], b = b >>> 8 ^ u[(b ^ a[f + 2]) & 255], b = b >>> 8 ^ u[(b ^ a[f + 3]) & 255], b = b >>> 8 ^ u[(b ^ a[f + 4]) & 255], b = b >>> 8 ^ u[(b ^ a[f + 5]) &
            255], b = b >>> 8 ^ u[(b ^ a[f + 6]) & 255], b = b >>> 8 ^ u[(b ^ a[f + 7]) & 255];
        return (b ^ 4294967295) >>> 0
    }

    function e() {}

    function d(a) {
        var b = a.length,
            f = 0,
            c = Number.POSITIVE_INFINITY,
            d, k, e, h, g, l, m, n, p;
        for (n = 0; n < b; ++n) a[n] > f && (f = a[n]), a[n] < c && (c = a[n]);
        d = 1 << f;
        k = new(r ? Uint32Array : Array)(d);
        e = 1;
        h = 0;
        for (g = 2; e <= f;) {
            for (n = 0; n < b; ++n)
                if (a[n] === e) {
                    l = 0;
                    m = h;
                    for (p = 0; p < e; ++p) l = l << 1 | m & 1, m >>= 1;
                    for (p = l; p < d; p += g) k[p] = e << 16 | n;
                    ++h
                }++e;
            h <<= 1;
            g <<= 1
        }
        return [k, f, c]
    }

    function g(b, f) {
        this.i = [];
        this.j = 32768;
        this.d = this.f = this.c = this.n = 0;
        this.input = r ?
            new Uint8Array(b) : b;
        this.o = !1;
        this.k = w;
        this.w = !1;
        if (f || !(f = {})) f.index && (this.c = f.index), f.bufferSize && (this.j = f.bufferSize), f.bufferType && (this.k = f.bufferType), f.resize && (this.w = f.resize);
        switch (this.k) {
        case v:
            this.a = 32768;
            this.b = new(r ? Uint8Array : Array)(32768 + this.j + 258);
            break;
        case w:
            this.a = 0;
            this.b = new(r ? Uint8Array : Array)(this.j);
            this.e = this.D;
            this.q = this.A;
            this.l = this.C;
            break;
        default:
            a(Error("invalid inflate mode"))
        }
    }

    function f(f, b) {
        for (var c = f.f, d = f.d, k = f.input, e = f.c, h; d < b;) h = k[e++], h === m &&
            a(Error("input buffer is broken")), c |= h << d, d += 8;
        f.f = c >>> b;
        f.d = d - b;
        f.c = e;
        return c & (1 << b) - 1
    }

    function k(a, f) {
        for (var b = a.f, c = a.d, d = a.input, k = a.c, e = f[0], h = f[1], g; c < h;) {
            g = d[k++];
            if (g === m) break;
            b |= g << c;
            c += 8
        }
        d = e[b & (1 << h) - 1];
        e = d >>> 16;
        a.f = b >> e;
        a.d = c - e;
        a.c = k;
        return d & 65535
    }

    function h(a) {
        function b(a, c, d) {
            var e, h, g, l;
            for (l = 0; l < a;) switch (e = k(this, c), e) {
            case 16:
                for (g = 3 + f(this, 2); g--;) d[l++] = h;
                break;
            case 17:
                for (g = 3 + f(this, 3); g--;) d[l++] = 0;
                h = 0;
                break;
            case 18:
                for (g = 11 + f(this, 7); g--;) d[l++] = 0;
                h = 0;
                break;
            default:
                h = d[l++] =
                    e
            }
            return d
        }
        var c = f(a, 5) + 257,
            e = f(a, 5) + 1,
            h = f(a, 4) + 4,
            g = new(r ? Uint8Array : Array)(y.length),
            l;
        for (l = 0; l < h; ++l) g[y[l]] = f(a, 3);
        h = d(g);
        g = new(r ? Uint8Array : Array)(c);
        l = new(r ? Uint8Array : Array)(e);
        a.l(d(b.call(a, c, h, g)), d(b.call(a, e, h, l)))
    }

    function l(a) {
        this.input = a;
        this.c = 0;
        this.m = [];
        this.s = !1
    }
    var m = void 0,
        n = this,
        r = "undefined" !== typeof Uint8Array && "undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array;
    new(r ? Uint8Array : Array)(256);
    var s;
    for (s = 0; 256 > s; ++s)
        for (var t = s, p = 7, t = t >>> 1; t; t >>>= 1)--p;
    s = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665,
        651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323,
        4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013,
        167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591,
        3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918E3,
        2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117
    ];
    var u = r ? new Uint32Array(s) : s;
    e.prototype.getName = function () {
        return this.name
    };
    e.prototype.getData = function () {
        return this.data
    };
    e.prototype.G = function () {
        return this.H
    };
    b("Zlib.GunzipMember", e);
    b("Zlib.GunzipMember.prototype.getName", e.prototype.getName);
    b("Zlib.GunzipMember.prototype.getData",
        e.prototype.getData);
    b("Zlib.GunzipMember.prototype.getMtime", e.prototype.G);
    s = [];
    for (t = 0; 288 > t; t++) switch (!0) {
    case 143 >= t:
        s.push([t + 48, 8]);
        break;
    case 255 >= t:
        s.push([t - 144 + 400, 9]);
        break;
    case 279 >= t:
        s.push([t - 256 + 0, 7]);
        break;
    case 287 >= t:
        s.push([t - 280 + 192, 8]);
        break;
    default:
        a("invalid literal: " + t)
    }
    s = function () {
        function f(b) {
            switch (!0) {
            case 3 === b:
                return [257, b - 3, 0];
            case 4 === b:
                return [258, b - 4, 0];
            case 5 === b:
                return [259, b - 5, 0];
            case 6 === b:
                return [260, b - 6, 0];
            case 7 === b:
                return [261, b - 7, 0];
            case 8 === b:
                return [262,
                    b - 8, 0
                ];
            case 9 === b:
                return [263, b - 9, 0];
            case 10 === b:
                return [264, b - 10, 0];
            case 12 >= b:
                return [265, b - 11, 1];
            case 14 >= b:
                return [266, b - 13, 1];
            case 16 >= b:
                return [267, b - 15, 1];
            case 18 >= b:
                return [268, b - 17, 1];
            case 22 >= b:
                return [269, b - 19, 2];
            case 26 >= b:
                return [270, b - 23, 2];
            case 30 >= b:
                return [271, b - 27, 2];
            case 34 >= b:
                return [272, b - 31, 2];
            case 42 >= b:
                return [273, b - 35, 3];
            case 50 >= b:
                return [274, b - 43, 3];
            case 58 >= b:
                return [275, b - 51, 3];
            case 66 >= b:
                return [276, b - 59, 3];
            case 82 >= b:
                return [277, b - 67, 4];
            case 98 >= b:
                return [278, b - 83, 4];
            case 114 >= b:
                return [279,
                    b - 99, 4
                ];
            case 130 >= b:
                return [280, b - 115, 4];
            case 162 >= b:
                return [281, b - 131, 5];
            case 194 >= b:
                return [282, b - 163, 5];
            case 226 >= b:
                return [283, b - 195, 5];
            case 257 >= b:
                return [284, b - 227, 5];
            case 258 === b:
                return [285, b - 258, 0];
            default:
                a("invalid length: " + b)
            }
        }
        var b = [],
            c, d;
        for (c = 3; 258 >= c; c++) d = f(c), b[c] = d[2] << 24 | d[1] << 16 | d[0];
        return b
    }();
    r && new Uint32Array(s);
    var v = 0,
        w = 1;
    g.prototype.g = function () {
        for (; !this.o;) {
            var b = f(this, 3);
            b & 1 && (this.o = !0);
            b >>>= 1;
            switch (b) {
            case 0:
                var b = this.input,
                    c = this.c,
                    d = this.b,
                    k = this.a,
                    e = m,
                    g = m,
                    l = m,
                    n =
                    d.length,
                    e = m;
                this.d = this.f = 0;
                e = b[c++];
                e === m && a(Error("invalid uncompressed block header: LEN (first byte)"));
                g = e;
                e = b[c++];
                e === m && a(Error("invalid uncompressed block header: LEN (second byte)"));
                g |= e << 8;
                e = b[c++];
                e === m && a(Error("invalid uncompressed block header: NLEN (first byte)"));
                l = e;
                e = b[c++];
                e === m && a(Error("invalid uncompressed block header: NLEN (second byte)"));
                l |= e << 8;
                g === ~l && a(Error("invalid uncompressed block header: length verify"));
                c + g > b.length && a(Error("input buffer is broken"));
                switch (this.k) {
                case v:
                    for (; k +
                        g > d.length;) {
                        e = n - k;
                        g -= e;
                        if (r) d.set(b.subarray(c, c + e), k), k += e, c += e;
                        else
                            for (; e--;) d[k++] = b[c++];
                        this.a = k;
                        d = this.e();
                        k = this.a
                    }
                    break;
                case w:
                    for (; k + g > d.length;) d = this.e({
                        t: 2
                    });
                    break;
                default:
                    a(Error("invalid inflate mode"))
                }
                if (r) d.set(b.subarray(c, c + g), k), k += g, c += g;
                else
                    for (; g--;) d[k++] = b[c++];
                this.c = c;
                this.a = k;
                this.b = d;
                break;
            case 1:
                this.l(G, C);
                break;
            case 2:
                h(this);
                break;
            default:
                a(Error("unknown BTYPE: " + b))
            }
        }
        return this.q()
    };
    s = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var y = r ? new Uint16Array(s) :
        s;
    s = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258];
    var x = r ? new Uint16Array(s) : s;
    s = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
    var A = r ? new Uint8Array(s) : s;
    s = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
    var N = r ? new Uint16Array(s) : s;
    s = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    var B = r ? new Uint8Array(s) : s;
    s = new(r ? Uint8Array : Array)(288);
    t =
        0;
    for (p = s.length; t < p; ++t) s[t] = 143 >= t ? 8 : 255 >= t ? 9 : 279 >= t ? 7 : 8;
    var G = d(s);
    s = new(r ? Uint8Array : Array)(30);
    t = 0;
    for (p = s.length; t < p; ++t) s[t] = 5;
    var C = d(s);
    g.prototype.l = function (a, b) {
        var c = this.b,
            d = this.a;
        this.r = a;
        for (var e = c.length - 258, h, g, l; 256 !== (h = k(this, a));)
            if (256 > h) d >= e && (this.a = d, c = this.e(), d = this.a), c[d++] = h;
            else
                for (h -= 257, l = x[h], 0 < A[h] && (l += f(this, A[h])), h = k(this, b), g = N[h], 0 < B[h] && (g += f(this, B[h])), d >= e && (this.a = d, c = this.e(), d = this.a); l--;) c[d] = c[d++-g];
        for (; 8 <= this.d;) this.d -= 8, this.c--;
        this.a =
            d
    };
    g.prototype.C = function (a, b) {
        var c = this.b,
            d = this.a;
        this.r = a;
        for (var e = c.length, h, g, l; 256 !== (h = k(this, a));)
            if (256 > h) d >= e && (c = this.e(), e = c.length), c[d++] = h;
            else
                for (h -= 257, l = x[h], 0 < A[h] && (l += f(this, A[h])), h = k(this, b), g = N[h], 0 < B[h] && (g += f(this, B[h])), d + l > e && (c = this.e(), e = c.length); l--;) c[d] = c[d++-g];
        for (; 8 <= this.d;) this.d -= 8, this.c--;
        this.a = d
    };
    g.prototype.e = function () {
        var a = new(r ? Uint8Array : Array)(this.a - 32768),
            b = this.a - 32768,
            f, c, d = this.b;
        if (r) a.set(d.subarray(32768, a.length));
        else
            for (f = 0, c = a.length; f <
                c; ++f) a[f] = d[f + 32768];
        this.i.push(a);
        this.n += a.length;
        if (r) d.set(d.subarray(b, b + 32768));
        else
            for (f = 0; 32768 > f; ++f) d[f] = d[b + f];
        this.a = 32768;
        return d
    };
    g.prototype.D = function (a) {
        var b, f = this.input.length / this.c + 1 | 0,
            c, d, k, e = this.input,
            h = this.b;
        a && ("number" === typeof a.t && (f = a.t), "number" === typeof a.z && (f += a.z));
        2 > f ? (c = (e.length - this.c) / this.r[2], k = c / 2 * 258 | 0, d = k < h.length ? h.length + k : h.length << 1) : d = h.length * f;
        r ? (b = new Uint8Array(d), b.set(h)) : b = h;
        return this.b = b
    };
    g.prototype.q = function () {
        var a = 0,
            b = this.b,
            f =
            this.i,
            c, d = new(r ? Uint8Array : Array)(this.n + (this.a - 32768)),
            k, e, h, g;
        if (0 === f.length) return r ? this.b.subarray(32768, this.a) : this.b.slice(32768, this.a);
        k = 0;
        for (e = f.length; k < e; ++k)
            for (c = f[k], h = 0, g = c.length; h < g; ++h) d[a++] = c[h];
        k = 32768;
        for (e = this.a; k < e; ++k) d[a++] = b[k];
        this.i = [];
        return this.buffer = d
    };
    g.prototype.A = function () {
        var a, b = this.a;
        r ? this.w ? (a = new Uint8Array(b), a.set(this.b.subarray(0, b))) : a = this.b.subarray(0, b) : (this.b.length > b && (this.b.length = b), a = this.b);
        return this.buffer = a
    };
    l.prototype.F = function () {
        this.s ||
            this.g();
        return this.m.slice()
    };
    l.prototype.g = function () {
        for (var b = this.input.length; this.c < b;) {
            var f = new e,
                d = m,
                k = m,
                h = m,
                l = d = h = m,
                n = m,
                d = d = m,
                p = this.input,
                k = this.c;
            f.u = p[k++];
            f.v = p[k++];
            31 === f.u && 139 === f.v || a(Error("invalid file signature:" + f.u + "," + f.v));
            f.p = p[k++];
            switch (f.p) {
            case 8:
                break;
            default:
                a(Error("unknown compression method: " + f.p))
            }
            f.h = p[k++];
            d = p[k++] | p[k++] << 8 | p[k++] << 16 | p[k++] << 24;
            f.H = new Date(1E3 * d);
            f.N = p[k++];
            f.M = p[k++];
            0 < (f.h & 4) && (f.I = p[k++] | p[k++] << 8, k += f.I);
            if (0 < (f.h & 8)) {
                n = [];
                for (l = 0; 0 <
                    (d = p[k++]);) n[l++] = String.fromCharCode(d);
                f.name = n.join("")
            }
            if (0 < (f.h & 16)) {
                n = [];
                for (l = 0; 0 < (d = p[k++]);) n[l++] = String.fromCharCode(d);
                f.J = n.join("")
            }
            0 < (f.h & 2) && (f.B = c(p, 0, k) & 65535, f.B !== (p[k++] | p[k++] << 8) && a(Error("invalid header crc16")));
            d = p[p.length - 4] | p[p.length - 3] << 8 | p[p.length - 2] << 16 | p[p.length - 1] << 24;
            p.length - k - 4 - 4 < 512 * d && (h = d);
            k = new g(p, {
                index: k,
                bufferSize: h
            });
            f.data = h = k.g();
            k = k.c;
            f.K = d = (p[k++] | p[k++] << 8 | p[k++] << 16 | p[k++] << 24) >>> 0;
            c(h, m, m) !== d && a(Error("invalid CRC-32 checksum: 0x" + c(h, m, m).toString(16) +
                " / 0x" + d.toString(16)));
            f.L = d = (p[k++] | p[k++] << 8 | p[k++] << 16 | p[k++] << 24) >>> 0;
            (h.length & 4294967295) !== d && a(Error("invalid input size: " + (h.length & 4294967295) + " / " + d));
            this.m.push(f);
            this.c = k
        }
        this.s = !0;
        b = this.m;
        f = h = k = 0;
        for (p = b.length; f < p; ++f) h += b[f].data.length;
        if (r)
            for (h = new Uint8Array(h), f = 0; f < p; ++f) h.set(b[f].data, k), k += b[f].data.length;
        else {
            h = [];
            for (f = 0; f < p; ++f) h[f] = b[f].data;
            h = Array.prototype.concat.apply([], h)
        }
        return h
    };
    b("Zlib.Gunzip", l);
    b("Zlib.Gunzip.prototype.decompress", l.prototype.g);
    b("Zlib.Gunzip.prototype.getMembers",
        l.prototype.F)
}).call(this);
"undefined" !== typeof window && ! function (a, b, c) {
    var e = a.L,
        d = {
            version: "0.7.2",
            noConflict: function () {
                return a.L = e, this
            }
        };
    a.L = d;
    d.Util = {
        extend: function (a) {
            var b, c, d, e, g = Array.prototype.slice.call(arguments, 1);
            c = 0;
            for (d = g.length; d > c; c++)
                for (b in e = g[c] || {}, e) e.hasOwnProperty(b) && (a[b] = e[b]);
            return a
        },
        bind: function (a, b) {
            var c = 2 < arguments.length ? Array.prototype.slice.call(arguments, 2) : null;
            return function () {
                return a.apply(b, c || arguments)
            }
        },
        stamp: function () {
            var a = 0;
            return function (b) {
                return b._leaflet_id =
                    b._leaflet_id || ++a, b._leaflet_id
            }
        }(),
        invokeEach: function (a, b, c) {
            var d, e;
            if ("object" == typeof a) {
                e = Array.prototype.slice.call(arguments, 3);
                for (d in a) b.apply(c, [d, a[d]].concat(e));
                return !0
            }
            return !1
        },
        limitExecByInterval: function (a, b, c) {
            var d, e;
            return function r() {
                var g = arguments;
                return d ? void(e = !0) : (d = !0, setTimeout(function () {
                    d = !1;
                    e && (r.apply(c, g), e = !1)
                }, b), void a.apply(c, g))
            }
        },
        falseFn: function () {
            return !1
        },
        formatNum: function (a, b) {
            var c = Math.pow(10, b || 5);
            return Math.round(a * c) / c
        },
        trim: function (a) {
            return a.trim ?
                a.trim() : a.replace(/^\s+|\s+$/g, "")
        },
        splitWords: function (a) {
            return d.Util.trim(a).split(/\s+/)
        },
        setOptions: function (a, b) {
            return a.options = d.extend({}, a.options, b), a.options
        },
        getParamString: function (a, b, c) {
            var d = [],
                e;
            for (e in a) d.push(encodeURIComponent(c ? e.toUpperCase() : e) + "=" + encodeURIComponent(a[e]));
            return (b && -1 !== b.indexOf("?") ? "&" : "?") + d.join("&")
        },
        template: function (a, b) {
            return a.replace(/\{ *([\w_]+) *\}/g, function (a, f) {
                var d = b[f];
                if (d === c) throw Error("No value provided for variable " + a);
                return "function" ==
                    typeof d && (d = d(b)), d
            })
        },
        isArray: Array.isArray || function (a) {
            return "[object Array]" === Object.prototype.toString.call(a)
        },
        emptyImageUrl: "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="
    };
    (function () {
        function b(f) {
            var c, d, k = ["webkit", "moz", "o", "ms"];
            for (c = 0; c < k.length && !d; c++) d = a[k[c] + f];
            return d
        }

        function c(b) {
            var f = +new Date,
                d = Math.max(0, 16 - (f - e));
            return e = f + d, a.setTimeout(b, d)
        }
        var e = 0,
            g = a.requestAnimationFrame || b("RequestAnimationFrame") || c,
            m = a.cancelAnimationFrame || b("CancelAnimationFrame") ||
            b("CancelRequestAnimationFrame") || function (b) {
                a.clearTimeout(b)
            };
        d.Util.requestAnimFrame = function (b, f, e, h) {
            return b = d.bind(b, f), e && g === c ? void b() : g.call(a, b, h)
        };
        d.Util.cancelAnimFrame = function (b) {
            b && m.call(a, b)
        }
    })();
    d.extend = d.Util.extend;
    d.bind = d.Util.bind;
    d.stamp = d.Util.stamp;
    d.setOptions = d.Util.setOptions;
    d.Class = function () {};
    d.Class.extend = function (a) {
        var b = function () {
                this.initialize && this.initialize.apply(this, arguments);
                this._initHooks && this.callInitHooks()
            },
            c = function () {};
        c.prototype = this.prototype;
        var e = new c;
        e.constructor = b;
        b.prototype = e;
        for (var g in this) this.hasOwnProperty(g) && "prototype" !== g && (b[g] = this[g]);
        a.statics && (d.extend(b, a.statics), delete a.statics);
        a.includes && (d.Util.extend.apply(null, [e].concat(a.includes)), delete a.includes);
        a.options && e.options && (a.options = d.extend({}, e.options, a.options));
        d.extend(e, a);
        e._initHooks = [];
        var n = this;
        return b.__super__ = n.prototype, e.callInitHooks = function () {
            if (!this._initHooksCalled) {
                n.prototype.callInitHooks && n.prototype.callInitHooks.call(this);
                this._initHooksCalled = !0;
                for (var a = 0, b = e._initHooks.length; b > a; a++) e._initHooks[a].call(this)
            }
        }, b
    };
    d.Class.include = function (a) {
        d.extend(this.prototype, a)
    };
    d.Class.mergeOptions = function (a) {
        d.extend(this.prototype.options, a)
    };
    d.Class.addInitHook = function (a) {
        var b = Array.prototype.slice.call(arguments, 1);
        this.prototype._initHooks = this.prototype._initHooks || [];
        this.prototype._initHooks.push("function" == typeof a ? a : function () {
            this[a].apply(this, b)
        })
    };
    d.Mixin = {};
    d.Mixin.Events = {
        addEventListener: function (a,
            b, c) {
            if (d.Util.invokeEach(a, this.addEventListener, this, b, c)) return this;
            var e, g, n, r, s, t, p, u = this._leaflet_events = this._leaflet_events || {},
                v = c && c !== this && d.stamp(c);
            a = d.Util.splitWords(a);
            e = 0;
            for (g = a.length; g > e; e++) n = {
                action: b,
                context: c || this
            }, r = a[e], v ? (s = r + "_idx", t = s + "_len", p = u[s] = u[s] || {}, p[v] || (p[v] = [], u[t] = (u[t] || 0) + 1), p[v].push(n)) : (u[r] = u[r] || [], u[r].push(n));
            return this
        },
        hasEventListeners: function (a) {
            var b = this._leaflet_events;
            return !!b && (a in b && 0 < b[a].length || a + "_idx" in b && 0 < b[a + "_idx_len"])
        },
        removeEventListener: function (a, b, c) {
            if (!this._leaflet_events) return this;
            if (!a) return this.clearAllEventListeners();
            if (d.Util.invokeEach(a, this.removeEventListener, this, b, c)) return this;
            var e, g, n, r, s, t, p, u, v, w = this._leaflet_events,
                y = c && c !== this && d.stamp(c);
            a = d.Util.splitWords(a);
            e = 0;
            for (g = a.length; g > e; e++)
                if (n = a[e], t = n + "_idx", p = t + "_len", u = w[t], b) {
                    if (r = y && u ? u[y] : w[n]) {
                        for (s = r.length - 1; 0 <= s; s--) r[s].action !== b || c && r[s].context !== c || (v = r.splice(s, 1), v[0].action = d.Util.falseFn);
                        c && u && 0 === r.length && (delete u[y],
                            w[p]--)
                    }
                } else delete w[n], delete w[t], delete w[p];
            return this
        },
        clearAllEventListeners: function () {
            return delete this._leaflet_events, this
        },
        fireEvent: function (a, b) {
            if (!this.hasEventListeners(a)) return this;
            var c, e, g, n, r, s = d.Util.extend({}, b, {
                type: a,
                target: this
            });
            n = this._leaflet_events;
            if (n[a])
                for (c = n[a].slice(), e = 0, g = c.length; g > e; e++) c[e].action.call(c[e].context, s);
            n = n[a + "_idx"];
            for (r in n)
                if (c = n[r].slice())
                    for (e = 0, g = c.length; g > e; e++) c[e].action.call(c[e].context, s);
            return this
        },
        addOneTimeEventListener: function (a,
            b, c) {
            if (d.Util.invokeEach(a, this.addOneTimeEventListener, this, b, c)) return this;
            var e = d.bind(function () {
                this.removeEventListener(a, b, c).removeEventListener(a, e, c)
            }, this);
            return this.addEventListener(a, b, c).addEventListener(a, e, c)
        }
    };
    d.Mixin.Events.on = d.Mixin.Events.addEventListener;
    d.Mixin.Events.off = d.Mixin.Events.removeEventListener;
    d.Mixin.Events.once = d.Mixin.Events.addOneTimeEventListener;
    d.Mixin.Events.fire = d.Mixin.Events.fireEvent;
    (function () {
        var f = "ActiveXObject" in a,
            k = f && !b.addEventListener,
            e = navigator.userAgent.toLowerCase(),
            g = -1 !== e.indexOf("webkit"),
            m = -1 !== e.indexOf("chrome"),
            n = -1 !== e.indexOf("phantom"),
            r = -1 !== e.indexOf("android"),
            s = -1 !== e.search("android [23]"),
            e = -1 !== e.indexOf("gecko"),
            t = typeof orientation != c + "",
            p = a.navigator && a.navigator.msPointerEnabled && a.navigator.msMaxTouchPoints && !a.PointerEvent,
            u = a.PointerEvent && a.navigator.pointerEnabled && a.navigator.maxTouchPoints || p,
            v = "devicePixelRatio" in a && 1 < a.devicePixelRatio || "matchMedia" in a && a.matchMedia("(min-resolution:144dpi)") &&
            a.matchMedia("(min-resolution:144dpi)").matches,
            w = b.documentElement,
            y = f && "transition" in w.style,
            x = "WebKitCSSMatrix" in a && "m11" in new a.WebKitCSSMatrix && !s,
            A = "MozPerspective" in w.style,
            N = "OTransition" in w.style,
            B = !a.L_DISABLE_3D && (y || x || A || N) && !n,
            G;
        if (G = !a.L_NO_TOUCH) {
            if (n = !n) u || "ontouchstart" in w ? n = !0 : (n = b.createElement("div"), w = !1, n = n.setAttribute ? (n.setAttribute("ontouchstart", "return;"), "function" == typeof n.ontouchstart && (w = !0), n.removeAttribute("ontouchstart"), w) : !1);
            G = n
        }
        d.Browser = {
            ie: f,
            ielt9: k,
            webkit: g,
            gecko: e && !g && !a.opera && !f,
            android: r,
            android23: s,
            chrome: m,
            ie3d: y,
            webkit3d: x,
            gecko3d: A,
            opera3d: N,
            any3d: B,
            mobile: t,
            mobileWebkit: t && g,
            mobileWebkit3d: t && x,
            mobileOpera: t && a.opera,
            touch: G,
            msPointer: p,
            pointer: u,
            retina: v
        }
    })();
    d.Point = function (a, b, c) {
        this.x = c ? Math.round(a) : a;
        this.y = c ? Math.round(b) : b
    };
    d.Point.prototype = {
        clone: function () {
            return new d.Point(this.x, this.y)
        },
        add: function (a) {
            return this.clone()._add(d.point(a))
        },
        _add: function (a) {
            return this.x += a.x, this.y += a.y, this
        },
        subtract: function (a) {
            return this.clone()._subtract(d.point(a))
        },
        _subtract: function (a) {
            return this.x -= a.x, this.y -= a.y, this
        },
        divideBy: function (a) {
            return this.clone()._divideBy(a)
        },
        _divideBy: function (a) {
            return this.x /= a, this.y /= a, this
        },
        multiplyBy: function (a) {
            return this.clone()._multiplyBy(a)
        },
        _multiplyBy: function (a) {
            return this.x *= a, this.y *= a, this
        },
        round: function () {
            return this.clone()._round()
        },
        _round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        },
        floor: function () {
            return this.clone()._floor()
        },
        _floor: function () {
            return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y), this
        },
        distanceTo: function (a) {
            a = d.point(a);
            var b = a.x - this.x;
            a = a.y - this.y;
            return Math.sqrt(b * b + a * a)
        },
        equals: function (a) {
            return a = d.point(a), a.x === this.x && a.y === this.y
        },
        contains: function (a) {
            return a = d.point(a), Math.abs(a.x) <= Math.abs(this.x) && Math.abs(a.y) <= Math.abs(this.y)
        },
        toString: function () {
            return "Point(" + d.Util.formatNum(this.x) + ", " + d.Util.formatNum(this.y) + ")"
        }
    };
    d.point = function (a, b, e) {
        return a instanceof d.Point ? a : d.Util.isArray(a) ? new d.Point(a[0], a[1]) : a === c || null ===
            a ? a : new d.Point(a, b, e)
    };
    d.Bounds = function (a, b) {
        if (a)
            for (var c = b ? [a, b] : a, d = 0, e = c.length; e > d; d++) this.extend(c[d])
    };
    d.Bounds.prototype = {
        extend: function (a) {
            return a = d.point(a), this.min || this.max ? (this.min.x = Math.min(a.x, this.min.x), this.max.x = Math.max(a.x, this.max.x), this.min.y = Math.min(a.y, this.min.y), this.max.y = Math.max(a.y, this.max.y)) : (this.min = a.clone(), this.max = a.clone()), this
        },
        getCenter: function (a) {
            return new d.Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, a)
        },
        getBottomLeft: function () {
            return new d.Point(this.min.x,
                this.max.y)
        },
        getTopRight: function () {
            return new d.Point(this.max.x, this.min.y)
        },
        getSize: function () {
            return this.max.subtract(this.min)
        },
        contains: function (a) {
            var b, c;
            return a = "number" == typeof a[0] || a instanceof d.Point ? d.point(a) : d.bounds(a), a instanceof d.Bounds ? (b = a.min, c = a.max) : b = c = a, b.x >= this.min.x && c.x <= this.max.x && b.y >= this.min.y && c.y <= this.max.y
        },
        intersects: function (a) {
            a = d.bounds(a);
            var b = this.min,
                c = this.max,
                e = a.min;
            a = a.max;
            var g = a.y >= b.y && e.y <= c.y;
            return a.x >= b.x && e.x <= c.x && g
        },
        isValid: function () {
            return !(!this.min ||
                !this.max)
        }
    };
    d.bounds = function (a, b) {
        return !a || a instanceof d.Bounds ? a : new d.Bounds(a, b)
    };
    d.Transformation = function (a, b, c, d) {
        this._a = a;
        this._b = b;
        this._c = c;
        this._d = d
    };
    d.Transformation.prototype = {
        transform: function (a, b) {
            return this._transform(a.clone(), b)
        },
        _transform: function (a, b) {
            return b = b || 1, a.x = b * (this._a * a.x + this._b), a.y = b * (this._c * a.y + this._d), a
        },
        untransform: function (a, b) {
            return b = b || 1, new d.Point((a.x / b - this._b) / this._a, (a.y / b - this._d) / this._c)
        }
    };
    d.DomUtil = {
        get: function (a) {
            return "string" == typeof a ?
                b.getElementById(a) : a
        },
        getStyle: function (a, c) {
            var d = a.style[c];
            (!d && a.currentStyle && (d = a.currentStyle[c]), d && "auto" !== d || !b.defaultView) || (d = (d = b.defaultView.getComputedStyle(a, null)) ? d[c] : null);
            return "auto" === d ? null : d
        },
        getViewportOffset: function (a) {
            var c, e = 0,
                g = 0,
                m = a,
                n = b.body,
                r = b.documentElement;
            do {
                if (e += m.offsetTop || 0, g += m.offsetLeft || 0, e += parseInt(d.DomUtil.getStyle(m, "borderTopWidth"), 10) || 0, g += parseInt(d.DomUtil.getStyle(m, "borderLeftWidth"), 10) || 0, c = d.DomUtil.getStyle(m, "position"), m.offsetParent ===
                    n && "absolute" === c) break;
                if ("fixed" === c) {
                    e += n.scrollTop || r.scrollTop || 0;
                    g += n.scrollLeft || r.scrollLeft || 0;
                    break
                }
                if ("relative" === c && !m.offsetLeft) {
                    c = d.DomUtil.getStyle(m, "width");
                    var s = d.DomUtil.getStyle(m, "max-width"),
                        t = m.getBoundingClientRect();
                    "none" === c && "none" === s || (g += t.left + m.clientLeft);
                    e += t.top + (n.scrollTop || r.scrollTop || 0);
                    break
                }
                m = m.offsetParent
            } while (m);
            m = a;
            do {
                if (m === n) break;
                e -= m.scrollTop || 0;
                g -= m.scrollLeft || 0;
                m = m.parentNode
            } while (m);
            return new d.Point(g, e)
        },
        documentIsLtr: function () {
            return d.DomUtil._docIsLtrCached ||
                (d.DomUtil._docIsLtrCached = !0, d.DomUtil._docIsLtr = "ltr" === d.DomUtil.getStyle(b.body, "direction")), d.DomUtil._docIsLtr
        },
        create: function (a, c, d) {
            a = b.createElement(a);
            return a.className = c, d && d.appendChild(a), a
        },
        hasClass: function (a, b) {
            if (a.classList !== c) return a.classList.contains(b);
            var e = d.DomUtil._getClass(a);
            return 0 < e.length && (new RegExp("(^|\\s)" + b + "(\\s|$)")).test(e)
        },
        addClass: function (a, b) {
            if (a.classList !== c)
                for (var e = d.Util.splitWords(b), g = 0, m = e.length; m > g; g++) a.classList.add(e[g]);
            else d.DomUtil.hasClass(a,
                b) || (e = d.DomUtil._getClass(a), d.DomUtil._setClass(a, (e ? e + " " : "") + b))
        },
        removeClass: function (a, b) {
            a.classList !== c ? a.classList.remove(b) : d.DomUtil._setClass(a, d.Util.trim((" " + d.DomUtil._getClass(a) + " ").replace(" " + b + " ", " ")))
        },
        _setClass: function (a, b) {
            a.className.baseVal === c ? a.className = b : a.className.baseVal = b
        },
        _getClass: function (a) {
            return a.className.baseVal === c ? a.className : a.className.baseVal
        },
        setOpacity: function (a, b) {
            if ("opacity" in a.style) a.style.opacity = b;
            else if ("filter" in a.style) {
                var c = !1;
                try {
                    c = a.filters.item("DXImageTransform.Microsoft.Alpha")
                } catch (d) {
                    if (1 === b) return
                }
                b = Math.round(100 * b);
                c ? (c.Enabled = 100 !== b, c.Opacity = b) : a.style.filter += " progid:DXImageTransform.Microsoft.Alpha(opacity=" + b + ")"
            }
        },
        testProp: function (a) {
            for (var c = b.documentElement.style, d = 0; d < a.length; d++)
                if (a[d] in c) return a[d];
            return !1
        },
        getTranslateString: function (a) {
            var b = d.Browser.webkit3d;
            return "translate" + (b ? "3d" : "") + "(" + a.x + "px," + a.y + "px" + ((b ? ",0" : "") + ")")
        },
        getScaleString: function (a, b) {
            return d.DomUtil.getTranslateString(b.add(b.multiplyBy(-1 *
                a))) + (" scale(" + a + ") ")
        },
        setPosition: function (a, b, c) {
            a._leaflet_pos = b;
            !c && d.Browser.any3d ? a.style[d.DomUtil.TRANSFORM] = d.DomUtil.getTranslateString(b) : (a.style.left = b.x + "px", a.style.top = b.y + "px")
        },
        getPosition: function (a) {
            return a._leaflet_pos
        }
    };
    d.DomUtil.TRANSFORM = d.DomUtil.testProp(["transform", "WebkitTransform", "OTransform", "MozTransform", "msTransform"]);
    d.DomUtil.TRANSITION = d.DomUtil.testProp(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
    d.DomUtil.TRANSITION_END =
        "webkitTransition" === d.DomUtil.TRANSITION || "OTransition" === d.DomUtil.TRANSITION ? d.DomUtil.TRANSITION + "End" : "transitionend";
    (function () {
        if ("onselectstart" in b) d.extend(d.DomUtil, {
            disableTextSelection: function () {
                d.DomEvent.on(a, "selectstart", d.DomEvent.preventDefault)
            },
            enableTextSelection: function () {
                d.DomEvent.off(a, "selectstart", d.DomEvent.preventDefault)
            }
        });
        else {
            var f = d.DomUtil.testProp(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]);
            d.extend(d.DomUtil, {
                disableTextSelection: function () {
                    if (f) {
                        var a =
                            b.documentElement.style;
                        this._userSelect = a[f];
                        a[f] = "none"
                    }
                },
                enableTextSelection: function () {
                    f && (b.documentElement.style[f] = this._userSelect, delete this._userSelect)
                }
            })
        }
        d.extend(d.DomUtil, {
            disableImageDrag: function () {
                d.DomEvent.on(a, "dragstart", d.DomEvent.preventDefault)
            },
            enableImageDrag: function () {
                d.DomEvent.off(a, "dragstart", d.DomEvent.preventDefault)
            }
        })
    })();
    d.LatLng = function (a, b, d) {
        if (a = parseFloat(a), b = parseFloat(b), isNaN(a) || isNaN(b)) throw Error("Invalid LatLng object: (" + a + ", " + b + ")");
        this.lat =
            a;
        this.lng = b;
        d !== c && (this.alt = parseFloat(d))
    };
    d.extend(d.LatLng, {
        DEG_TO_RAD: Math.PI / 180,
        RAD_TO_DEG: 180 / Math.PI,
        MAX_MARGIN: 1E-9
    });
    d.LatLng.prototype = {
        equals: function (a) {
            if (!a) return !1;
            a = d.latLng(a);
            return Math.max(Math.abs(this.lat - a.lat), Math.abs(this.lng - a.lng)) <= d.LatLng.MAX_MARGIN
        },
        toString: function (a) {
            return "LatLng(" + d.Util.formatNum(this.lat, a) + ", " + d.Util.formatNum(this.lng, a) + ")"
        },
        distanceTo: function (a) {
            a = d.latLng(a);
            var b = d.LatLng.DEG_TO_RAD,
                c = (a.lng - this.lng) * b,
                e = this.lat * b,
                g = a.lat * b;
            a = Math.sin((a.lat -
                this.lat) * b / 2);
            c = Math.sin(c / 2);
            e = a * a + c * c * Math.cos(e) * Math.cos(g);
            return 12756274 * Math.atan2(Math.sqrt(e), Math.sqrt(1 - e))
        },
        wrap: function (a, b) {
            var c = this.lng;
            return a = a || -180, b = b || 180, c = (c + b) % (b - a) + (a > c || c === b ? b : a), new d.LatLng(this.lat, c)
        }
    };
    d.latLng = function (a, b) {
        return a instanceof d.LatLng ? a : d.Util.isArray(a) ? "number" == typeof a[0] || "string" == typeof a[0] ? new d.LatLng(a[0], a[1], a[2]) : null : a === c || null === a ? a : "object" == typeof a && "lat" in a ? new d.LatLng(a.lat, "lng" in a ? a.lng : a.lon) : b === c ? null : new d.LatLng(a,
            b)
    };
    d.LatLngBounds = function (a, b) {
        if (a)
            for (var c = b ? [a, b] : a, d = 0, e = c.length; e > d; d++) this.extend(c[d])
    };
    d.LatLngBounds.prototype = {
        extend: function (a) {
            if (!a) return this;
            var b = d.latLng(a);
            return a = null !== b ? b : d.latLngBounds(a), a instanceof d.LatLng ? this._southWest || this._northEast ? (this._southWest.lat = Math.min(a.lat, this._southWest.lat), this._southWest.lng = Math.min(a.lng, this._southWest.lng), this._northEast.lat = Math.max(a.lat, this._northEast.lat), this._northEast.lng = Math.max(a.lng, this._northEast.lng)) : (this._southWest =
                new d.LatLng(a.lat, a.lng), this._northEast = new d.LatLng(a.lat, a.lng)) : a instanceof d.LatLngBounds && (this.extend(a._southWest), this.extend(a._northEast)), this
        },
        pad: function (a) {
            var b = this._southWest,
                c = this._northEast,
                e = Math.abs(b.lat - c.lat) * a;
            a *= Math.abs(b.lng - c.lng);
            return new d.LatLngBounds(new d.LatLng(b.lat - e, b.lng - a), new d.LatLng(c.lat + e, c.lng + a))
        },
        getCenter: function () {
            return new d.LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2)
        },
        getSouthWest: function () {
            return this._southWest
        },
        getNorthEast: function () {
            return this._northEast
        },
        getNorthWest: function () {
            return new d.LatLng(this.getNorth(), this.getWest())
        },
        getSouthEast: function () {
            return new d.LatLng(this.getSouth(), this.getEast())
        },
        getWest: function () {
            return this._southWest.lng
        },
        getSouth: function () {
            return this._southWest.lat
        },
        getEast: function () {
            return this._northEast.lng
        },
        getNorth: function () {
            return this._northEast.lat
        },
        contains: function (a) {
            a = "number" == typeof a[0] || a instanceof d.LatLng ? d.latLng(a) : d.latLngBounds(a);
            var b, c, e = this._southWest,
                g = this._northEast;
            return a instanceof d.LatLngBounds ? (b = a.getSouthWest(), c = a.getNorthEast()) : b = c = a, b.lat >= e.lat && c.lat <= g.lat && b.lng >= e.lng && c.lng <= g.lng
        },
        intersects: function (a) {
            a = d.latLngBounds(a);
            var b = this._southWest,
                c = this._northEast,
                e = a.getSouthWest();
            a = a.getNorthEast();
            var g = a.lng >= b.lng && e.lng <= c.lng;
            return a.lat >= b.lat && e.lat <= c.lat && g
        },
        toBBoxString: function () {
            return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join()
        },
        equals: function (a) {
            return a ? (a = d.latLngBounds(a), this._southWest.equals(a.getSouthWest()) &&
                this._northEast.equals(a.getNorthEast())) : !1
        },
        isValid: function () {
            return !(!this._southWest || !this._northEast)
        }
    };
    d.latLngBounds = function (a, b) {
        return !a || a instanceof d.LatLngBounds ? a : new d.LatLngBounds(a, b)
    };
    d.Projection = {};
    d.Projection.SphericalMercator = {
        MAX_LATITUDE: 85.0511287798,
        project: function (a) {
            var b = d.LatLng.DEG_TO_RAD,
                c = this.MAX_LATITUDE,
                c = Math.max(Math.min(c, a.lat), -c);
            a = a.lng * b;
            b *= c;
            return b = Math.log(Math.tan(Math.PI / 4 + b / 2)), new d.Point(a, b)
        },
        unproject: function (a) {
            var b = d.LatLng.RAD_TO_DEG,
                c = a.x * b;
            a = (2 * Math.atan(Math.exp(a.y)) - Math.PI / 2) * b;
            return new d.LatLng(a, c)
        }
    };
    d.Projection.LonLat = {
        project: function (a) {
            return new d.Point(a.lng, a.lat)
        },
        unproject: function (a) {
            return new d.LatLng(a.y, a.x)
        }
    };
    d.CRS = {
        latLngToPoint: function (a, b) {
            var c = this.projection.project(a),
                d = this.scale(b);
            return this.transformation._transform(c, d)
        },
        pointToLatLng: function (a, b) {
            var c = this.scale(b),
                c = this.transformation.untransform(a, c);
            return this.projection.unproject(c)
        },
        project: function (a) {
            return this.projection.project(a)
        },
        scale: function (a) {
            return 256 * Math.pow(2, a)
        },
        getSize: function (a) {
            a = this.scale(a);
            return d.point(a, a)
        }
    };
    d.CRS.Simple = d.extend({}, d.CRS, {
        projection: d.Projection.LonLat,
        transformation: new d.Transformation(1, 0, -1, 0),
        scale: function (a) {
            return Math.pow(2, a)
        }
    });
    d.CRS.EPSG3857 = d.extend({}, d.CRS, {
        code: "EPSG:3857",
        projection: d.Projection.SphericalMercator,
        transformation: new d.Transformation(0.5 / Math.PI, 0.5, -0.5 / Math.PI, 0.5),
        project: function (a) {
            return this.projection.project(a).multiplyBy(6378137)
        }
    });
    d.CRS.EPSG900913 =
        d.extend({}, d.CRS.EPSG3857, {
            code: "EPSG:900913"
        });
    d.CRS.EPSG4326 = d.extend({}, d.CRS, {
        code: "EPSG:4326",
        projection: d.Projection.LonLat,
        transformation: new d.Transformation(1 / 360, 0.5, -1 / 360, 0.5)
    });
    d.Map = d.Class.extend({
        includes: d.Mixin.Events,
        options: {
            crs: d.CRS.EPSG3857,
            fadeAnimation: d.DomUtil.TRANSITION && !d.Browser.android23,
            trackResize: !0,
            markerZoomAnimation: d.DomUtil.TRANSITION && d.Browser.any3d
        },
        initialize: function (a, b) {
            b = d.setOptions(this, b);
            this._initContainer(a);
            this._initLayout();
            this._onResize =
                d.bind(this._onResize, this);
            this._initEvents();
            b.maxBounds && this.setMaxBounds(b.maxBounds);
            b.center && b.zoom !== c && this.setView(d.latLng(b.center), b.zoom, {
                reset: !0
            });
            this._handlers = [];
            this._layers = {};
            this._zoomBoundLayers = {};
            this._tileLayersNum = 0;
            this.callInitHooks();
            this._addLayers(b.layers)
        },
        setView: function (a, b) {
            return b = b === c ? this.getZoom() : b, this._resetView(d.latLng(a), this._limitZoom(b)), this
        },
        setZoom: function (a, b) {
            return this._loaded ? this.setView(this.getCenter(), a, {
                zoom: b
            }) : (this._zoom = this._limitZoom(a),
                this)
        },
        zoomIn: function (a, b) {
            return this.setZoom(this._zoom + (a || 1), b)
        },
        zoomOut: function (a, b) {
            return this.setZoom(this._zoom - (a || 1), b)
        },
        setZoomAround: function (a, b, c) {
            var e = this.getZoomScale(b),
                g = this.getSize().divideBy(2);
            a = (a instanceof d.Point ? a : this.latLngToContainerPoint(a)).subtract(g).multiplyBy(1 - 1 / e);
            g = this.containerPointToLatLng(g.add(a));
            return this.setView(g, b, {
                zoom: c
            })
        },
        fitBounds: function (a, b) {
            b = b || {};
            a = a.getBounds ? a.getBounds() : d.latLngBounds(a);
            var c = d.point(b.paddingTopLeft || b.padding || [0, 0]),
                e = d.point(b.paddingBottomRight || b.padding || [0, 0]),
                g = this.getBoundsZoom(a, !1, c.add(e)),
                c = e.subtract(c).divideBy(2),
                e = this.project(a.getSouthWest(), g),
                n = this.project(a.getNorthEast(), g),
                c = this.unproject(e.add(n).divideBy(2).add(c), g);
            return g = b && b.maxZoom ? Math.min(b.maxZoom, g) : g, this.setView(c, g, b)
        },
        fitWorld: function (a) {
            return this.fitBounds([
                [-90, -180],
                [90, 180]
            ], a)
        },
        panTo: function (a, b) {
            return this.setView(a, this._zoom, {
                pan: b
            })
        },
        panBy: function (a) {
            return this.fire("movestart"), this._rawPanBy(d.point(a)),
                this.fire("move"), this.fire("moveend")
        },
        setMaxBounds: function (a) {
            return a = d.latLngBounds(a), this.options.maxBounds = a, a ? (this._loaded && this._panInsideMaxBounds(), this.on("moveend", this._panInsideMaxBounds, this)) : this.off("moveend", this._panInsideMaxBounds, this)
        },
        panInsideBounds: function (a, b) {
            var c = this.getCenter(),
                d = this._limitCenter(c, this._zoom, a);
            return c.equals(d) ? this : this.panTo(d, b)
        },
        addLayer: function (a) {
            var b = d.stamp(a);
            return this._layers[b] ? this : (this._layers[b] = a, !a.options || isNaN(a.options.maxZoom) &&
                isNaN(a.options.minZoom) || (this._zoomBoundLayers[b] = a, this._updateZoomLevels()), this.options.zoomAnimation && d.TileLayer && a instanceof d.TileLayer && (this._tileLayersNum++, this._tileLayersToLoad++, a.on("load", this._onTileLayerLoad, this)), this._loaded && this._layerAdd(a), this)
        },
        removeLayer: function (a) {
            var b = d.stamp(a);
            return this._layers[b] ? (this._loaded && a.onRemove(this), delete this._layers[b], this._loaded && this.fire("layerremove", {
                layer: a
            }), this._zoomBoundLayers[b] && (delete this._zoomBoundLayers[b],
                this._updateZoomLevels()), this.options.zoomAnimation && d.TileLayer && a instanceof d.TileLayer && (this._tileLayersNum--, this._tileLayersToLoad--, a.off("load", this._onTileLayerLoad, this)), this) : this
        },
        hasLayer: function (a) {
            return a ? d.stamp(a) in this._layers : !1
        },
        eachLayer: function (a, b) {
            for (var c in this._layers) a.call(b, this._layers[c]);
            return this
        },
        invalidateSize: function (a) {
            if (!this._loaded) return this;
            a = d.extend({
                animate: !1,
                pan: !0
            }, !0 === a ? {
                animate: !0
            } : a);
            var b = this.getSize();
            this._sizeChanged = !0;
            this._initialCenter =
                null;
            var c = this.getSize(),
                e = b.divideBy(2).round(),
                g = c.divideBy(2).round(),
                e = e.subtract(g);
            return e.x || e.y ? (a.animate && a.pan ? this.panBy(e) : (a.pan && this._rawPanBy(e), this.fire("move"), a.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(d.bind(this.fire, this, "moveend"), 200)) : this.fire("moveend")), this.fire("resize", {
                oldSize: b,
                newSize: c
            })) : this
        },
        addHandler: function (a, b) {
            if (!b) return this;
            var c = this[a] = new b(this);
            return this._handlers.push(c), this.options[a] && c.enable(), this
        },
        remove: function () {
            this._loaded && this.fire("unload");
            this._initEvents("off");
            try {
                delete this._container._leaflet
            } catch (a) {
                this._container._leaflet = c
            }
            return this._clearPanes(), this._clearControlPos && this._clearControlPos(), this._clearHandlers(), this
        },
        getCenter: function () {
            return this._checkIfLoaded(), this._initialCenter && !this._moved() ? this._initialCenter : this.layerPointToLatLng(this._getCenterLayerPoint())
        },
        getZoom: function () {
            return this._zoom
        },
        getBounds: function () {
            var a = this.getPixelBounds(),
                b = this.unproject(a.getBottomLeft()),
                a = this.unproject(a.getTopRight());
            return new d.LatLngBounds(b, a)
        },
        getMinZoom: function () {
            return this.options.minZoom === c ? this._layersMinZoom === c ? 0 : this._layersMinZoom : this.options.minZoom
        },
        getMaxZoom: function () {
            return this.options.maxZoom === c ? this._layersMaxZoom === c ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom
        },
        getBoundsZoom: function (a, b, c) {
            a = d.latLngBounds(a);
            var e, g = this.getMinZoom() - (b ? 1 : 0),
                n = this.getMaxZoom(),
                r = this.getSize(),
                s = a.getNorthWest();
            a = a.getSouthEast();
            e = !0;
            c = d.point(c || [0, 0]);
            do g++,
                e = this.project(a, g).subtract(this.project(s, g)).add(c), e = b ? e.x < r.x || e.y < r.y : r.contains(e); while (e && n >= g);
            return e && b ? null : b ? g : g - 1
        },
        getSize: function () {
            return (!this._size || this._sizeChanged) && (this._size = new d.Point(this._container.clientWidth, this._container.clientHeight), this._sizeChanged = !1), this._size.clone()
        },
        getPixelBounds: function () {
            var a = this._getTopLeftPoint();
            return new d.Bounds(a, a.add(this.getSize()))
        },
        getPixelOrigin: function () {
            return this._checkIfLoaded(), this._initialTopLeftPoint
        },
        getPanes: function () {
            return this._panes
        },
        getContainer: function () {
            return this._container
        },
        getZoomScale: function (a) {
            var b = this.options.crs;
            return b.scale(a) / b.scale(this._zoom)
        },
        getScaleZoom: function (a) {
            return this._zoom + Math.log(a) / Math.LN2
        },
        project: function (a, b) {
            return b = b === c ? this._zoom : b, this.options.crs.latLngToPoint(d.latLng(a), b)
        },
        unproject: function (a, b) {
            return b = b === c ? this._zoom : b, this.options.crs.pointToLatLng(d.point(a), b)
        },
        layerPointToLatLng: function (a) {
            a = d.point(a).add(this.getPixelOrigin());
            return this.unproject(a)
        },
        latLngToLayerPoint: function (a) {
            return this.project(d.latLng(a))._round()._subtract(this.getPixelOrigin())
        },
        containerPointToLayerPoint: function (a) {
            return d.point(a).subtract(this._getMapPanePos())
        },
        layerPointToContainerPoint: function (a) {
            return d.point(a).add(this._getMapPanePos())
        },
        containerPointToLatLng: function (a) {
            a = this.containerPointToLayerPoint(d.point(a));
            return this.layerPointToLatLng(a)
        },
        latLngToContainerPoint: function (a) {
            return this.layerPointToContainerPoint(this.latLngToLayerPoint(d.latLng(a)))
        },
        mouseEventToContainerPoint: function (a) {
            return d.DomEvent.getMousePosition(a, this._container)
        },
        mouseEventToLayerPoint: function (a) {
            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(a))
        },
        mouseEventToLatLng: function (a) {
            return this.layerPointToLatLng(this.mouseEventToLayerPoint(a))
        },
        _initContainer: function (a) {
            a = this._container = d.DomUtil.get(a);
            if (!a) throw Error("Map container not found.");
            if (a._leaflet) throw Error("Map container is already initialized.");
            a._leaflet = !0
        },
        _initLayout: function () {
            var a = this._container;
            d.DomUtil.addClass(a, "leaflet-container" + (d.Browser.touch ? " leaflet-touch" : "") + (d.Browser.retina ? " leaflet-retina" : "") + (d.Browser.ielt9 ? " leaflet-oldie" : "") + (this.options.fadeAnimation ?
                " leaflet-fade-anim" : ""));
            var b = d.DomUtil.getStyle(a, "position");
            "absolute" !== b && "relative" !== b && "fixed" !== b && (a.style.position = "relative");
            this._initPanes();
            this._initControlPos && this._initControlPos()
        },
        _initPanes: function () {
            var a = this._panes = {};
            this._mapPane = a.mapPane = this._createPane("leaflet-map-pane", this._container);
            this._tilePane = a.tilePane = this._createPane("leaflet-tile-pane", this._mapPane);
            a.objectsPane = this._createPane("leaflet-objects-pane", this._mapPane);
            a.shadowPane = this._createPane("leaflet-shadow-pane");
            a.overlayPane = this._createPane("leaflet-overlay-pane");
            a.markerPane = this._createPane("leaflet-marker-pane");
            a.popupPane = this._createPane("leaflet-popup-pane");
            this.options.markerZoomAnimation || (d.DomUtil.addClass(a.markerPane, " leaflet-zoom-hide"), d.DomUtil.addClass(a.shadowPane, " leaflet-zoom-hide"), d.DomUtil.addClass(a.popupPane, " leaflet-zoom-hide"))
        },
        _createPane: function (a, b) {
            return d.DomUtil.create("div", a, b || this._panes.objectsPane)
        },
        _clearPanes: function () {
            this._container.removeChild(this._mapPane)
        },
        _addLayers: function (a) {
            a = a ? d.Util.isArray(a) ? a : [a] : [];
            for (var b = 0, c = a.length; c > b; b++) this.addLayer(a[b])
        },
        _resetView: function (a, b, c, e) {
            var g = this._zoom !== b;
            e || (this.fire("movestart"), g && this.fire("zoomstart"));
            this._zoom = b;
            this._initialCenter = a;
            this._initialTopLeftPoint = this._getNewTopLeftPoint(a);
            c ? this._initialTopLeftPoint._add(this._getMapPanePos()) : d.DomUtil.setPosition(this._mapPane, new d.Point(0, 0));
            this._tileLayersToLoad = this._tileLayersNum;
            a = !this._loaded;
            this._loaded = !0;
            a && (this.fire("load"),
                this.eachLayer(this._layerAdd, this));
            this.fire("viewreset", {
                hard: !c
            });
            this.fire("move");
            (g || e) && this.fire("zoomend");
            this.fire("moveend", {
                hard: !c
            })
        },
        _rawPanBy: function (a) {
            d.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(a))
        },
        _getZoomSpan: function () {
            return this.getMaxZoom() - this.getMinZoom()
        },
        _updateZoomLevels: function () {
            var a, b = 1 / 0,
                d = -1 / 0,
                e = this._getZoomSpan();
            for (a in this._zoomBoundLayers) {
                var g = this._zoomBoundLayers[a];
                isNaN(g.options.minZoom) || (b = Math.min(b, g.options.minZoom));
                isNaN(g.options.maxZoom) || (d = Math.max(d, g.options.maxZoom))
            }
            a === c ? this._layersMaxZoom = this._layersMinZoom = c : (this._layersMaxZoom = d, this._layersMinZoom = b);
            e !== this._getZoomSpan() && this.fire("zoomlevelschange")
        },
        _panInsideMaxBounds: function () {
            this.panInsideBounds(this.options.maxBounds)
        },
        _checkIfLoaded: function () {
            if (!this._loaded) throw Error("Set map center and zoom first.");
        },
        _initEvents: function (b) {
            if (d.DomEvent) {
                b = b || "on";
                d.DomEvent[b](this._container, "click", this._onMouseClick, this);
                var c, e, g = "dblclick mousedown mouseup mouseenter mouseleave mousemove contextmenu".split(" ");
                c = 0;
                for (e = g.length; e > c; c++) d.DomEvent[b](this._container, g[c], this._fireMouseEvent, this);
                this.options.trackResize && d.DomEvent[b](a, "resize", this._onResize, this)
            }
        },
        _onResize: function () {
            d.Util.cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = d.Util.requestAnimFrame(function () {
                this.invalidateSize({
                    debounceMoveend: !0
                })
            }, this, !1, this._container)
        },
        _onMouseClick: function (a) {
            !this._loaded || !a._simulated && (this.dragging && this.dragging.moved() || this.boxZoom && this.boxZoom.moved()) || d.DomEvent._skipped(a) ||
                (this.fire("preclick"), this._fireMouseEvent(a))
        },
        _fireMouseEvent: function (a) {
            if (this._loaded && !d.DomEvent._skipped(a)) {
                var b = a.type;
                if (b = "mouseenter" === b ? "mouseover" : "mouseleave" === b ? "mouseout" : b, this.hasEventListeners(b)) {
                    "contextmenu" === b && d.DomEvent.preventDefault(a);
                    var c = this.mouseEventToContainerPoint(a),
                        e = this.containerPointToLayerPoint(c),
                        g = this.layerPointToLatLng(e);
                    this.fire(b, {
                        latlng: g,
                        layerPoint: e,
                        containerPoint: c,
                        originalEvent: a
                    })
                }
            }
        },
        _onTileLayerLoad: function () {
            this._tileLayersToLoad--;
            this._tileLayersNum && !this._tileLayersToLoad && this.fire("tilelayersload")
        },
        _clearHandlers: function () {
            for (var a = 0, b = this._handlers.length; b > a; a++) this._handlers[a].disable()
        },
        whenReady: function (a, b) {
            return this._loaded ? a.call(b || this, this) : this.on("load", a, b), this
        },
        _layerAdd: function (a) {
            a.onAdd(this);
            this.fire("layeradd", {
                layer: a
            })
        },
        _getMapPanePos: function () {
            return d.DomUtil.getPosition(this._mapPane)
        },
        _moved: function () {
            var a = this._getMapPanePos();
            return a && !a.equals([0, 0])
        },
        _getTopLeftPoint: function () {
            return this.getPixelOrigin().subtract(this._getMapPanePos())
        },
        _getNewTopLeftPoint: function (a, b) {
            var c = this.getSize()._divideBy(2);
            return this.project(a, b)._subtract(c)._round()
        },
        _latLngToNewLayerPoint: function (a, b, c) {
            c = this._getNewTopLeftPoint(c, b).add(this._getMapPanePos());
            return this.project(a, b)._subtract(c)
        },
        _getCenterLayerPoint: function () {
            return this.containerPointToLayerPoint(this.getSize()._divideBy(2))
        },
        _getCenterOffset: function (a) {
            return this.latLngToLayerPoint(a).subtract(this._getCenterLayerPoint())
        },
        _limitCenter: function (a, b, c) {
            if (!c) return a;
            a =
                this.project(a, b);
            var e = this.getSize().divideBy(2),
                e = new d.Bounds(a.subtract(e), a.add(e));
            c = this._getBoundsOffset(e, c, b);
            return this.unproject(a.add(c), b)
        },
        _limitOffset: function (a, b) {
            if (!b) return a;
            var c = this.getPixelBounds(),
                c = new d.Bounds(c.min.add(a), c.max.add(a));
            return a.add(this._getBoundsOffset(c, b))
        },
        _getBoundsOffset: function (a, b, c) {
            var e = this.project(b.getNorthWest(), c).subtract(a.min);
            b = this.project(b.getSouthEast(), c).subtract(a.max);
            a = this._rebound(e.x, -b.x);
            e = this._rebound(e.y, -b.y);
            return new d.Point(a, e)
        },
        _rebound: function (a, b) {
            return 0 < a + b ? Math.round(a - b) / 2 : Math.max(0, Math.ceil(a)) - Math.max(0, Math.floor(b))
        },
        _limitZoom: function (a) {
            var b = this.getMinZoom(),
                c = this.getMaxZoom();
            return Math.max(b, Math.min(c, a))
        }
    });
    d.map = function (a, b) {
        return new d.Map(a, b)
    };
    d.Projection.Mercator = {
        MAX_LATITUDE: 85.0840591556,
        R_MINOR: 6356752.314245179,
        R_MAJOR: 6378137,
        project: function (a) {
            var b = d.LatLng.DEG_TO_RAD,
                c = this.MAX_LATITUDE,
                e = Math.max(Math.min(c, a.lat), -c),
                c = this.R_MAJOR;
            a = a.lng * b * c;
            var b =
                e * b,
                e = this.R_MINOR / c,
                e = Math.sqrt(1 - e * e),
                g = e * Math.sin(b),
                g = Math.pow((1 - g) / (1 + g), 0.5 * e),
                e = Math.tan(0.5 * (0.5 * Math.PI - b)) / g;
            return b = -c * Math.log(e), new d.Point(a, b)
        },
        unproject: function (a) {
            var b, c = d.LatLng.RAD_TO_DEG,
                e = this.R_MAJOR,
                g = a.x * c / e,
                n = this.R_MINOR / e,
                n = Math.sqrt(1 - n * n);
            a = Math.exp(-a.y / e);
            var e = Math.PI / 2 - 2 * Math.atan(a),
                r = 15;
            for (b = 0.1; 1E-7 < Math.abs(b) && 0 < --r;) b = n * Math.sin(e), b = Math.PI / 2 - 2 * Math.atan(a * Math.pow((1 - b) / (1 + b), 0.5 * n)) - e, e += b;
            return new d.LatLng(e * c, g)
        }
    };
    d.CRS.EPSG3395 = d.extend({}, d.CRS, {
        code: "EPSG:3395",
        projection: d.Projection.Mercator,
        transformation: function () {
            var a = 0.5 / (Math.PI * d.Projection.Mercator.R_MAJOR);
            return new d.Transformation(a, 0.5, -a, 0.5)
        }()
    });
    d.TileLayer = d.Class.extend({
        includes: d.Mixin.Events,
        options: {
            minZoom: 0,
            maxZoom: 18,
            tileSize: 256,
            subdomains: "abc",
            errorTileUrl: "",
            attribution: "",
            zoomOffset: 0,
            opacity: 1,
            unloadInvisibleTiles: d.Browser.mobile,
            updateWhenIdle: d.Browser.mobile
        },
        initialize: function (a, b) {
            b = d.setOptions(this, b);
            b.detectRetina && d.Browser.retina && 0 < b.maxZoom &&
                (b.tileSize = Math.floor(b.tileSize / 2), b.zoomOffset++, 0 < b.minZoom && b.minZoom--, this.options.maxZoom--);
            b.bounds && (b.bounds = d.latLngBounds(b.bounds));
            this._url = a;
            var c = this.options.subdomains;
            "string" == typeof c && (this.options.subdomains = c.split(""))
        },
        onAdd: function (a) {
            this._map = a;
            this._animated = a._zoomAnimated;
            this._initContainer();
            a.on({
                viewreset: this._reset,
                moveend: this._update
            }, this);
            this._animated && a.on({
                zoomanim: this._animateZoom,
                zoomend: this._endZoomAnim
            }, this);
            this.options.updateWhenIdle || (this._limitedUpdate =
                d.Util.limitExecByInterval(this._update, 150, this), a.on("move", this._limitedUpdate, this));
            this._reset();
            this._update()
        },
        addTo: function (a) {
            return a.addLayer(this), this
        },
        onRemove: function (a) {
            this._container.parentNode.removeChild(this._container);
            a.off({
                viewreset: this._reset,
                moveend: this._update
            }, this);
            this._animated && a.off({
                zoomanim: this._animateZoom,
                zoomend: this._endZoomAnim
            }, this);
            this.options.updateWhenIdle || a.off("move", this._limitedUpdate, this);
            this._map = this._container = null
        },
        bringToFront: function () {
            var a =
                this._map._panes.tilePane;
            return this._container && (a.appendChild(this._container), this._setAutoZIndex(a, Math.max)), this
        },
        bringToBack: function () {
            var a = this._map._panes.tilePane;
            return this._container && (a.insertBefore(this._container, a.firstChild), this._setAutoZIndex(a, Math.min)), this
        },
        getAttribution: function () {
            return this.options.attribution
        },
        getContainer: function () {
            return this._container
        },
        setOpacity: function (a) {
            return this.options.opacity = a, this._map && this._updateOpacity(), this
        },
        setZIndex: function (a) {
            return this.options.zIndex =
                a, this._updateZIndex(), this
        },
        setUrl: function (a, b) {
            return this._url = a, b || this.redraw(), this
        },
        redraw: function () {
            return this._map && (this._reset({
                hard: !0
            }), this._update()), this
        },
        _updateZIndex: function () {
            this._container && this.options.zIndex !== c && (this._container.style.zIndex = this.options.zIndex)
        },
        _setAutoZIndex: function (a, b) {
            var c, d, e, g = a.children,
                r = -b(1 / 0, -1 / 0);
            d = 0;
            for (e = g.length; e > d; d++) g[d] !== this._container && (c = parseInt(g[d].style.zIndex, 10), isNaN(c) || (r = b(r, c)));
            this.options.zIndex = this._container.style.zIndex =
                (isFinite(r) ? r : 0) + b(1, -1)
        },
        _updateOpacity: function () {
            var a, b = this._tiles;
            if (d.Browser.ielt9)
                for (a in b) d.DomUtil.setOpacity(b[a], this.options.opacity);
            else d.DomUtil.setOpacity(this._container, this.options.opacity)
        },
        _initContainer: function () {
            var a = this._map._panes.tilePane;
            this._container || ((this._container = d.DomUtil.create("div", "leaflet-layer"), this._updateZIndex(), this._animated) ? (this._bgBuffer = d.DomUtil.create("div", "leaflet-tile-container", this._container), this._tileContainer = d.DomUtil.create("div",
                "leaflet-tile-container", this._container)) : this._tileContainer = this._container, a.appendChild(this._container), 1 > this.options.opacity && this._updateOpacity())
        },
        _reset: function (a) {
            for (var b in this._tiles) this.fire("tileunload", {
                tile: this._tiles[b]
            });
            this._tiles = {};
            this._tilesToLoad = 0;
            this.options.reuseTiles && (this._unusedTiles = []);
            this._tileContainer.innerHTML = "";
            this._animated && a && a.hard && this._clearBgBuffer();
            this._initContainer()
        },
        _getTileSize: function () {
            var a = this._map,
                b = a.getZoom() + this.options.zoomOffset,
                c = this.options.maxNativeZoom,
                d = this.options.tileSize;
            return c && b > c && (d = Math.round(a.getZoomScale(b) / a.getZoomScale(c) * d)), d
        },
        _update: function () {
            if (this._map) {
                var a = this._map,
                    b = a.getPixelBounds(),
                    a = a.getZoom(),
                    c = this._getTileSize();
                a > this.options.maxZoom || a < this.options.minZoom || (b = d.bounds(b.min.divideBy(c)._floor(), b.max.divideBy(c)._floor()), this._addTilesFromCenterOut(b), (this.options.unloadInvisibleTiles || this.options.reuseTiles) && this._removeOtherTiles(b))
            }
        },
        _addTilesFromCenterOut: function (a) {
            var c,
                e, g, m = [],
                n = a.getCenter();
            for (c = a.min.y; c <= a.max.y; c++)
                for (e = a.min.x; e <= a.max.x; e++) g = new d.Point(e, c), this._tileShouldBeLoaded(g) && m.push(g);
            a = m.length;
            if (0 !== a) {
                m.sort(function (a, b) {
                    return a.distanceTo(n) - b.distanceTo(n)
                });
                c = b.createDocumentFragment();
                this._tilesToLoad || this.fire("loading");
                this._tilesToLoad += a;
                for (e = 0; a > e; e++) this._addTile(m[e], c);
                this._tileContainer.appendChild(c)
            }
        },
        _tileShouldBeLoaded: function (a) {
            if (a.x + ":" + a.y in this._tiles) return !1;
            var b = this.options;
            if (!b.continuousWorld) {
                var c =
                    this._getWrapTileNum();
                if (b.noWrap && (0 > a.x || a.x >= c.x) || 0 > a.y || a.y >= c.y) return !1
            }
            return b.bounds && (c = b.tileSize, a = a.multiplyBy(c), c = a.add([c, c]), a = this._map.unproject(a), c = this._map.unproject(c), b.continuousWorld || b.noWrap || (a = a.wrap(), c = c.wrap()), !b.bounds.intersects([a, c])) ? !1 : !0
        },
        _removeOtherTiles: function (a) {
            var b, c, d;
            for (d in this._tiles) b = d.split(":"), c = parseInt(b[0], 10), b = parseInt(b[1], 10), (c < a.min.x || c > a.max.x || b < a.min.y || b > a.max.y) && this._removeTile(d)
        },
        _removeTile: function (a) {
            var b = this._tiles[a];
            this.fire("tileunload", {
                tile: b,
                url: b.src
            });
            this.options.reuseTiles ? (d.DomUtil.removeClass(b, "leaflet-tile-loaded"), this._unusedTiles.push(b)) : b.parentNode === this._tileContainer && this._tileContainer.removeChild(b);
            d.Browser.android || (b.onload = null, b.src = d.Util.emptyImageUrl);
            delete this._tiles[a]
        },
        _addTile: function (a, b) {
            var c = this._getTilePos(a),
                e = this._getTile();
            d.DomUtil.setPosition(e, c, d.Browser.chrome);
            this._tiles[a.x + ":" + a.y] = e;
            this._loadTile(e, a);
            e.parentNode !== this._tileContainer && b.appendChild(e)
        },
        _getZoomForUrl: function () {
            var a = this.options,
                b = this._map.getZoom();
            return a.zoomReverse && (b = a.maxZoom - b), b += a.zoomOffset, a.maxNativeZoom ? Math.min(b, a.maxNativeZoom) : b
        },
        _getTilePos: function (a) {
            var b = this._map.getPixelOrigin(),
                c = this._getTileSize();
            return a.multiplyBy(c).subtract(b)
        },
        getTileUrl: function (a) {
            return d.Util.template(this._url, d.extend({
                s: this._getSubdomain(a),
                z: a.z,
                x: a.x,
                y: a.y
            }, this.options))
        },
        _getWrapTileNum: function () {
            return this._map.options.crs.getSize(this._map.getZoom()).divideBy(this._getTileSize())._floor()
        },
        _adjustTilePoint: function (a) {
            var b = this._getWrapTileNum();
            this.options.continuousWorld || this.options.noWrap || (a.x = (a.x % b.x + b.x) % b.x);
            this.options.tms && (a.y = b.y - a.y - 1);
            a.z = this._getZoomForUrl()
        },
        _getSubdomain: function (a) {
            a = Math.abs(a.x + a.y) % this.options.subdomains.length;
            return this.options.subdomains[a]
        },
        _getTile: function () {
            if (this.options.reuseTiles && 0 < this._unusedTiles.length) {
                var a = this._unusedTiles.pop();
                return this._resetTile(a), a
            }
            return this._createTile()
        },
        _resetTile: function () {},
        _createTile: function () {
            var a =
                d.DomUtil.create("img", "leaflet-tile");
            return a.style.width = a.style.height = this._getTileSize() + "px", a.galleryimg = "no", a.onselectstart = a.onmousemove = d.Util.falseFn, d.Browser.ielt9 && this.options.opacity !== c && d.DomUtil.setOpacity(a, this.options.opacity), d.Browser.mobileWebkit3d && (a.style.WebkitBackfaceVisibility = "hidden"), a
        },
        _loadTile: function (a, b) {
            a._layer = this;
            a.onload = this._tileOnLoad;
            a.onerror = this._tileOnError;
            this._adjustTilePoint(b);
            a.src = this.getTileUrl(b);
            this.fire("tileloadstart", {
                tile: a,
                url: a.src
            })
        },
        _tileLoaded: function () {
            this._tilesToLoad--;
            this._animated && d.DomUtil.addClass(this._tileContainer, "leaflet-zoom-animated");
            this._tilesToLoad || (this.fire("load"), this._animated && (clearTimeout(this._clearBgBufferTimer), this._clearBgBufferTimer = setTimeout(d.bind(this._clearBgBuffer, this), 500)))
        },
        _tileOnLoad: function () {
            var a = this._layer;
            this.src !== d.Util.emptyImageUrl && (d.DomUtil.addClass(this, "leaflet-tile-loaded"), a.fire("tileload", {
                tile: this,
                url: this.src
            }));
            a._tileLoaded()
        },
        _tileOnError: function () {
            var a =
                this._layer;
            a.fire("tileerror", {
                tile: this,
                url: this.src
            });
            var b = a.options.errorTileUrl;
            b && (this.src = b);
            a._tileLoaded()
        }
    });
    d.tileLayer = function (a, b) {
        return new d.TileLayer(a, b)
    };
    d.TileLayer.WMS = d.TileLayer.extend({
        defaultWmsParams: {
            service: "WMS",
            request: "GetMap",
            version: "1.1.1",
            layers: "",
            styles: "",
            format: "image/jpeg",
            transparent: !1
        },
        initialize: function (a, b) {
            this._url = a;
            var c = d.extend({}, this.defaultWmsParams),
                e = b.tileSize || this.options.tileSize;
            c.width = c.height = b.detectRetina && d.Browser.retina ? 2 * e :
                e;
            for (var g in b) this.options.hasOwnProperty(g) || "crs" === g || (c[g] = b[g]);
            this.wmsParams = c;
            d.setOptions(this, b)
        },
        onAdd: function (a) {
            this._crs = this.options.crs || a.options.crs;
            this._wmsVersion = parseFloat(this.wmsParams.version);
            this.wmsParams[1.3 <= this._wmsVersion ? "crs" : "srs"] = this._crs.code;
            d.TileLayer.prototype.onAdd.call(this, a)
        },
        getTileUrl: function (a) {
            var b = this._map,
                c = this.options.tileSize,
                e = a.multiplyBy(c),
                c = e.add([c, c]),
                e = this._crs.project(b.unproject(e, a.z)),
                b = this._crs.project(b.unproject(c, a.z)),
                b = 1.3 <= this._wmsVersion && this._crs === d.CRS.EPSG4326 ? [b.y, e.x, e.y, b.x].join() : [e.x, b.y, b.x, e.y].join();
            a = d.Util.template(this._url, {
                s: this._getSubdomain(a)
            });
            return a + d.Util.getParamString(this.wmsParams, a, !0) + "&BBOX=" + b
        },
        setParams: function (a, b) {
            return d.extend(this.wmsParams, a), b || this.redraw(), this
        }
    });
    d.tileLayer.wms = function (a, b) {
        return new d.TileLayer.WMS(a, b)
    };
    d.TileLayer.Canvas = d.TileLayer.extend({
        options: {
            async: !1
        },
        initialize: function (a) {
            d.setOptions(this, a)
        },
        redraw: function () {
            this._map && (this._reset({
                    hard: !0
                }),
                this._update());
            for (var a in this._tiles) this._redrawTile(this._tiles[a]);
            return this
        },
        _redrawTile: function (a) {
            this.drawTile(a, a._tilePoint, this._map._zoom)
        },
        _createTile: function () {
            var a = d.DomUtil.create("canvas", "leaflet-tile");
            return a.width = a.height = this.options.tileSize, a.onselectstart = a.onmousemove = d.Util.falseFn, a
        },
        _loadTile: function (a, b) {
            a._layer = this;
            a._tilePoint = b;
            this._redrawTile(a);
            this.options.async || this.tileDrawn(a)
        },
        drawTile: function () {},
        tileDrawn: function (a) {
            this._tileOnLoad.call(a)
        }
    });
    d.tileLayer.canvas = function (a) {
        return new d.TileLayer.Canvas(a)
    };
    d.ImageOverlay = d.Class.extend({
        includes: d.Mixin.Events,
        options: {
            opacity: 1
        },
        initialize: function (a, b, c) {
            this._url = a;
            this._bounds = d.latLngBounds(b);
            d.setOptions(this, c)
        },
        onAdd: function (a) {
            this._map = a;
            this._image || this._initImage();
            a._panes.overlayPane.appendChild(this._image);
            a.on("viewreset", this._reset, this);
            a.options.zoomAnimation && d.Browser.any3d && a.on("zoomanim", this._animateZoom, this);
            this._reset()
        },
        onRemove: function (a) {
            a.getPanes().overlayPane.removeChild(this._image);
            a.off("viewreset", this._reset, this);
            a.options.zoomAnimation && a.off("zoomanim", this._animateZoom, this)
        },
        addTo: function (a) {
            return a.addLayer(this), this
        },
        setOpacity: function (a) {
            return this.options.opacity = a, this._updateOpacity(), this
        },
        bringToFront: function () {
            return this._image && this._map._panes.overlayPane.appendChild(this._image), this
        },
        bringToBack: function () {
            var a = this._map._panes.overlayPane;
            return this._image && a.insertBefore(this._image, a.firstChild), this
        },
        setUrl: function (a) {
            this._url = a;
            this._image.src =
                this._url
        },
        getAttribution: function () {
            return this.options.attribution
        },
        _initImage: function () {
            this._image = d.DomUtil.create("img", "leaflet-image-layer");
            this._map.options.zoomAnimation && d.Browser.any3d ? d.DomUtil.addClass(this._image, "leaflet-zoom-animated") : d.DomUtil.addClass(this._image, "leaflet-zoom-hide");
            this._updateOpacity();
            d.extend(this._image, {
                galleryimg: "no",
                onselectstart: d.Util.falseFn,
                onmousemove: d.Util.falseFn,
                onload: d.bind(this._onImageLoad, this),
                src: this._url
            })
        },
        _animateZoom: function (a) {
            var b =
                this._map,
                c = this._image,
                e = b.getZoomScale(a.zoom),
                g = this._bounds.getNorthWest(),
                n = this._bounds.getSouthEast(),
                g = b._latLngToNewLayerPoint(g, a.zoom, a.center);
            a = b._latLngToNewLayerPoint(n, a.zoom, a.center)._subtract(g);
            a = g._add(a._multiplyBy(0.5 * (1 - 1 / e)));
            c.style[d.DomUtil.TRANSFORM] = d.DomUtil.getTranslateString(a) + " scale(" + e + ") "
        },
        _reset: function () {
            var a = this._image,
                b = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
                c = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(b);
            d.DomUtil.setPosition(a,
                b);
            a.style.width = c.x + "px";
            a.style.height = c.y + "px"
        },
        _onImageLoad: function () {
            this.fire("load")
        },
        _updateOpacity: function () {
            d.DomUtil.setOpacity(this._image, this.options.opacity)
        }
    });
    d.imageOverlay = function (a, b, c) {
        return new d.ImageOverlay(a, b, c)
    };
    d.Icon = d.Class.extend({
        options: {
            className: ""
        },
        initialize: function (a) {
            d.setOptions(this, a)
        },
        createIcon: function (a) {
            return this._createIcon("icon", a)
        },
        createShadow: function (a) {
            return this._createIcon("shadow", a)
        },
        _createIcon: function (a, b) {
            var c = this._getIconUrl(a);
            if (!c) {
                if ("icon" === a) throw Error("iconUrl not set in Icon options (see the docs).");
                return null
            }
            var d;
            return d = b && "IMG" === b.tagName ? this._createImg(c, b) : this._createImg(c), this._setIconStyles(d, a), d
        },
        _setIconStyles: function (a, b) {
            var c, e = this.options,
                g = d.point(e[b + "Size"]);
            c = d.point("shadow" === b ? e.shadowAnchor || e.iconAnchor : e.iconAnchor);
            !c && g && (c = g.divideBy(2, !0));
            a.className = "leaflet-marker-" + b + " " + e.className;
            c && (a.style.marginLeft = -c.x + "px", a.style.marginTop = -c.y + "px");
            g && (a.style.width = g.x + "px",
                a.style.height = g.y + "px")
        },
        _createImg: function (a, c) {
            return c = c || b.createElement("img"), c.src = a, c
        },
        _getIconUrl: function (a) {
            return d.Browser.retina && this.options[a + "RetinaUrl"] ? this.options[a + "RetinaUrl"] : this.options[a + "Url"]
        }
    });
    d.icon = function (a) {
        return new d.Icon(a)
    };
    d.Icon.Default = d.Icon.extend({
        options: {
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        },
        _getIconUrl: function (a) {
            var b = a + "Url";
            if (this.options[b]) return this.options[b];
            d.Browser.retina && "icon" === a && (a += "-2x");
            b = d.Icon.Default.imagePath;
            if (!b) throw Error("Couldn't autodetect L.Icon.Default.imagePath, set it manually.");
            return b + "/marker-" + a + ".png"
        }
    });
    d.Icon.Default.imagePath = function () {
        var a, c, d, e, g = b.getElementsByTagName("script"),
            n = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;
        a = 0;
        for (c = g.length; c > a; a++)
            if (d = g[a].src, d.match(n)) return e = d.split(n)[0], (e ? e + "/" : "") + "images"
    }();
    d.Marker = d.Class.extend({
        includes: d.Mixin.Events,
        options: {
            icon: new d.Icon.Default,
            title: "",
            alt: "",
            clickable: !0,
            draggable: !1,
            keyboard: !0,
            zIndexOffset: 0,
            opacity: 1,
            riseOnHover: !1,
            riseOffset: 250
        },
        initialize: function (a, b) {
            d.setOptions(this, b);
            this._latlng = d.latLng(a)
        },
        onAdd: function (a) {
            this._map = a;
            a.on("viewreset", this.update, this);
            this._initIcon();
            this.update();
            this.fire("add");
            a.options.zoomAnimation && a.options.markerZoomAnimation && a.on("zoomanim", this._animateZoom, this)
        },
        addTo: function (a) {
            return a.addLayer(this), this
        },
        onRemove: function (a) {
            this.dragging && this.dragging.disable();
            this._removeIcon();
            this._removeShadow();
            this.fire("remove");
            a.off({
                viewreset: this.update,
                zoomanim: this._animateZoom
            }, this);
            this._map = null
        },
        getLatLng: function () {
            return this._latlng
        },
        setLatLng: function (a) {
            return this._latlng = d.latLng(a), this.update(), this.fire("move", {
                latlng: this._latlng
            })
        },
        setZIndexOffset: function (a) {
            return this.options.zIndexOffset = a, this.update(), this
        },
        setIcon: function (a) {
            return this.options.icon = a, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup), this
        },
        update: function () {
            if (this._icon) {
                var a = this._map.latLngToLayerPoint(this._latlng).round();
                this._setPos(a)
            }
            return this
        },
        _initIcon: function () {
            var a = this.options,
                b = this._map,
                c = b.options.zoomAnimation && b.options.markerZoomAnimation ? "leaflet-zoom-animated" : "leaflet-zoom-hide",
                e = a.icon.createIcon(this._icon),
                b = !1;
            e !== this._icon && (this._icon && this._removeIcon(), b = !0, a.title && (e.title = a.title), a.alt && (e.alt = a.alt));
            d.DomUtil.addClass(e, c);
            a.keyboard && (e.tabIndex = "0");
            this._icon = e;
            this._initInteraction();
            a.riseOnHover && d.DomEvent.on(e, "mouseover", this._bringToFront, this).on(e, "mouseout", this._resetZIndex,
                this);
            var e = a.icon.createShadow(this._shadow),
                g = !1;
            e !== this._shadow && (this._removeShadow(), g = !0);
            e && d.DomUtil.addClass(e, c);
            this._shadow = e;
            1 > a.opacity && this._updateOpacity();
            a = this._map._panes;
            b && a.markerPane.appendChild(this._icon);
            e && g && a.shadowPane.appendChild(this._shadow)
        },
        _removeIcon: function () {
            this.options.riseOnHover && d.DomEvent.off(this._icon, "mouseover", this._bringToFront).off(this._icon, "mouseout", this._resetZIndex);
            this._map._panes.markerPane.removeChild(this._icon);
            this._icon = null
        },
        _removeShadow: function () {
            this._shadow &&
                this._map._panes.shadowPane.removeChild(this._shadow);
            this._shadow = null
        },
        _setPos: function (a) {
            d.DomUtil.setPosition(this._icon, a);
            this._shadow && d.DomUtil.setPosition(this._shadow, a);
            this._zIndex = a.y + this.options.zIndexOffset;
            this._resetZIndex()
        },
        _updateZIndex: function (a) {
            this._icon.style.zIndex = this._zIndex + a
        },
        _animateZoom: function (a) {
            a = this._map._latLngToNewLayerPoint(this._latlng, a.zoom, a.center).round();
            this._setPos(a)
        },
        _initInteraction: function () {
            if (this.options.clickable) {
                var a = this._icon,
                    b = ["dblclick",
                        "mousedown", "mouseover", "mouseout", "contextmenu"
                    ];
                d.DomUtil.addClass(a, "leaflet-clickable");
                d.DomEvent.on(a, "click", this._onMouseClick, this);
                d.DomEvent.on(a, "keypress", this._onKeyPress, this);
                for (var c = 0; c < b.length; c++) d.DomEvent.on(a, b[c], this._fireMouseEvent, this);
                d.Handler.MarkerDrag && (this.dragging = new d.Handler.MarkerDrag(this), this.options.draggable && this.dragging.enable())
            }
        },
        _onMouseClick: function (a) {
            var b = this.dragging && this.dragging.moved();
            (this.hasEventListeners(a.type) || b) && d.DomEvent.stopPropagation(a);
            b || (this.dragging && this.dragging._enabled || !this._map.dragging || !this._map.dragging.moved()) && this.fire(a.type, {
                originalEvent: a,
                latlng: this._latlng
            })
        },
        _onKeyPress: function (a) {
            13 === a.keyCode && this.fire("click", {
                originalEvent: a,
                latlng: this._latlng
            })
        },
        _fireMouseEvent: function (a) {
            this.fire(a.type, {
                originalEvent: a,
                latlng: this._latlng
            });
            "contextmenu" === a.type && this.hasEventListeners(a.type) && d.DomEvent.preventDefault(a);
            "mousedown" !== a.type ? d.DomEvent.stopPropagation(a) : d.DomEvent.preventDefault(a)
        },
        setOpacity: function (a) {
            return this.options.opacity =
                a, this._map && this._updateOpacity(), this
        },
        _updateOpacity: function () {
            d.DomUtil.setOpacity(this._icon, this.options.opacity);
            this._shadow && d.DomUtil.setOpacity(this._shadow, this.options.opacity)
        },
        _bringToFront: function () {
            this._updateZIndex(this.options.riseOffset)
        },
        _resetZIndex: function () {
            this._updateZIndex(0)
        }
    });
    d.marker = function (a, b) {
        return new d.Marker(a, b)
    };
    d.DivIcon = d.Icon.extend({
        options: {
            iconSize: [12, 12],
            className: "leaflet-div-icon",
            html: !1
        },
        createIcon: function (a) {
            a = a && "DIV" === a.tagName ? a : b.createElement("div");
            var c = this.options;
            return a.innerHTML = !1 !== c.html ? c.html : "", c.bgPos && (a.style.backgroundPosition = -c.bgPos.x + "px " + -c.bgPos.y + "px"), this._setIconStyles(a, "icon"), a
        },
        createShadow: function () {
            return null
        }
    });
    d.divIcon = function (a) {
        return new d.DivIcon(a)
    };
    d.Map.mergeOptions({
        closePopupOnClick: !0
    });
    d.Popup = d.Class.extend({
        includes: d.Mixin.Events,
        options: {
            minWidth: 50,
            maxWidth: 300,
            autoPan: !0,
            closeButton: !0,
            offset: [0, 7],
            autoPanPadding: [5, 5],
            keepInView: !1,
            className: "",
            zoomAnimation: !0
        },
        initialize: function (a,
            b) {
            d.setOptions(this, a);
            this._source = b;
            this._animated = d.Browser.any3d && this.options.zoomAnimation;
            this._isOpen = !1
        },
        onAdd: function (a) {
            this._map = a;
            this._container || this._initLayout();
            var b = a.options.fadeAnimation;
            b && d.DomUtil.setOpacity(this._container, 0);
            a._panes.popupPane.appendChild(this._container);
            a.on(this._getEvents(), this);
            this.update();
            b && d.DomUtil.setOpacity(this._container, 1);
            this.fire("open");
            a.fire("popupopen", {
                popup: this
            });
            this._source && this._source.fire("popupopen", {
                popup: this
            })
        },
        addTo: function (a) {
            return a.addLayer(this),
                this
        },
        openOn: function (a) {
            return a.openPopup(this), this
        },
        onRemove: function (a) {
            a._panes.popupPane.removeChild(this._container);
            d.Util.falseFn(this._container.offsetWidth);
            a.off(this._getEvents(), this);
            a.options.fadeAnimation && d.DomUtil.setOpacity(this._container, 0);
            this._map = null;
            this.fire("close");
            a.fire("popupclose", {
                popup: this
            });
            this._source && this._source.fire("popupclose", {
                popup: this
            })
        },
        getLatLng: function () {
            return this._latlng
        },
        setLatLng: function (a) {
            return this._latlng = d.latLng(a), this._map && (this._updatePosition(),
                this._adjustPan()), this
        },
        getContent: function () {
            return this._content
        },
        setContent: function (a) {
            return this._content = a, this.update(), this
        },
        update: function () {
            this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan())
        },
        _getEvents: function () {
            var a = {
                viewreset: this._updatePosition
            };
            return this._animated && (a.zoomanim = this._zoomAnimation), ("closeOnClick" in this.options ? this.options.closeOnClick :
                this._map.options.closePopupOnClick) && (a.preclick = this._close), this.options.keepInView && (a.moveend = this._adjustPan), a
        },
        _close: function () {
            this._map && this._map.closePopup(this)
        },
        _initLayout: function () {
            var a, b = this._container = d.DomUtil.create("div", "leaflet-popup " + this.options.className + " leaflet-zoom-" + (this._animated ? "animated" : "hide"));
            this.options.closeButton && (a = this._closeButton = d.DomUtil.create("a", "leaflet-popup-close-button", b), a.href = "#close", a.innerHTML = "&#215;", d.DomEvent.disableClickPropagation(a),
                d.DomEvent.on(a, "click", this._onCloseButtonClick, this));
            a = this._wrapper = d.DomUtil.create("div", "leaflet-popup-content-wrapper", b);
            d.DomEvent.disableClickPropagation(a);
            this._contentNode = d.DomUtil.create("div", "leaflet-popup-content", a);
            d.DomEvent.disableScrollPropagation(this._contentNode);
            d.DomEvent.on(a, "contextmenu", d.DomEvent.stopPropagation);
            this._tipContainer = d.DomUtil.create("div", "leaflet-popup-tip-container", b);
            this._tip = d.DomUtil.create("div", "leaflet-popup-tip", this._tipContainer)
        },
        _updateContent: function () {
            if (this._content) {
                if ("string" ==
                    typeof this._content) this._contentNode.innerHTML = this._content;
                else {
                    for (; this._contentNode.hasChildNodes();) this._contentNode.removeChild(this._contentNode.firstChild);
                    this._contentNode.appendChild(this._content)
                }
                this.fire("contentupdate")
            }
        },
        _updateLayout: function () {
            var a = this._contentNode,
                b = a.style;
            b.width = "";
            b.whiteSpace = "nowrap";
            var c = a.offsetWidth,
                c = Math.min(c, this.options.maxWidth),
                c = Math.max(c, this.options.minWidth);
            b.width = c + 1 + "px";
            b.whiteSpace = "";
            b.height = "";
            var c = a.offsetHeight,
                e = this.options.maxHeight;
            e && c > e ? (b.height = e + "px", d.DomUtil.addClass(a, "leaflet-popup-scrolled")) : d.DomUtil.removeClass(a, "leaflet-popup-scrolled");
            this._containerWidth = this._container.offsetWidth
        },
        _updatePosition: function () {
            if (this._map) {
                var a = this._map.latLngToLayerPoint(this._latlng),
                    b = this._animated,
                    c = d.point(this.options.offset);
                b && d.DomUtil.setPosition(this._container, a);
                this._containerBottom = -c.y - (b ? 0 : a.y);
                this._containerLeft = -Math.round(this._containerWidth / 2) + c.x + (b ? 0 : a.x);
                this._container.style.bottom = this._containerBottom +
                    "px";
                this._container.style.left = this._containerLeft + "px"
            }
        },
        _zoomAnimation: function (a) {
            a = this._map._latLngToNewLayerPoint(this._latlng, a.zoom, a.center);
            d.DomUtil.setPosition(this._container, a)
        },
        _adjustPan: function () {
            if (this.options.autoPan) {
                var a = this._map,
                    b = this._container.offsetHeight,
                    c = this._containerWidth,
                    e = new d.Point(this._containerLeft, -b - this._containerBottom);
                this._animated && e._add(d.DomUtil.getPosition(this._container));
                var e = a.layerPointToContainerPoint(e),
                    g = d.point(this.options.autoPanPadding),
                    n = d.point(this.options.autoPanPaddingTopLeft || g),
                    g = d.point(this.options.autoPanPaddingBottomRight || g),
                    r = a.getSize(),
                    s = 0,
                    t = 0;
                e.x + c + g.x > r.x && (s = e.x + c - r.x + g.x);
                0 > e.x - s - n.x && (s = e.x - n.x);
                e.y + b + g.y > r.y && (t = e.y + b - r.y + g.y);
                0 > e.y - t - n.y && (t = e.y - n.y);
                (s || t) && a.fire("autopanstart").panBy([s, t])
            }
        },
        _onCloseButtonClick: function (a) {
            this._close();
            d.DomEvent.stop(a)
        }
    });
    d.popup = function (a, b) {
        return new d.Popup(a, b)
    };
    d.Map.include({
        openPopup: function (a, b, c) {
            (this.closePopup(), a instanceof d.Popup) || (a = (new d.Popup(c)).setLatLng(b).setContent(a));
            return a._isOpen = !0, this._popup = a, this.addLayer(a)
        },
        closePopup: function (a) {
            return a && a !== this._popup || (a = this._popup, this._popup = null), a && (this.removeLayer(a), a._isOpen = !1), this
        }
    });
    d.Marker.include({
        openPopup: function () {
            return this._popup && this._map && !this._map.hasLayer(this._popup) && (this._popup.setLatLng(this._latlng), this._map.openPopup(this._popup)), this
        },
        closePopup: function () {
            return this._popup && this._popup._close(), this
        },
        togglePopup: function () {
            return this._popup && (this._popup._isOpen ? this.closePopup() :
                this.openPopup()), this
        },
        bindPopup: function (a, b) {
            var c = d.point(this.options.icon.options.popupAnchor || [0, 0]);
            return c = c.add(d.Popup.prototype.options.offset), b && b.offset && (c = c.add(b.offset)), b = d.extend({
                offset: c
            }, b), this._popupHandlersAdded || (this.on("click", this.togglePopup, this).on("remove", this.closePopup, this).on("move", this._movePopup, this), this._popupHandlersAdded = !0), a instanceof d.Popup ? (d.setOptions(a, b), this._popup = a) : this._popup = (new d.Popup(b, this)).setContent(a), this
        },
        setPopupContent: function (a) {
            return this._popup &&
                this._popup.setContent(a), this
        },
        unbindPopup: function () {
            return this._popup && (this._popup = null, this.off("click", this.togglePopup, this).off("remove", this.closePopup, this).off("move", this._movePopup, this), this._popupHandlersAdded = !1), this
        },
        getPopup: function () {
            return this._popup
        },
        _movePopup: function (a) {
            this._popup.setLatLng(a.latlng)
        }
    });
    d.LayerGroup = d.Class.extend({
        initialize: function (a) {
            this._layers = {};
            var b, c;
            if (a)
                for (b = 0, c = a.length; c > b; b++) this.addLayer(a[b])
        },
        addLayer: function (a) {
            var b = this.getLayerId(a);
            return this._layers[b] = a, this._map && this._map.addLayer(a), this
        },
        removeLayer: function (a) {
            a = a in this._layers ? a : this.getLayerId(a);
            return this._map && this._layers[a] && this._map.removeLayer(this._layers[a]), delete this._layers[a], this
        },
        hasLayer: function (a) {
            return a ? a in this._layers || this.getLayerId(a) in this._layers : !1
        },
        clearLayers: function () {
            return this.eachLayer(this.removeLayer, this), this
        },
        invoke: function (a) {
            var b, c, d = Array.prototype.slice.call(arguments, 1);
            for (b in this._layers) c = this._layers[b],
                c[a] && c[a].apply(c, d);
            return this
        },
        onAdd: function (a) {
            this._map = a;
            this.eachLayer(a.addLayer, a)
        },
        onRemove: function (a) {
            this.eachLayer(a.removeLayer, a);
            this._map = null
        },
        addTo: function (a) {
            return a.addLayer(this), this
        },
        eachLayer: function (a, b) {
            for (var c in this._layers) a.call(b, this._layers[c]);
            return this
        },
        getLayer: function (a) {
            return this._layers[a]
        },
        getLayers: function () {
            var a = [],
                b;
            for (b in this._layers) a.push(this._layers[b]);
            return a
        },
        setZIndex: function (a) {
            return this.invoke("setZIndex", a)
        },
        getLayerId: function (a) {
            return d.stamp(a)
        }
    });
    d.layerGroup = function (a) {
        return new d.LayerGroup(a)
    };
    d.FeatureGroup = d.LayerGroup.extend({
        includes: d.Mixin.Events,
        statics: {
            EVENTS: "click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose"
        },
        addLayer: function (a) {
            return this.hasLayer(a) ? this : ("on" in a && a.on(d.FeatureGroup.EVENTS, this._propagateEvent, this), d.LayerGroup.prototype.addLayer.call(this, a), this._popupContent && a.bindPopup && a.bindPopup(this._popupContent, this._popupOptions), this.fire("layeradd", {
                layer: a
            }))
        },
        removeLayer: function (a) {
            return this.hasLayer(a) ?
                (a in this._layers && (a = this._layers[a]), a.off(d.FeatureGroup.EVENTS, this._propagateEvent, this), d.LayerGroup.prototype.removeLayer.call(this, a), this._popupContent && this.invoke("unbindPopup"), this.fire("layerremove", {
                    layer: a
                })) : this
        },
        bindPopup: function (a, b) {
            return this._popupContent = a, this._popupOptions = b, this.invoke("bindPopup", a, b)
        },
        openPopup: function (a) {
            for (var b in this._layers) {
                this._layers[b].openPopup(a);
                break
            }
            return this
        },
        setStyle: function (a) {
            return this.invoke("setStyle", a)
        },
        bringToFront: function () {
            return this.invoke("bringToFront")
        },
        bringToBack: function () {
            return this.invoke("bringToBack")
        },
        getBounds: function () {
            var a = new d.LatLngBounds;
            return this.eachLayer(function (b) {
                a.extend(b instanceof d.Marker ? b.getLatLng() : b.getBounds())
            }), a
        },
        _propagateEvent: function (a) {
            a = d.extend({
                layer: a.target,
                target: this
            }, a);
            this.fire(a.type, a)
        }
    });
    d.featureGroup = function (a) {
        return new d.FeatureGroup(a)
    };
    d.Path = d.Class.extend({
        includes: [d.Mixin.Events],
        statics: {
            CLIP_PADDING: function () {
                var b = ((d.Browser.mobile ? 1280 : 2E3) / Math.max(a.outerWidth, a.outerHeight) -
                    1) / 2;
                return Math.max(0, Math.min(0.5, b))
            }()
        },
        options: {
            stroke: !0,
            color: "#0033ff",
            dashArray: null,
            lineCap: null,
            lineJoin: null,
            weight: 5,
            opacity: 0.5,
            fill: !1,
            fillColor: null,
            fillOpacity: 0.2,
            clickable: !0
        },
        initialize: function (a) {
            d.setOptions(this, a)
        },
        onAdd: function (a) {
            this._map = a;
            this._container || (this._initElements(), this._initEvents());
            this.projectLatlngs();
            this._updatePath();
            this._container && this._map._pathRoot.appendChild(this._container);
            this.fire("add");
            a.on({
                    viewreset: this.projectLatlngs,
                    moveend: this._updatePath
                },
                this)
        },
        addTo: function (a) {
            return a.addLayer(this), this
        },
        onRemove: function (a) {
            a._pathRoot.removeChild(this._container);
            this.fire("remove");
            this._map = null;
            d.Browser.vml && (this._container = null, this._stroke = null, this._fill = null);
            a.off({
                viewreset: this.projectLatlngs,
                moveend: this._updatePath
            }, this)
        },
        projectLatlngs: function () {},
        setStyle: function (a) {
            return d.setOptions(this, a), this._container && this._updateStyle(), this
        },
        redraw: function () {
            return this._map && (this.projectLatlngs(), this._updatePath()), this
        }
    });
    d.Map.include({
        _updatePathViewport: function () {
            var a = d.Path.CLIP_PADDING,
                b = this.getSize(),
                c = d.DomUtil.getPosition(this._mapPane).multiplyBy(-1)._subtract(b.multiplyBy(a)._round()),
                a = c.add(b.multiplyBy(1 + 2 * a)._round());
            this._pathViewport = new d.Bounds(c, a)
        }
    });
    d.Path.SVG_NS = "http://www.w3.org/2000/svg";
    d.Browser.svg = !(!b.createElementNS || !b.createElementNS(d.Path.SVG_NS, "svg").createSVGRect);
    d.Path = d.Path.extend({
        statics: {
            SVG: d.Browser.svg
        },
        bringToFront: function () {
            var a = this._map._pathRoot,
                b = this._container;
            return b && a.lastChild !== b && a.appendChild(b), this
        },
        bringToBack: function () {
            var a = this._map._pathRoot,
                b = this._container,
                c = a.firstChild;
            return b && c !== b && a.insertBefore(b, c), this
        },
        getPathString: function () {},
        _createElement: function (a) {
            return b.createElementNS(d.Path.SVG_NS, a)
        },
        _initElements: function () {
            this._map._initPathRoot();
            this._initPath();
            this._initStyle()
        },
        _initPath: function () {
            this._container = this._createElement("g");
            this._path = this._createElement("path");
            this.options.className && d.DomUtil.addClass(this._path,
                this.options.className);
            this._container.appendChild(this._path)
        },
        _initStyle: function () {
            this.options.stroke && (this._path.setAttribute("stroke-linejoin", "round"), this._path.setAttribute("stroke-linecap", "round"));
            this.options.fill && this._path.setAttribute("fill-rule", "evenodd");
            this.options.pointerEvents && this._path.setAttribute("pointer-events", this.options.pointerEvents);
            this.options.clickable || this.options.pointerEvents || this._path.setAttribute("pointer-events", "none");
            this._updateStyle()
        },
        _updateStyle: function () {
            this.options.stroke ?
                (this._path.setAttribute("stroke", this.options.color), this._path.setAttribute("stroke-opacity", this.options.opacity), this._path.setAttribute("stroke-width", this.options.weight), this.options.dashArray ? this._path.setAttribute("stroke-dasharray", this.options.dashArray) : this._path.removeAttribute("stroke-dasharray"), this.options.lineCap && this._path.setAttribute("stroke-linecap", this.options.lineCap), this.options.lineJoin && this._path.setAttribute("stroke-linejoin", this.options.lineJoin)) : this._path.setAttribute("stroke",
                "none");
            this.options.fill ? (this._path.setAttribute("fill", this.options.fillColor || this.options.color), this._path.setAttribute("fill-opacity", this.options.fillOpacity)) : this._path.setAttribute("fill", "none")
        },
        _updatePath: function () {
            var a = this.getPathString();
            a || (a = "M0 0");
            this._path.setAttribute("d", a)
        },
        _initEvents: function () {
            if (this.options.clickable) {
                !d.Browser.svg && d.Browser.vml || d.DomUtil.addClass(this._path, "leaflet-clickable");
                d.DomEvent.on(this._container, "click", this._onMouseClick, this);
                for (var a =
                    "dblclick mousedown mouseover mouseout mousemove contextmenu".split(" "), b = 0; b < a.length; b++) d.DomEvent.on(this._container, a[b], this._fireMouseEvent, this)
            }
        },
        _onMouseClick: function (a) {
            this._map.dragging && this._map.dragging.moved() || this._fireMouseEvent(a)
        },
        _fireMouseEvent: function (a) {
            if (this.hasEventListeners(a.type)) {
                var b = this._map,
                    c = b.mouseEventToContainerPoint(a),
                    e = b.containerPointToLayerPoint(c),
                    b = b.layerPointToLatLng(e);
                this.fire(a.type, {
                    latlng: b,
                    layerPoint: e,
                    containerPoint: c,
                    originalEvent: a
                });
                "contextmenu" === a.type && d.DomEvent.preventDefault(a);
                "mousemove" !== a.type && d.DomEvent.stopPropagation(a)
            }
        }
    });
    d.Map.include({
        _initPathRoot: function () {
            this._pathRoot || (this._pathRoot = d.Path.prototype._createElement("svg"), this._panes.overlayPane.appendChild(this._pathRoot), this.options.zoomAnimation && d.Browser.any3d ? (d.DomUtil.addClass(this._pathRoot, "leaflet-zoom-animated"), this.on({
                zoomanim: this._animatePathZoom,
                zoomend: this._endPathZoom
            })) : d.DomUtil.addClass(this._pathRoot, "leaflet-zoom-hide"), this.on("moveend",
                this._updateSvgViewport), this._updateSvgViewport())
        },
        _animatePathZoom: function (a) {
            var b = this.getZoomScale(a.zoom);
            a = this._getCenterOffset(a.center)._multiplyBy(-b)._add(this._pathViewport.min);
            this._pathRoot.style[d.DomUtil.TRANSFORM] = d.DomUtil.getTranslateString(a) + " scale(" + b + ") ";
            this._pathZooming = !0
        },
        _endPathZoom: function () {
            this._pathZooming = !1
        },
        _updateSvgViewport: function () {
            if (!this._pathZooming) {
                this._updatePathViewport();
                var a = this._pathViewport,
                    b = a.min,
                    c = a.max,
                    a = c.x - b.x,
                    c = c.y - b.y,
                    e = this._pathRoot,
                    g = this._panes.overlayPane;
                d.Browser.mobileWebkit && g.removeChild(e);
                d.DomUtil.setPosition(e, b);
                e.setAttribute("width", a);
                e.setAttribute("height", c);
                e.setAttribute("viewBox", [b.x, b.y, a, c].join(" "));
                d.Browser.mobileWebkit && g.appendChild(e)
            }
        }
    });
    d.Path.include({
        bindPopup: function (a, b) {
            return a instanceof d.Popup ? this._popup = a : ((!this._popup || b) && (this._popup = new d.Popup(b, this)), this._popup.setContent(a)), this._popupHandlersAdded || (this.on("click", this._openPopup, this).on("remove", this.closePopup, this),
                this._popupHandlersAdded = !0), this
        },
        unbindPopup: function () {
            return this._popup && (this._popup = null, this.off("click", this._openPopup).off("remove", this.closePopup), this._popupHandlersAdded = !1), this
        },
        openPopup: function (a) {
            return this._popup && (a = a || this._latlng || this._latlngs[Math.floor(this._latlngs.length / 2)], this._openPopup({
                latlng: a
            })), this
        },
        closePopup: function () {
            return this._popup && this._popup._close(), this
        },
        _openPopup: function (a) {
            this._popup.setLatLng(a.latlng);
            this._map.openPopup(this._popup)
        }
    });
    d.Browser.vml = !d.Browser.svg && function () {
        try {
            var a = b.createElement("div");
            a.innerHTML = '<v:shape adj="1"/>';
            var c = a.firstChild;
            return c.style.behavior = "url(#default#VML)", c && "object" == typeof c.adj
        } catch (d) {
            return !1
        }
    }();
    d.Path = d.Browser.svg || !d.Browser.vml ? d.Path : d.Path.extend({
        statics: {
            VML: !0,
            CLIP_PADDING: 0.02
        },
        _createElement: function () {
            try {
                return b.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"),
                    function (a) {
                        return b.createElement("<lvml:" + a + ' class="lvml">')
                    }
            } catch (a) {
                return function (a) {
                    return b.createElement("<" +
                        a + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')
                }
            }
        }(),
        _initPath: function () {
            var a = this._container = this._createElement("shape");
            d.DomUtil.addClass(a, "leaflet-vml-shape" + (this.options.className ? " " + this.options.className : ""));
            this.options.clickable && d.DomUtil.addClass(a, "leaflet-clickable");
            a.coordsize = "1 1";
            this._path = this._createElement("path");
            a.appendChild(this._path);
            this._map._pathRoot.appendChild(a)
        },
        _initStyle: function () {
            this._updateStyle()
        },
        _updateStyle: function () {
            var a = this._stroke,
                b = this._fill,
                c = this.options,
                e = this._container;
            e.stroked = c.stroke;
            e.filled = c.fill;
            c.stroke ? (a || (a = this._stroke = this._createElement("stroke"), a.endcap = "round", e.appendChild(a)), a.weight = c.weight + "px", a.color = c.color, a.opacity = c.opacity, a.dashStyle = c.dashArray ? d.Util.isArray(c.dashArray) ? c.dashArray.join(" ") : c.dashArray.replace(/( *, *)/g, " ") : "", c.lineCap && (a.endcap = c.lineCap.replace("butt", "flat")), c.lineJoin && (a.joinstyle = c.lineJoin)) : a && (e.removeChild(a), this._stroke = null);
            c.fill ? (b || (b = this._fill =
                this._createElement("fill"), e.appendChild(b)), b.color = c.fillColor || c.color, b.opacity = c.fillOpacity) : b && (e.removeChild(b), this._fill = null)
        },
        _updatePath: function () {
            var a = this._container.style;
            a.display = "none";
            this._path.v = this.getPathString() + " ";
            a.display = ""
        }
    });
    d.Map.include(d.Browser.svg || !d.Browser.vml ? {} : {
        _initPathRoot: function () {
            if (!this._pathRoot) {
                var a = this._pathRoot = b.createElement("div");
                a.className = "leaflet-vml-container";
                this._panes.overlayPane.appendChild(a);
                this.on("moveend", this._updatePathViewport);
                this._updatePathViewport()
            }
        }
    });
    d.Browser.canvas = !!b.createElement("canvas").getContext;
    d.Path = d.Path.SVG && !a.L_PREFER_CANVAS || !d.Browser.canvas ? d.Path : d.Path.extend({
        statics: {
            CANVAS: !0,
            SVG: !1
        },
        redraw: function () {
            return this._map && (this.projectLatlngs(), this._requestUpdate()), this
        },
        setStyle: function (a) {
            return d.setOptions(this, a), this._map && (this._updateStyle(), this._requestUpdate()), this
        },
        onRemove: function (a) {
            a.off("viewreset", this.projectLatlngs, this).off("moveend", this._updatePath, this);
            this.options.clickable &&
                (this._map.off("click", this._onClick, this), this._map.off("mousemove", this._onMouseMove, this));
            this._requestUpdate();
            this._map = null
        },
        _requestUpdate: function () {
            this._map && !d.Path._updateRequest && (d.Path._updateRequest = d.Util.requestAnimFrame(this._fireMapMoveEnd, this._map))
        },
        _fireMapMoveEnd: function () {
            d.Path._updateRequest = null;
            this.fire("moveend")
        },
        _initElements: function () {
            this._map._initPathRoot();
            this._ctx = this._map._canvasCtx
        },
        _updateStyle: function () {
            var a = this.options;
            a.stroke && (this._ctx.lineWidth =
                a.weight, this._ctx.strokeStyle = a.color);
            a.fill && (this._ctx.fillStyle = a.fillColor || a.color)
        },
        _drawPath: function () {
            var a, b, c, e, g, n;
            this._ctx.beginPath();
            a = 0;
            for (c = this._parts.length; c > a; a++) {
                b = 0;
                for (e = this._parts[a].length; e > b; b++) g = this._parts[a][b], n = (0 === b ? "move" : "line") + "To", this._ctx[n](g.x, g.y);
                this instanceof d.Polygon && this._ctx.closePath()
            }
        },
        _checkIfEmpty: function () {
            return !this._parts.length
        },
        _updatePath: function () {
            if (!this._checkIfEmpty()) {
                var a = this._ctx,
                    b = this.options;
                this._drawPath();
                a.save();
                this._updateStyle();
                b.fill && (a.globalAlpha = b.fillOpacity, a.fill());
                b.stroke && (a.globalAlpha = b.opacity, a.stroke());
                a.restore()
            }
        },
        _initEvents: function () {
            this.options.clickable && (this._map.on("mousemove", this._onMouseMove, this), this._map.on("click", this._onClick, this))
        },
        _onClick: function (a) {
            this._containsPoint(a.layerPoint) && this.fire("click", a)
        },
        _onMouseMove: function (a) {
            this._map && !this._map._animatingZoom && (this._containsPoint(a.layerPoint) ? (this._ctx.canvas.style.cursor = "pointer", this._mouseInside = !0, this.fire("mouseover", a)) : this._mouseInside && (this._ctx.canvas.style.cursor = "", this._mouseInside = !1, this.fire("mouseout", a)))
        }
    });
    d.Map.include(d.Path.SVG && !a.L_PREFER_CANVAS || !d.Browser.canvas ? {} : {
        _initPathRoot: function () {
            var a, c = this._pathRoot;
            c || (c = this._pathRoot = b.createElement("canvas"), c.style.position = "absolute", a = this._canvasCtx = c.getContext("2d"), a.lineCap = "round", a.lineJoin = "round", this._panes.overlayPane.appendChild(c), this.options.zoomAnimation && (this._pathRoot.className = "leaflet-zoom-animated",
                this.on("zoomanim", this._animatePathZoom), this.on("zoomend", this._endPathZoom)), this.on("moveend", this._updateCanvasViewport), this._updateCanvasViewport())
        },
        _updateCanvasViewport: function () {
            if (!this._pathZooming) {
                this._updatePathViewport();
                var a = this._pathViewport,
                    b = a.min,
                    a = a.max.subtract(b),
                    c = this._pathRoot;
                d.DomUtil.setPosition(c, b);
                c.width = a.x;
                c.height = a.y;
                c.getContext("2d").translate(-b.x, -b.y)
            }
        }
    });
    d.LineUtil = {
        simplify: function (a, b) {
            if (!b || !a.length) return a.slice();
            var c = b * b;
            return a = this._reducePoints(a,
                c), this._simplifyDP(a, c)
        },
        pointToSegmentDistance: function (a, b, c) {
            return Math.sqrt(this._sqClosestPointOnSegment(a, b, c, !0))
        },
        closestPointOnSegment: function (a, b, c) {
            return this._sqClosestPointOnSegment(a, b, c)
        },
        _simplifyDP: function (a, b) {
            var d = a.length,
                e = new(typeof Uint8Array != c + "" ? Uint8Array : Array)(d);
            e[0] = e[d - 1] = 1;
            this._simplifyDPStep(a, e, b, 0, d - 1);
            var g, n = [];
            for (g = 0; d > g; g++) e[g] && n.push(a[g]);
            return n
        },
        _simplifyDPStep: function (a, b, c, d, e) {
            var g, r, s, t = 0;
            for (r = d + 1; e - 1 >= r; r++) s = this._sqClosestPointOnSegment(a[r],
                a[d], a[e], !0), s > t && (g = r, t = s);
            t > c && (b[g] = 1, this._simplifyDPStep(a, b, c, d, g), this._simplifyDPStep(a, b, c, g, e))
        },
        _reducePoints: function (a, b) {
            for (var c = [a[0]], d = 1, e = 0, g = a.length; g > d; d++) this._sqDist(a[d], a[e]) > b && (c.push(a[d]), e = d);
            return g - 1 > e && c.push(a[g - 1]), c
        },
        clipSegment: function (a, b, c, d) {
            var e, g, r = d ? this._lastCode : this._getBitCode(a, c),
                s = this._getBitCode(b, c);
            for (this._lastCode = s;;) {
                if (!(r | s)) return [a, b];
                if (r & s) return !1;
                d = r || s;
                e = this._getEdgeIntersection(a, b, d, c);
                g = this._getBitCode(e, c);
                d === r ? (a = e,
                    r = g) : (b = e, s = g)
            }
        },
        _getEdgeIntersection: function (a, b, c, e) {
            var g = b.x - a.x;
            b = b.y - a.y;
            var n = e.min;
            e = e.max;
            return 8 & c ? new d.Point(a.x + g * (e.y - a.y) / b, e.y) : 4 & c ? new d.Point(a.x + g * (n.y - a.y) / b, n.y) : 2 & c ? new d.Point(e.x, a.y + b * (e.x - a.x) / g) : 1 & c ? new d.Point(n.x, a.y + b * (n.x - a.x) / g) : void 0
        },
        _getBitCode: function (a, b) {
            var c = 0;
            return a.x < b.min.x ? c |= 1 : a.x > b.max.x && (c |= 2), a.y < b.min.y ? c |= 4 : a.y > b.max.y && (c |= 8), c
        },
        _sqDist: function (a, b) {
            var c = b.x - a.x,
                d = b.y - a.y;
            return c * c + d * d
        },
        _sqClosestPointOnSegment: function (a, b, c, e) {
            var g, n =
                b.x;
            b = b.y;
            var r = c.x - n,
                s = c.y - b,
                t = r * r + s * s;
            return 0 < t && (g = ((a.x - n) * r + (a.y - b) * s) / t, 1 < g ? (n = c.x, b = c.y) : 0 < g && (n += r * g, b += s * g)), r = a.x - n, s = a.y - b, e ? r * r + s * s : new d.Point(n, b)
        }
    };
    d.Polyline = d.Path.extend({
        initialize: function (a, b) {
            d.Path.prototype.initialize.call(this, b);
            this._latlngs = this._convertLatLngs(a)
        },
        options: {
            smoothFactor: 1,
            noClip: !1
        },
        projectLatlngs: function () {
            this._originalPoints = [];
            for (var a = 0, b = this._latlngs.length; b > a; a++) this._originalPoints[a] = this._map.latLngToLayerPoint(this._latlngs[a])
        },
        getPathString: function () {
            for (var a =
                0, b = this._parts.length, c = ""; b > a; a++) c += this._getPathPartStr(this._parts[a]);
            return c
        },
        getLatLngs: function () {
            return this._latlngs
        },
        setLatLngs: function (a) {
            return this._latlngs = this._convertLatLngs(a), this.redraw()
        },
        addLatLng: function (a) {
            return this._latlngs.push(d.latLng(a)), this.redraw()
        },
        spliceLatLngs: function () {
            var a = [].splice.apply(this._latlngs, arguments);
            return this._convertLatLngs(this._latlngs, !0), this.redraw(), a
        },
        closestLayerPoint: function (a) {
            for (var b, c, e = 1 / 0, g = this._parts, n = null, r = 0, s = g.length; s >
                r; r++)
                for (var t = g[r], p = 1, u = t.length; u > p; p++) {
                    b = t[p - 1];
                    c = t[p];
                    var v = d.LineUtil._sqClosestPointOnSegment(a, b, c, !0);
                    e > v && (e = v, n = d.LineUtil._sqClosestPointOnSegment(a, b, c))
                }
            return n && (n.distance = Math.sqrt(e)), n
        },
        getBounds: function () {
            return new d.LatLngBounds(this.getLatLngs())
        },
        _convertLatLngs: function (a, b) {
            var c, e, g = b ? a : [];
            c = 0;
            for (e = a.length; e > c; c++) {
                if (d.Util.isArray(a[c]) && "number" != typeof a[c][0]) return;
                g[c] = d.latLng(a[c])
            }
            return g
        },
        _initEvents: function () {
            d.Path.prototype._initEvents.call(this)
        },
        _getPathPartStr: function (a) {
            for (var b, c = d.Path.VML, e = 0, g = a.length, n = ""; g > e; e++) b = a[e], c && b._round(), n += (e ? "L" : "M") + b.x + " " + b.y;
            return n
        },
        _clipPoints: function () {
            var a, b, c, e = this._originalPoints,
                g = e.length;
            if (this.options.noClip) return void(this._parts = [e]);
            var n = this._parts = [],
                r = this._map._pathViewport,
                s = d.LineUtil;
            for (b = a = 0; g - 1 > a; a++)(c = s.clipSegment(e[a], e[a + 1], r, a)) && (n[b] = n[b] || [], n[b].push(c[0]), (c[1] !== e[a + 1] || a === g - 2) && (n[b].push(c[1]), b++))
        },
        _simplifyPoints: function () {
            for (var a = this._parts,
                b = d.LineUtil, c = 0, e = a.length; e > c; c++) a[c] = b.simplify(a[c], this.options.smoothFactor)
        },
        _updatePath: function () {
            this._map && (this._clipPoints(), this._simplifyPoints(), d.Path.prototype._updatePath.call(this))
        }
    });
    d.polyline = function (a, b) {
        return new d.Polyline(a, b)
    };
    d.PolyUtil = {};
    d.PolyUtil.clipPolygon = function (a, b) {
        var c, e, g, n, r, s, t, p, u = [1, 4, 2, 8],
            v = d.LineUtil;
        e = 0;
        for (s = a.length; s > e; e++) a[e]._code = v._getBitCode(a[e], b);
        for (n = 0; 4 > n; n++) {
            t = u[n];
            c = [];
            e = 0;
            s = a.length;
            for (g = s - 1; s > e; g = e++) r = a[e], g = a[g], r._code &
                t ? g._code & t || (p = v._getEdgeIntersection(g, r, t, b), p._code = v._getBitCode(p, b), c.push(p)) : (g._code & t && (p = v._getEdgeIntersection(g, r, t, b), p._code = v._getBitCode(p, b), c.push(p)), c.push(r));
            a = c
        }
        return a
    };
    d.Polygon = d.Polyline.extend({
        options: {
            fill: !0
        },
        initialize: function (a, b) {
            d.Polyline.prototype.initialize.call(this, a, b);
            this._initWithHoles(a)
        },
        _initWithHoles: function (a) {
            var b, c;
            if (a && d.Util.isArray(a[0]) && "number" != typeof a[0][0])
                for (this._latlngs = this._convertLatLngs(a[0]), this._holes = a.slice(1), a = 0, b =
                    this._holes.length; b > a; a++) c = this._holes[a] = this._convertLatLngs(this._holes[a]), c[0].equals(c[c.length - 1]) && c.pop();
            a = this._latlngs;
            2 <= a.length && a[0].equals(a[a.length - 1]) && a.pop()
        },
        projectLatlngs: function () {
            if (d.Polyline.prototype.projectLatlngs.call(this), this._holePoints = [], this._holes) {
                var a, b, c, e;
                a = 0;
                for (c = this._holes.length; c > a; a++)
                    for (this._holePoints[a] = [], b = 0, e = this._holes[a].length; e > b; b++) this._holePoints[a][b] = this._map.latLngToLayerPoint(this._holes[a][b])
            }
        },
        setLatLngs: function (a) {
            return a &&
                d.Util.isArray(a[0]) && "number" != typeof a[0][0] ? (this._initWithHoles(a), this.redraw()) : d.Polyline.prototype.setLatLngs.call(this, a)
        },
        _clipPoints: function () {
            var a = [];
            if (this._parts = [this._originalPoints].concat(this._holePoints), !this.options.noClip) {
                for (var b = 0, c = this._parts.length; c > b; b++) {
                    var e = d.PolyUtil.clipPolygon(this._parts[b], this._map._pathViewport);
                    e.length && a.push(e)
                }
                this._parts = a
            }
        },
        _getPathPartStr: function (a) {
            return d.Polyline.prototype._getPathPartStr.call(this, a) + (d.Browser.svg ? "z" : "x")
        }
    });
    d.polygon = function (a, b) {
        return new d.Polygon(a, b)
    };
    (function () {
        function a(b) {
            return d.FeatureGroup.extend({
                initialize: function (a, b) {
                    this._layers = {};
                    this._options = b;
                    this.setLatLngs(a)
                },
                setLatLngs: function (a) {
                    var c = 0,
                        d = a.length;
                    for (this.eachLayer(function (b) {
                        d > c ? b.setLatLngs(a[c++]) : this.removeLayer(b)
                    }, this); d > c;) this.addLayer(new b(a[c++], this._options));
                    return this
                },
                getLatLngs: function () {
                    var a = [];
                    return this.eachLayer(function (b) {
                        a.push(b.getLatLngs())
                    }), a
                }
            })
        }
        d.MultiPolyline = a(d.Polyline);
        d.MultiPolygon =
            a(d.Polygon);
        d.multiPolyline = function (a, b) {
            return new d.MultiPolyline(a, b)
        };
        d.multiPolygon = function (a, b) {
            return new d.MultiPolygon(a, b)
        }
    })();
    d.Rectangle = d.Polygon.extend({
        initialize: function (a, b) {
            d.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(a), b)
        },
        setBounds: function (a) {
            this.setLatLngs(this._boundsToLatLngs(a))
        },
        _boundsToLatLngs: function (a) {
            return a = d.latLngBounds(a), [a.getSouthWest(), a.getNorthWest(), a.getNorthEast(), a.getSouthEast()]
        }
    });
    d.rectangle = function (a, b) {
        return new d.Rectangle(a,
            b)
    };
    d.Circle = d.Path.extend({
        initialize: function (a, b, c) {
            d.Path.prototype.initialize.call(this, c);
            this._latlng = d.latLng(a);
            this._mRadius = b
        },
        options: {
            fill: !0
        },
        setLatLng: function (a) {
            return this._latlng = d.latLng(a), this.redraw()
        },
        setRadius: function (a) {
            return this._mRadius = a, this.redraw()
        },
        projectLatlngs: function () {
            var a = this._getLngRadius(),
                b = this._latlng,
                a = this._map.latLngToLayerPoint([b.lat, b.lng - a]);
            this._point = this._map.latLngToLayerPoint(b);
            this._radius = Math.max(this._point.x - a.x, 1)
        },
        getBounds: function () {
            var a =
                this._getLngRadius(),
                b = this._mRadius / 40075017 * 360,
                c = this._latlng;
            return new d.LatLngBounds([c.lat - b, c.lng - a], [c.lat + b, c.lng + a])
        },
        getLatLng: function () {
            return this._latlng
        },
        getPathString: function () {
            var a = this._point,
                b = this._radius;
            return this._checkIfEmpty() ? "" : d.Browser.svg ? "M" + a.x + "," + (a.y - b) + "A" + b + "," + b + ",0,1,1," + (a.x - 0.1) + "," + (a.y - b) + " z" : (a._round(), b = Math.round(b), "AL " + a.x + "," + a.y + " " + b + "," + b + " 0,23592600")
        },
        getRadius: function () {
            return this._mRadius
        },
        _getLatRadius: function () {
            return this._mRadius /
                40075017 * 360
        },
        _getLngRadius: function () {
            return this._getLatRadius() / Math.cos(d.LatLng.DEG_TO_RAD * this._latlng.lat)
        },
        _checkIfEmpty: function () {
            if (!this._map) return !1;
            var a = this._map._pathViewport,
                b = this._radius,
                c = this._point;
            return c.x - b > a.max.x || c.y - b > a.max.y || c.x + b < a.min.x || c.y + b < a.min.y
        }
    });
    d.circle = function (a, b, c) {
        return new d.Circle(a, b, c)
    };
    d.CircleMarker = d.Circle.extend({
        options: {
            radius: 10,
            weight: 2
        },
        initialize: function (a, b) {
            d.Circle.prototype.initialize.call(this, a, null, b);
            this._radius = this.options.radius
        },
        projectLatlngs: function () {
            this._point = this._map.latLngToLayerPoint(this._latlng)
        },
        _updateStyle: function () {
            d.Circle.prototype._updateStyle.call(this);
            this.setRadius(this.options.radius)
        },
        setLatLng: function (a) {
            return d.Circle.prototype.setLatLng.call(this, a), this._popup && this._popup._isOpen && this._popup.setLatLng(a), this
        },
        setRadius: function (a) {
            return this.options.radius = this._radius = a, this.redraw()
        },
        getRadius: function () {
            return this._radius
        }
    });
    d.circleMarker = function (a, b) {
        return new d.CircleMarker(a,
            b)
    };
    d.Polyline.include(d.Path.CANVAS ? {
        _containsPoint: function (a, b) {
            var c, e, g, n, r, s, t, p = this.options.weight / 2;
            d.Browser.touch && (p += 10);
            c = 0;
            for (n = this._parts.length; n > c; c++)
                for (t = this._parts[c], e = 0, r = t.length, g = r - 1; r > e; g = e++)
                    if ((b || 0 !== e) && (s = d.LineUtil.pointToSegmentDistance(a, t[g], t[e]), p >= s)) return !0;
            return !1
        }
    } : {});
    d.Polygon.include(d.Path.CANVAS ? {
        _containsPoint: function (a) {
            var b, c, e, g, n, r, s, t = !1;
            if (d.Polyline.prototype._containsPoint.call(this, a, !0)) return !0;
            g = 0;
            for (r = this._parts.length; r > g; g++)
                for (b =
                    this._parts[g], n = 0, s = b.length, e = s - 1; s > n; e = n++) c = b[n], e = b[e], c.y > a.y != e.y > a.y && a.x < (e.x - c.x) * (a.y - c.y) / (e.y - c.y) + c.x && (t = !t);
            return t
        }
    } : {});
    d.Circle.include(d.Path.CANVAS ? {
        _drawPath: function () {
            var a = this._point;
            this._ctx.beginPath();
            this._ctx.arc(a.x, a.y, this._radius, 0, 2 * Math.PI, !1)
        },
        _containsPoint: function (a) {
            var b = this.options.stroke ? this.options.weight / 2 : 0;
            return a.distanceTo(this._point) <= this._radius + b
        }
    } : {});
    d.CircleMarker.include(d.Path.CANVAS ? {
        _updateStyle: function () {
            d.Path.prototype._updateStyle.call(this)
        }
    } : {});
    d.GeoJSON = d.FeatureGroup.extend({
        initialize: function (a, b) {
            d.setOptions(this, b);
            this._layers = {};
            a && this.addData(a)
        },
        addData: function (a) {
            var b, c, e = d.Util.isArray(a) ? a : a.features;
            if (e) {
                a = 0;
                for (b = e.length; b > a; a++) c = e[a], (c.geometries || c.geometry || c.features || c.coordinates) && this.addData(e[a]);
                return this
            }
            e = this.options;
            if (!e.filter || e.filter(a)) return b = d.GeoJSON.geometryToLayer(a, e.pointToLayer, e.coordsToLatLng, e), b.feature = d.GeoJSON.asFeature(a), b.defaultOptions = b.options, this.resetStyle(b), e.onEachFeature &&
                e.onEachFeature(a, b), this.addLayer(b)
        },
        resetStyle: function (a) {
            var b = this.options.style;
            b && (d.Util.extend(a.options, a.defaultOptions), this._setLayerStyle(a, b))
        },
        setStyle: function (a) {
            this.eachLayer(function (b) {
                this._setLayerStyle(b, a)
            }, this)
        },
        _setLayerStyle: function (a, b) {
            "function" == typeof b && (b = b(a.feature));
            a.setStyle && a.setStyle(b)
        }
    });
    d.extend(d.GeoJSON, {
        geometryToLayer: function (a, b, c, e) {
            var g, n, r, s = "Feature" === a.type ? a.geometry : a,
                t = s.coordinates,
                p = [];
            switch (c = c || this.coordsToLatLng, s.type) {
            case "Point":
                return g =
                    c(t), b ? b(a, g) : new d.Marker(g);
            case "MultiPoint":
                n = 0;
                for (r = t.length; r > n; n++) g = c(t[n]), p.push(b ? b(a, g) : new d.Marker(g));
                return new d.FeatureGroup(p);
            case "LineString":
                return n = this.coordsToLatLngs(t, 0, c), new d.Polyline(n, e);
            case "Polygon":
                if (2 === t.length && !t[1].length) throw Error("Invalid GeoJSON object.");
                return n = this.coordsToLatLngs(t, 1, c), new d.Polygon(n, e);
            case "MultiLineString":
                return n = this.coordsToLatLngs(t, 1, c), new d.MultiPolyline(n, e);
            case "MultiPolygon":
                return n = this.coordsToLatLngs(t, 2,
                    c), new d.MultiPolygon(n, e);
            case "GeometryCollection":
                n = 0;
                for (r = s.geometries.length; r > n; n++) p.push(this.geometryToLayer({
                    geometry: s.geometries[n],
                    type: "Feature",
                    properties: a.properties
                }, b, c, e));
                return new d.FeatureGroup(p);
            default:
                throw Error("Invalid GeoJSON object.");
            }
        },
        coordsToLatLng: function (a) {
            return new d.LatLng(a[1], a[0], a[2])
        },
        coordsToLatLngs: function (a, b, c) {
            var d, e, g, r = [];
            e = 0;
            for (g = a.length; g > e; e++) d = b ? this.coordsToLatLngs(a[e], b - 1, c) : (c || this.coordsToLatLng)(a[e]), r.push(d);
            return r
        },
        latLngToCoords: function (a) {
            var b = [a.lng, a.lat];
            return a.alt !== c && b.push(a.alt), b
        },
        latLngsToCoords: function (a) {
            for (var b = [], c = 0, e = a.length; e > c; c++) b.push(d.GeoJSON.latLngToCoords(a[c]));
            return b
        },
        getFeature: function (a, b) {
            return a.feature ? d.extend({}, a.feature, {
                geometry: b
            }) : d.GeoJSON.asFeature(b)
        },
        asFeature: function (a) {
            return "Feature" === a.type ? a : {
                type: "Feature",
                properties: {},
                geometry: a
            }
        }
    });
    var g = {
        toGeoJSON: function () {
            return d.GeoJSON.getFeature(this, {
                type: "Point",
                coordinates: d.GeoJSON.latLngToCoords(this.getLatLng())
            })
        }
    };
    d.Marker.include(g);
    d.Circle.include(g);
    d.CircleMarker.include(g);
    d.Polyline.include({
        toGeoJSON: function () {
            return d.GeoJSON.getFeature(this, {
                type: "LineString",
                coordinates: d.GeoJSON.latLngsToCoords(this.getLatLngs())
            })
        }
    });
    d.Polygon.include({
        toGeoJSON: function () {
            var a, b, c, e = [d.GeoJSON.latLngsToCoords(this.getLatLngs())];
            if (e[0].push(e[0][0]), this._holes)
                for (a = 0, b = this._holes.length; b > a; a++) c = d.GeoJSON.latLngsToCoords(this._holes[a]), c.push(c[0]), e.push(c);
            return d.GeoJSON.getFeature(this, {
                type: "Polygon",
                coordinates: e
            })
        }
    });
    (function () {
        function a(b) {
            return function () {
                var a = [];
                return this.eachLayer(function (b) {
                    a.push(b.toGeoJSON().geometry.coordinates)
                }), d.GeoJSON.getFeature(this, {
                    type: b,
                    coordinates: a
                })
            }
        }
        d.MultiPolyline.include({
            toGeoJSON: a("MultiLineString")
        });
        d.MultiPolygon.include({
            toGeoJSON: a("MultiPolygon")
        });
        d.LayerGroup.include({
            toGeoJSON: function () {
                var b, c = this.feature && this.feature.geometry,
                    e = [];
                if (c && "MultiPoint" === c.type) return a("MultiPoint").call(this);
                var g = c && "GeometryCollection" === c.type;
                return this.eachLayer(function (a) {
                    a.toGeoJSON &&
                        (b = a.toGeoJSON(), e.push(g ? b.geometry : d.GeoJSON.asFeature(b)))
                }), g ? d.GeoJSON.getFeature(this, {
                    geometries: e,
                    type: "GeometryCollection"
                }) : {
                    type: "FeatureCollection",
                    features: e
                }
            }
        })
    })();
    d.geoJson = function (a, b) {
        return new d.GeoJSON(a, b)
    };
    d.DomEvent = {
        addListener: function (a, b, c, e) {
            var g, n, r, s = d.stamp(c),
                t = "_leaflet_" + b + s;
            return a[t] ? this : (g = function (b) {
                return c.call(e || a, b || d.DomEvent._getEvent())
            }, d.Browser.pointer && 0 === b.indexOf("touch") ? this.addPointerListener(a, b, g, s) : (d.Browser.touch && "dblclick" === b &&
                this.addDoubleTapListener && this.addDoubleTapListener(a, g, s), "addEventListener" in a ? "mousewheel" === b ? (a.addEventListener("DOMMouseScroll", g, !1), a.addEventListener(b, g, !1)) : "mouseenter" === b || "mouseleave" === b ? (n = g, r = "mouseenter" === b ? "mouseover" : "mouseout", g = function (b) {
                    return d.DomEvent._checkMouse(a, b) ? n(b) : void 0
                }, a.addEventListener(r, g, !1)) : "click" === b && d.Browser.android ? (n = g, g = function (a) {
                    return d.DomEvent._filterClick(a, n)
                }, a.addEventListener(b, g, !1)) : a.addEventListener(b, g, !1) : "attachEvent" in a &&
                a.attachEvent("on" + b, g), a[t] = g, this))
        },
        removeListener: function (a, b, c) {
            c = d.stamp(c);
            var e = "_leaflet_" + b + c,
                g = a[e];
            return g ? (d.Browser.pointer && 0 === b.indexOf("touch") ? this.removePointerListener(a, b, c) : d.Browser.touch && "dblclick" === b && this.removeDoubleTapListener ? this.removeDoubleTapListener(a, c) : "removeEventListener" in a ? "mousewheel" === b ? (a.removeEventListener("DOMMouseScroll", g, !1), a.removeEventListener(b, g, !1)) : "mouseenter" === b || "mouseleave" === b ? a.removeEventListener("mouseenter" === b ? "mouseover" : "mouseout",
                g, !1) : a.removeEventListener(b, g, !1) : "detachEvent" in a && a.detachEvent("on" + b, g), a[e] = null, this) : this
        },
        stopPropagation: function (a) {
            return a.stopPropagation ? a.stopPropagation() : a.cancelBubble = !0, d.DomEvent._skipped(a), this
        },
        disableScrollPropagation: function (a) {
            var b = d.DomEvent.stopPropagation;
            return d.DomEvent.on(a, "mousewheel", b).on(a, "MozMousePixelScroll", b)
        },
        disableClickPropagation: function (a) {
            for (var b = d.DomEvent.stopPropagation, c = d.Draggable.START.length - 1; 0 <= c; c--) d.DomEvent.on(a, d.Draggable.START[c],
                b);
            return d.DomEvent.on(a, "click", d.DomEvent._fakeStop).on(a, "dblclick", b)
        },
        preventDefault: function (a) {
            return a.preventDefault ? a.preventDefault() : a.returnValue = !1, this
        },
        stop: function (a) {
            return d.DomEvent.preventDefault(a).stopPropagation(a)
        },
        getMousePosition: function (a, b) {
            if (!b) return new d.Point(a.clientX, a.clientY);
            var c = b.getBoundingClientRect();
            return new d.Point(a.clientX - c.left - b.clientLeft, a.clientY - c.top - b.clientTop)
        },
        getWheelDelta: function (a) {
            var b = 0;
            return a.wheelDelta && (b = a.wheelDelta /
                120), a.detail && (b = -a.detail / 3), b
        },
        _skipEvents: {},
        _fakeStop: function (a) {
            d.DomEvent._skipEvents[a.type] = !0
        },
        _skipped: function (a) {
            var b = this._skipEvents[a.type];
            return this._skipEvents[a.type] = !1, b
        },
        _checkMouse: function (a, b) {
            var c = b.relatedTarget;
            if (!c) return !0;
            try {
                for (; c && c !== a;) c = c.parentNode
            } catch (d) {
                return !1
            }
            return c !== a
        },
        _getEvent: function () {
            var b = a.event;
            if (!b)
                for (var c = arguments.callee.caller; c && (b = c.arguments[0], !b || a.Event !== b.constructor);) c = c.caller;
            return b
        },
        _filterClick: function (a, b) {
            var c =
                a.timeStamp || a.originalEvent.timeStamp,
                e = d.DomEvent._lastClick && c - d.DomEvent._lastClick;
            return e && 100 < e && 1E3 > e || a.target._simulatedClick && !a._simulated ? void d.DomEvent.stop(a) : (d.DomEvent._lastClick = c, b(a))
        }
    };
    d.DomEvent.on = d.DomEvent.addListener;
    d.DomEvent.off = d.DomEvent.removeListener;
    d.Draggable = d.Class.extend({
        includes: d.Mixin.Events,
        statics: {
            START: d.Browser.touch ? ["touchstart", "mousedown"] : ["mousedown"],
            END: {
                mousedown: "mouseup",
                touchstart: "touchend",
                pointerdown: "touchend",
                MSPointerDown: "touchend"
            },
            MOVE: {
                mousedown: "mousemove",
                touchstart: "touchmove",
                pointerdown: "touchmove",
                MSPointerDown: "touchmove"
            }
        },
        initialize: function (a, b) {
            this._element = a;
            this._dragStartTarget = b || a
        },
        enable: function () {
            if (!this._enabled) {
                for (var a = d.Draggable.START.length - 1; 0 <= a; a--) d.DomEvent.on(this._dragStartTarget, d.Draggable.START[a], this._onDown, this);
                this._enabled = !0
            }
        },
        disable: function () {
            if (this._enabled) {
                for (var a = d.Draggable.START.length - 1; 0 <= a; a--) d.DomEvent.off(this._dragStartTarget, d.Draggable.START[a], this._onDown,
                    this);
                this._moved = this._enabled = !1
            }
        },
        _onDown: function (a) {
            if (this._moved = !1, !(a.shiftKey || 1 !== a.which && 1 !== a.button && !a.touches || (d.DomEvent.stopPropagation(a), d.Draggable._disabled || (d.DomUtil.disableImageDrag(), d.DomUtil.disableTextSelection(), this._moving)))) {
                var c = a.touches ? a.touches[0] : a;
                this._startPoint = new d.Point(c.clientX, c.clientY);
                this._startPos = this._newPos = d.DomUtil.getPosition(this._element);
                d.DomEvent.on(b, d.Draggable.MOVE[a.type], this._onMove, this).on(b, d.Draggable.END[a.type], this._onUp,
                    this)
            }
        },
        _onMove: function (a) {
            if (a.touches && 1 < a.touches.length) return void(this._moved = !0);
            var c = a.touches && 1 === a.touches.length ? a.touches[0] : a,
                c = (new d.Point(c.clientX, c.clientY)).subtract(this._startPoint);
            (c.x || c.y) && (d.DomEvent.preventDefault(a), this._moved || (this.fire("dragstart"), this._moved = !0, this._startPos = d.DomUtil.getPosition(this._element).subtract(c), d.DomUtil.addClass(b.body, "leaflet-dragging"), d.DomUtil.addClass(a.target || a.srcElement, "leaflet-drag-target")), this._newPos = this._startPos.add(c),
                this._moving = !0, d.Util.cancelAnimFrame(this._animRequest), this._animRequest = d.Util.requestAnimFrame(this._updatePosition, this, !0, this._dragStartTarget))
        },
        _updatePosition: function () {
            this.fire("predrag");
            d.DomUtil.setPosition(this._element, this._newPos);
            this.fire("drag")
        },
        _onUp: function (a) {
            d.DomUtil.removeClass(b.body, "leaflet-dragging");
            d.DomUtil.removeClass(a.target || a.srcElement, "leaflet-drag-target");
            for (var c in d.Draggable.MOVE) d.DomEvent.off(b, d.Draggable.MOVE[c], this._onMove).off(b, d.Draggable.END[c],
                this._onUp);
            d.DomUtil.enableImageDrag();
            d.DomUtil.enableTextSelection();
            this._moved && this._moving && (d.Util.cancelAnimFrame(this._animRequest), this.fire("dragend", {
                distance: this._newPos.distanceTo(this._startPos)
            }));
            this._moving = !1
        }
    });
    d.Handler = d.Class.extend({
        initialize: function (a) {
            this._map = a
        },
        enable: function () {
            this._enabled || (this._enabled = !0, this.addHooks())
        },
        disable: function () {
            this._enabled && (this._enabled = !1, this.removeHooks())
        },
        enabled: function () {
            return !!this._enabled
        }
    });
    d.Map.mergeOptions({
        dragging: !0,
        inertia: !d.Browser.android23,
        inertiaDeceleration: 3400,
        inertiaMaxSpeed: 1 / 0,
        inertiaThreshold: d.Browser.touch ? 32 : 18,
        easeLinearity: 0.25,
        worldCopyJump: !1
    });
    d.Map.Drag = d.Handler.extend({
        addHooks: function () {
            if (!this._draggable) {
                var a = this._map;
                this._draggable = new d.Draggable(a._mapPane, a._container);
                this._draggable.on({
                    dragstart: this._onDragStart,
                    drag: this._onDrag,
                    dragend: this._onDragEnd
                }, this);
                a.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDrag, this), a.on("viewreset", this._onViewReset,
                    this), a.whenReady(this._onViewReset, this))
            }
            this._draggable.enable()
        },
        removeHooks: function () {
            this._draggable.disable()
        },
        moved: function () {
            return this._draggable && this._draggable._moved
        },
        _onDragStart: function () {
            var a = this._map;
            a._panAnim && a._panAnim.stop();
            a.fire("movestart").fire("dragstart");
            a.options.inertia && (this._positions = [], this._times = [])
        },
        _onDrag: function () {
            if (this._map.options.inertia) {
                var a = this._lastTime = +new Date,
                    b = this._lastPos = this._draggable._newPos;
                this._positions.push(b);
                this._times.push(a);
                200 < a - this._times[0] && (this._positions.shift(), this._times.shift())
            }
            this._map.fire("move").fire("drag")
        },
        _onViewReset: function () {
            var a = this._map.getSize()._divideBy(2);
            this._initialWorldOffset = this._map.latLngToLayerPoint([0, 0]).subtract(a).x;
            this._worldWidth = this._map.project([0, 180]).x
        },
        _onPreDrag: function () {
            var a = this._worldWidth,
                b = Math.round(a / 2),
                c = this._initialWorldOffset,
                d = this._draggable._newPos.x,
                e = (d - b + c) % a + b - c,
                a = (d + b + c) % a - b - c,
                c = Math.abs(e + c) < Math.abs(a + c) ? e : a;
            this._draggable._newPos.x = c
        },
        _onDragEnd: function (a) {
            var b = this._map,
                c = b.options,
                e = +new Date - this._lastTime,
                g = !c.inertia || e > c.inertiaThreshold || !this._positions[0];
            if (b.fire("dragend", a), g) b.fire("moveend");
            else {
                a = this._lastPos.subtract(this._positions[0]);
                var n = c.easeLinearity;
                a = a.multiplyBy(n / ((this._lastTime + e - this._times[0]) / 1E3));
                g = a.distanceTo([0, 0]);
                e = Math.min(c.inertiaMaxSpeed, g);
                a = a.multiplyBy(e / g);
                var r = e / (c.inertiaDeceleration * n),
                    s = a.multiplyBy(-r / 2).round();
                s.x && s.y ? (s = b._limitOffset(s, b.options.maxBounds), d.Util.requestAnimFrame(function () {
                    b.panBy(s, {
                        duration: r,
                        easeLinearity: n,
                        noMoveStart: !0
                    })
                })) : b.fire("moveend")
            }
        }
    });
    d.Map.addInitHook("addHandler", "dragging", d.Map.Drag);
    d.Map.mergeOptions({
        doubleClickZoom: !0
    });
    d.Map.DoubleClickZoom = d.Handler.extend({
        addHooks: function () {
            this._map.on("dblclick", this._onDoubleClick, this)
        },
        removeHooks: function () {
            this._map.off("dblclick", this._onDoubleClick, this)
        },
        _onDoubleClick: function (a) {
            var b = this._map,
                c = b.getZoom() + (a.originalEvent.shiftKey ? -1 : 1);
            "center" === b.options.doubleClickZoom ? b.setZoom(c) : b.setZoomAround(a.containerPoint,
                c)
        }
    });
    d.Map.addInitHook("addHandler", "doubleClickZoom", d.Map.DoubleClickZoom);
    d.Map.mergeOptions({
        scrollWheelZoom: !0
    });
    d.Map.ScrollWheelZoom = d.Handler.extend({
        addHooks: function () {
            d.DomEvent.on(this._map._container, "mousewheel", this._onWheelScroll, this);
            d.DomEvent.on(this._map._container, "MozMousePixelScroll", d.DomEvent.preventDefault);
            this._delta = 0
        },
        removeHooks: function () {
            d.DomEvent.off(this._map._container, "mousewheel", this._onWheelScroll);
            d.DomEvent.off(this._map._container, "MozMousePixelScroll",
                d.DomEvent.preventDefault)
        },
        _onWheelScroll: function (a) {
            var b = d.DomEvent.getWheelDelta(a);
            this._delta += b;
            this._lastMousePos = this._map.mouseEventToContainerPoint(a);
            this._startTime || (this._startTime = +new Date);
            b = Math.max(40 - (+new Date - this._startTime), 0);
            clearTimeout(this._timer);
            this._timer = setTimeout(d.bind(this._performZoom, this), b);
            d.DomEvent.preventDefault(a);
            d.DomEvent.stopPropagation(a)
        },
        _performZoom: function () {
            var a = this._map,
                b = this._delta,
                c = a.getZoom(),
                b = 0 < b ? Math.ceil(b) : Math.floor(b),
                b = Math.max(Math.min(b,
                    4), -4),
                b = a._limitZoom(c + b) - c;
            this._delta = 0;
            this._startTime = null;
            b && ("center" === a.options.scrollWheelZoom ? a.setZoom(c + b) : a.setZoomAround(this._lastMousePos, c + b))
        }
    });
    d.Map.addInitHook("addHandler", "scrollWheelZoom", d.Map.ScrollWheelZoom);
    d.extend(d.DomEvent, {
        _touchstart: d.Browser.msPointer ? "MSPointerDown" : d.Browser.pointer ? "pointerdown" : "touchstart",
        _touchend: d.Browser.msPointer ? "MSPointerUp" : d.Browser.pointer ? "pointerup" : "touchend",
        addDoubleTapListener: function (a, c, e) {
            function g(a) {
                var b;
                if (d.Browser.pointer ?
                    (v.push(a.pointerId), b = v.length) : b = a.touches.length, !(1 < b)) {
                    b = Date.now();
                    var c = b - (n || b);
                    r = a.touches ? a.touches[0] : a;
                    s = 0 < c && t >= c;
                    n = b
                }
            }

            function m(a) {
                if (d.Browser.pointer) {
                    a = v.indexOf(a.pointerId);
                    if (-1 === a) return;
                    v.splice(a, 1)
                }
                if (s) {
                    if (d.Browser.pointer) {
                        var b = {},
                            e;
                        for (e in r) a = r[e], b[e] = "function" == typeof a ? a.bind(r) : a;
                        r = b
                    }
                    r.type = "dblclick";
                    c(r);
                    n = null
                }
            }
            var n, r, s = !1,
                t = 250,
                p = this._touchstart,
                u = this._touchend,
                v = [];
            a["_leaflet_" + p + e] = g;
            a["_leaflet_" + u + e] = m;
            e = d.Browser.pointer ? b.documentElement : a;
            return a.addEventListener(p,
                g, !1), e.addEventListener(u, m, !1), d.Browser.pointer && e.addEventListener(d.DomEvent.POINTER_CANCEL, m, !1), this
        },
        removeDoubleTapListener: function (a, c) {
            return a.removeEventListener(this._touchstart, a["_leaflet_" + this._touchstart + c], !1), (d.Browser.pointer ? b.documentElement : a).removeEventListener(this._touchend, a["_leaflet_" + this._touchend + c], !1), d.Browser.pointer && b.documentElement.removeEventListener(d.DomEvent.POINTER_CANCEL, a["_leaflet_" + this._touchend + c], !1), this
        }
    });
    d.extend(d.DomEvent, {
        POINTER_DOWN: d.Browser.msPointer ?
            "MSPointerDown" : "pointerdown",
        POINTER_MOVE: d.Browser.msPointer ? "MSPointerMove" : "pointermove",
        POINTER_UP: d.Browser.msPointer ? "MSPointerUp" : "pointerup",
        POINTER_CANCEL: d.Browser.msPointer ? "MSPointerCancel" : "pointercancel",
        _pointers: [],
        _pointerDocumentListener: !1,
        addPointerListener: function (a, b, c, d) {
            switch (b) {
            case "touchstart":
                return this.addPointerListenerStart(a, b, c, d);
            case "touchend":
                return this.addPointerListenerEnd(a, b, c, d);
            case "touchmove":
                return this.addPointerListenerMove(a, b, c, d);
            default:
                throw "Unknown touch event type";
            }
        },
        addPointerListenerStart: function (a, c, e, g) {
            var m = this._pointers;
            c = function (a) {
                d.DomEvent.preventDefault(a);
                for (var b = !1, c = 0; c < m.length; c++)
                    if (m[c].pointerId === a.pointerId) {
                        b = !0;
                        break
                    }
                b || m.push(a);
                a.touches = m.slice();
                a.changedTouches = [a];
                e(a)
            };
            (a["_leaflet_touchstart" + g] = c, a.addEventListener(this.POINTER_DOWN, c, !1), this._pointerDocumentListener) || (a = function (a) {
                    for (var b = 0; b < m.length; b++)
                        if (m[b].pointerId === a.pointerId) {
                            m.splice(b, 1);
                            break
                        }
                }, b.documentElement.addEventListener(this.POINTER_UP, a, !1),
                b.documentElement.addEventListener(this.POINTER_CANCEL, a, !1), this._pointerDocumentListener = !0);
            return this
        },
        addPointerListenerMove: function (a, b, c, d) {
            function e(a) {
                if (a.pointerType !== a.MSPOINTER_TYPE_MOUSE && "mouse" !== a.pointerType || 0 !== a.buttons) {
                    for (var b = 0; b < g.length; b++)
                        if (g[b].pointerId === a.pointerId) {
                            g[b] = a;
                            break
                        }
                    a.touches = g.slice();
                    a.changedTouches = [a];
                    c(a)
                }
            }
            var g = this._pointers;
            return a["_leaflet_touchmove" + d] = e, a.addEventListener(this.POINTER_MOVE, e, !1), this
        },
        addPointerListenerEnd: function (a,
            b, c, d) {
            var e = this._pointers;
            b = function (a) {
                for (var b = 0; b < e.length; b++)
                    if (e[b].pointerId === a.pointerId) {
                        e.splice(b, 1);
                        break
                    }
                a.touches = e.slice();
                a.changedTouches = [a];
                c(a)
            };
            return a["_leaflet_touchend" + d] = b, a.addEventListener(this.POINTER_UP, b, !1), a.addEventListener(this.POINTER_CANCEL, b, !1), this
        },
        removePointerListener: function (a, b, c) {
            c = a["_leaflet_" + b + c];
            switch (b) {
            case "touchstart":
                a.removeEventListener(this.POINTER_DOWN, c, !1);
                break;
            case "touchmove":
                a.removeEventListener(this.POINTER_MOVE, c, !1);
                break;
            case "touchend":
                a.removeEventListener(this.POINTER_UP, c, !1), a.removeEventListener(this.POINTER_CANCEL, c, !1)
            }
            return this
        }
    });
    d.Map.mergeOptions({
        touchZoom: d.Browser.touch && !d.Browser.android23,
        bounceAtZoomLimits: !0
    });
    d.Map.TouchZoom = d.Handler.extend({
        addHooks: function () {
            d.DomEvent.on(this._map._container, "touchstart", this._onTouchStart, this)
        },
        removeHooks: function () {
            d.DomEvent.off(this._map._container, "touchstart", this._onTouchStart, this)
        },
        _onTouchStart: function (a) {
            var c = this._map;
            if (a.touches && 2 ===
                a.touches.length && !c._animatingZoom && !this._zooming) {
                var e = c.mouseEventToLayerPoint(a.touches[0]),
                    g = c.mouseEventToLayerPoint(a.touches[1]),
                    m = c._getCenterLayerPoint();
                this._startCenter = e.add(g)._divideBy(2);
                this._startDist = e.distanceTo(g);
                this._moved = !1;
                this._zooming = !0;
                this._centerOffset = m.subtract(this._startCenter);
                c._panAnim && c._panAnim.stop();
                d.DomEvent.on(b, "touchmove", this._onTouchMove, this).on(b, "touchend", this._onTouchEnd, this);
                d.DomEvent.preventDefault(a)
            }
        },
        _onTouchMove: function (a) {
            var b =
                this._map;
            if (a.touches && 2 === a.touches.length && this._zooming) {
                var c = b.mouseEventToLayerPoint(a.touches[0]),
                    e = b.mouseEventToLayerPoint(a.touches[1]);
                this._scale = c.distanceTo(e) / this._startDist;
                this._delta = c._add(e)._divideBy(2)._subtract(this._startCenter);
                1 === this._scale || !b.options.bounceAtZoomLimits && (b.getZoom() === b.getMinZoom() && 1 > this._scale || b.getZoom() === b.getMaxZoom() && 1 < this._scale) || (this._moved || (d.DomUtil.addClass(b._mapPane, "leaflet-touching"), b.fire("movestart").fire("zoomstart"), this._moved = !0), d.Util.cancelAnimFrame(this._animRequest), this._animRequest = d.Util.requestAnimFrame(this._updateOnMove, this, !0, this._map._container), d.DomEvent.preventDefault(a))
            }
        },
        _updateOnMove: function () {
            var a = this._map,
                b = this._getScaleOrigin(),
                b = a.layerPointToLatLng(b),
                c = a.getScaleZoom(this._scale);
            a._animateZoom(b, c, this._startCenter, this._scale, this._delta)
        },
        _onTouchEnd: function () {
            if (!this._moved || !this._zooming) return void(this._zooming = !1);
            var a = this._map;
            this._zooming = !1;
            d.DomUtil.removeClass(a._mapPane,
                "leaflet-touching");
            d.Util.cancelAnimFrame(this._animRequest);
            d.DomEvent.off(b, "touchmove", this._onTouchMove).off(b, "touchend", this._onTouchEnd);
            var c = this._getScaleOrigin(),
                e = a.layerPointToLatLng(c),
                g = a.getZoom(),
                m = a.getScaleZoom(this._scale) - g,
                m = 0 < m ? Math.ceil(m) : Math.floor(m),
                g = a._limitZoom(g + m),
                m = a.getZoomScale(g) / this._scale;
            a._animateZoom(e, g, c, m)
        },
        _getScaleOrigin: function () {
            var a = this._centerOffset.subtract(this._delta).divideBy(this._scale);
            return this._startCenter.add(a)
        }
    });
    d.Map.addInitHook("addHandler",
        "touchZoom", d.Map.TouchZoom);
    d.Map.mergeOptions({
        tap: !0,
        tapTolerance: 15
    });
    d.Map.Tap = d.Handler.extend({
        addHooks: function () {
            d.DomEvent.on(this._map._container, "touchstart", this._onDown, this)
        },
        removeHooks: function () {
            d.DomEvent.off(this._map._container, "touchstart", this._onDown, this)
        },
        _onDown: function (a) {
            if (a.touches) {
                if (d.DomEvent.preventDefault(a), this._fireClick = !0, 1 < a.touches.length) return this._fireClick = !1, void clearTimeout(this._holdTimeout);
                var c = a.touches[0];
                a = c.target;
                this._startPos = this._newPos =
                    new d.Point(c.clientX, c.clientY);
                a.tagName && "a" === a.tagName.toLowerCase() && d.DomUtil.addClass(a, "leaflet-active");
                this._holdTimeout = setTimeout(d.bind(function () {
                    this._isTapValid() && (this._fireClick = !1, this._onUp(), this._simulateEvent("contextmenu", c))
                }, this), 1E3);
                d.DomEvent.on(b, "touchmove", this._onMove, this).on(b, "touchend", this._onUp, this)
            }
        },
        _onUp: function (a) {
            if (clearTimeout(this._holdTimeout), d.DomEvent.off(b, "touchmove", this._onMove, this).off(b, "touchend", this._onUp, this), this._fireClick && a &&
                a.changedTouches) {
                a = a.changedTouches[0];
                var c = a.target;
                c && c.tagName && "a" === c.tagName.toLowerCase() && d.DomUtil.removeClass(c, "leaflet-active");
                this._isTapValid() && this._simulateEvent("click", a)
            }
        },
        _isTapValid: function () {
            return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance
        },
        _onMove: function (a) {
            a = a.touches[0];
            this._newPos = new d.Point(a.clientX, a.clientY)
        },
        _simulateEvent: function (c, d) {
            var e = b.createEvent("MouseEvents");
            e._simulated = !0;
            d.target._simulatedClick = !0;
            e.initMouseEvent(c, !0, !0, a, 1, d.screenX, d.screenY, d.clientX, d.clientY, !1, !1, !1, !1, 0, null);
            d.target.dispatchEvent(e)
        }
    });
    d.Browser.touch && !d.Browser.pointer && d.Map.addInitHook("addHandler", "tap", d.Map.Tap);
    d.Map.mergeOptions({
        boxZoom: !0
    });
    d.Map.BoxZoom = d.Handler.extend({
        initialize: function (a) {
            this._map = a;
            this._container = a._container;
            this._pane = a._panes.overlayPane;
            this._moved = !1
        },
        addHooks: function () {
            d.DomEvent.on(this._container, "mousedown", this._onMouseDown, this)
        },
        removeHooks: function () {
            d.DomEvent.off(this._container,
                "mousedown", this._onMouseDown);
            this._moved = !1
        },
        moved: function () {
            return this._moved
        },
        _onMouseDown: function (a) {
            return this._moved = !1, !a.shiftKey || 1 !== a.which && 1 !== a.button ? !1 : (d.DomUtil.disableTextSelection(), d.DomUtil.disableImageDrag(), this._startLayerPoint = this._map.mouseEventToLayerPoint(a), void d.DomEvent.on(b, "mousemove", this._onMouseMove, this).on(b, "mouseup", this._onMouseUp, this).on(b, "keydown", this._onKeyDown, this))
        },
        _onMouseMove: function (a) {
            this._moved || (this._box = d.DomUtil.create("div", "leaflet-zoom-box",
                this._pane), d.DomUtil.setPosition(this._box, this._startLayerPoint), this._container.style.cursor = "crosshair", this._map.fire("boxzoomstart"));
            var b = this._startLayerPoint,
                c = this._box,
                e = this._map.mouseEventToLayerPoint(a);
            a = e.subtract(b);
            b = new d.Point(Math.min(e.x, b.x), Math.min(e.y, b.y));
            d.DomUtil.setPosition(c, b);
            this._moved = !0;
            c.style.width = Math.max(0, Math.abs(a.x) - 4) + "px";
            c.style.height = Math.max(0, Math.abs(a.y) - 4) + "px"
        },
        _finish: function () {
            this._moved && (this._pane.removeChild(this._box), this._container.style.cursor =
                "");
            d.DomUtil.enableTextSelection();
            d.DomUtil.enableImageDrag();
            d.DomEvent.off(b, "mousemove", this._onMouseMove).off(b, "mouseup", this._onMouseUp).off(b, "keydown", this._onKeyDown)
        },
        _onMouseUp: function (a) {
            this._finish();
            var b = this._map;
            a = b.mouseEventToLayerPoint(a);
            this._startLayerPoint.equals(a) || (a = new d.LatLngBounds(b.layerPointToLatLng(this._startLayerPoint), b.layerPointToLatLng(a)), b.fitBounds(a), b.fire("boxzoomend", {
                boxZoomBounds: a
            }))
        },
        _onKeyDown: function (a) {
            27 === a.keyCode && this._finish()
        }
    });
    d.Map.addInitHook("addHandler",
        "boxZoom", d.Map.BoxZoom);
    d.Map.mergeOptions({
        keyboard: !0,
        keyboardPanOffset: 80,
        keyboardZoomOffset: 1
    });
    d.Map.Keyboard = d.Handler.extend({
        keyCodes: {
            left: [37],
            right: [39],
            down: [40],
            up: [38],
            zoomIn: [187, 107, 61, 171],
            zoomOut: [189, 109, 173]
        },
        initialize: function (a) {
            this._map = a;
            this._setPanOffset(a.options.keyboardPanOffset);
            this._setZoomOffset(a.options.keyboardZoomOffset)
        },
        addHooks: function () {
            var a = this._map._container; - 1 === a.tabIndex && (a.tabIndex = "0");
            d.DomEvent.on(a, "focus", this._onFocus, this).on(a, "blur",
                this._onBlur, this).on(a, "mousedown", this._onMouseDown, this);
            this._map.on("focus", this._addHooks, this).on("blur", this._removeHooks, this)
        },
        removeHooks: function () {
            this._removeHooks();
            var a = this._map._container;
            d.DomEvent.off(a, "focus", this._onFocus, this).off(a, "blur", this._onBlur, this).off(a, "mousedown", this._onMouseDown, this);
            this._map.off("focus", this._addHooks, this).off("blur", this._removeHooks, this)
        },
        _onMouseDown: function () {
            if (!this._focused) {
                var c = b.body,
                    d = b.documentElement,
                    e = c.scrollTop || d.scrollTop,
                    c = c.scrollLeft || d.scrollLeft;
                this._map._container.focus();
                a.scrollTo(c, e)
            }
        },
        _onFocus: function () {
            this._focused = !0;
            this._map.fire("focus")
        },
        _onBlur: function () {
            this._focused = !1;
            this._map.fire("blur")
        },
        _setPanOffset: function (a) {
            var b, c, d = this._panKeys = {},
                e = this.keyCodes;
            b = 0;
            for (c = e.left.length; c > b; b++) d[e.left[b]] = [-1 * a, 0];
            b = 0;
            for (c = e.right.length; c > b; b++) d[e.right[b]] = [a, 0];
            b = 0;
            for (c = e.down.length; c > b; b++) d[e.down[b]] = [0, a];
            b = 0;
            for (c = e.up.length; c > b; b++) d[e.up[b]] = [0, -1 * a]
        },
        _setZoomOffset: function (a) {
            var b,
                c, d = this._zoomKeys = {},
                e = this.keyCodes;
            b = 0;
            for (c = e.zoomIn.length; c > b; b++) d[e.zoomIn[b]] = a;
            b = 0;
            for (c = e.zoomOut.length; c > b; b++) d[e.zoomOut[b]] = -a
        },
        _addHooks: function () {
            d.DomEvent.on(b, "keydown", this._onKeyDown, this)
        },
        _removeHooks: function () {
            d.DomEvent.off(b, "keydown", this._onKeyDown, this)
        },
        _onKeyDown: function (a) {
            var b = a.keyCode,
                c = this._map;
            if (b in this._panKeys) {
                if (c._panAnim && c._panAnim._inProgress) return;
                c.panBy(this._panKeys[b]);
                c.options.maxBounds && c.panInsideBounds(c.options.maxBounds)
            } else {
                if (!(b in
                    this._zoomKeys)) return;
                c.setZoom(c.getZoom() + this._zoomKeys[b])
            }
            d.DomEvent.stop(a)
        }
    });
    d.Map.addInitHook("addHandler", "keyboard", d.Map.Keyboard);
    d.Handler.MarkerDrag = d.Handler.extend({
        initialize: function (a) {
            this._marker = a
        },
        addHooks: function () {
            var a = this._marker._icon;
            this._draggable || (this._draggable = new d.Draggable(a, a));
            this._draggable.on("dragstart", this._onDragStart, this).on("drag", this._onDrag, this).on("dragend", this._onDragEnd, this);
            this._draggable.enable();
            d.DomUtil.addClass(this._marker._icon,
                "leaflet-marker-draggable")
        },
        removeHooks: function () {
            this._draggable.off("dragstart", this._onDragStart, this).off("drag", this._onDrag, this).off("dragend", this._onDragEnd, this);
            this._draggable.disable();
            d.DomUtil.removeClass(this._marker._icon, "leaflet-marker-draggable")
        },
        moved: function () {
            return this._draggable && this._draggable._moved
        },
        _onDragStart: function () {
            this._marker.closePopup().fire("movestart").fire("dragstart")
        },
        _onDrag: function () {
            var a = this._marker,
                b = a._shadow,
                c = d.DomUtil.getPosition(a._icon),
                e = a._map.layerPointToLatLng(c);
            b && d.DomUtil.setPosition(b, c);
            a._latlng = e;
            a.fire("move", {
                latlng: e
            }).fire("drag")
        },
        _onDragEnd: function (a) {
            this._marker.fire("moveend").fire("dragend", a)
        }
    });
    d.Control = d.Class.extend({
        options: {
            position: "topright"
        },
        initialize: function (a) {
            d.setOptions(this, a)
        },
        getPosition: function () {
            return this.options.position
        },
        setPosition: function (a) {
            var b = this._map;
            return b && b.removeControl(this), this.options.position = a, b && b.addControl(this), this
        },
        getContainer: function () {
            return this._container
        },
        addTo: function (a) {
            this._map = a;
            var b = this._container = this.onAdd(a),
                c = this.getPosition();
            a = a._controlCorners[c];
            return d.DomUtil.addClass(b, "leaflet-control"), -1 !== c.indexOf("bottom") ? a.insertBefore(b, a.firstChild) : a.appendChild(b), this
        },
        removeFrom: function (a) {
            var b = this.getPosition();
            return a._controlCorners[b].removeChild(this._container), this._map = null, this.onRemove && this.onRemove(a), this
        },
        _refocusOnMap: function () {
            this._map && this._map.getContainer().focus()
        }
    });
    d.control = function (a) {
        return new d.Control(a)
    };
    d.Map.include({
        addControl: function (a) {
            return a.addTo(this), this
        },
        removeControl: function (a) {
            return a.removeFrom(this), this
        },
        _initControlPos: function () {
            function a(f, g) {
                b[f + g] = d.DomUtil.create("div", c + f + " " + c + g, e)
            }
            var b = this._controlCorners = {},
                c = "leaflet-",
                e = this._controlContainer = d.DomUtil.create("div", c + "control-container", this._container);
            a("top", "left");
            a("top", "right");
            a("bottom", "left");
            a("bottom", "right")
        },
        _clearControlPos: function () {
            this._container.removeChild(this._controlContainer)
        }
    });
    d.Control.Zoom =
        d.Control.extend({
            options: {
                position: "topleft",
                zoomInText: "+",
                zoomInTitle: "Zoom in",
                zoomOutText: "-",
                zoomOutTitle: "Zoom out"
            },
            onAdd: function (a) {
                var b = d.DomUtil.create("div", "leaflet-control-zoom leaflet-bar");
                return this._map = a, this._zoomInButton = this._createButton(this.options.zoomInText, this.options.zoomInTitle, "leaflet-control-zoom-in", b, this._zoomIn, this), this._zoomOutButton = this._createButton(this.options.zoomOutText, this.options.zoomOutTitle, "leaflet-control-zoom-out", b, this._zoomOut, this), this._updateDisabled(),
                    a.on("zoomend zoomlevelschange", this._updateDisabled, this), b
            },
            onRemove: function (a) {
                a.off("zoomend zoomlevelschange", this._updateDisabled, this)
            },
            _zoomIn: function (a) {
                this._map.zoomIn(a.shiftKey ? 3 : 1)
            },
            _zoomOut: function (a) {
                this._map.zoomOut(a.shiftKey ? 3 : 1)
            },
            _createButton: function (a, b, c, e, g, n) {
                c = d.DomUtil.create("a", c, e);
                c.innerHTML = a;
                c.href = "#";
                c.title = b;
                a = d.DomEvent.stopPropagation;
                return d.DomEvent.on(c, "click", a).on(c, "mousedown", a).on(c, "dblclick", a).on(c, "click", d.DomEvent.preventDefault).on(c, "click",
                    g, n).on(c, "click", this._refocusOnMap, n), c
            },
            _updateDisabled: function () {
                var a = this._map;
                d.DomUtil.removeClass(this._zoomInButton, "leaflet-disabled");
                d.DomUtil.removeClass(this._zoomOutButton, "leaflet-disabled");
                a._zoom === a.getMinZoom() && d.DomUtil.addClass(this._zoomOutButton, "leaflet-disabled");
                a._zoom === a.getMaxZoom() && d.DomUtil.addClass(this._zoomInButton, "leaflet-disabled")
            }
        });
    d.Map.mergeOptions({
        zoomControl: !0
    });
    d.Map.addInitHook(function () {
        this.options.zoomControl && (this.zoomControl = new d.Control.Zoom,
            this.addControl(this.zoomControl))
    });
    d.control.zoom = function (a) {
        return new d.Control.Zoom(a)
    };
    d.Control.Attribution = d.Control.extend({
        options: {
            position: "bottomright",
            prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
        },
        initialize: function (a) {
            d.setOptions(this, a);
            this._attributions = {}
        },
        onAdd: function (a) {
            this._container = d.DomUtil.create("div", "leaflet-control-attribution");
            d.DomEvent.disableClickPropagation(this._container);
            for (var b in a._layers) a._layers[b].getAttribution &&
                this.addAttribution(a._layers[b].getAttribution());
            return a.on("layeradd", this._onLayerAdd, this).on("layerremove", this._onLayerRemove, this), this._update(), this._container
        },
        onRemove: function (a) {
            a.off("layeradd", this._onLayerAdd).off("layerremove", this._onLayerRemove)
        },
        setPrefix: function (a) {
            return this.options.prefix = a, this._update(), this
        },
        addAttribution: function (a) {
            return a ? (this._attributions[a] || (this._attributions[a] = 0), this._attributions[a]++, this._update(), this) : void 0
        },
        removeAttribution: function (a) {
            return a ?
                (this._attributions[a] && (this._attributions[a]--, this._update()), this) : void 0
        },
        _update: function () {
            if (this._map) {
                var a = [],
                    b;
                for (b in this._attributions) this._attributions[b] && a.push(b);
                b = [];
                this.options.prefix && b.push(this.options.prefix);
                a.length && b.push(a.join(", "));
                this._container.innerHTML = b.join(" | ")
            }
        },
        _onLayerAdd: function (a) {
            a.layer.getAttribution && this.addAttribution(a.layer.getAttribution())
        },
        _onLayerRemove: function (a) {
            a.layer.getAttribution && this.removeAttribution(a.layer.getAttribution())
        }
    });
    d.Map.mergeOptions({
        attributionControl: !0
    });
    d.Map.addInitHook(function () {
        this.options.attributionControl && (this.attributionControl = (new d.Control.Attribution).addTo(this))
    });
    d.control.attribution = function (a) {
        return new d.Control.Attribution(a)
    };
    d.Control.Scale = d.Control.extend({
        options: {
            position: "bottomleft",
            maxWidth: 100,
            metric: !0,
            imperial: !0,
            updateWhenIdle: !1
        },
        onAdd: function (a) {
            this._map = a;
            var b = d.DomUtil.create("div", "leaflet-control-scale"),
                c = this.options;
            return this._addScales(c, "leaflet-control-scale",
                b), a.on(c.updateWhenIdle ? "moveend" : "move", this._update, this), a.whenReady(this._update, this), b
        },
        onRemove: function (a) {
            a.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this)
        },
        _addScales: function (a, b, c) {
            a.metric && (this._mScale = d.DomUtil.create("div", b + "-line", c));
            a.imperial && (this._iScale = d.DomUtil.create("div", b + "-line", c))
        },
        _update: function () {
            var a = this._map.getBounds(),
                b = a.getCenter().lat,
                a = 6378137 * Math.PI * Math.cos(b * Math.PI / 180) * (a.getNorthEast().lng - a.getSouthWest().lng) / 180,
                b = this._map.getSize(),
                c = this.options,
                d = 0;
            0 < b.x && (d = c.maxWidth / b.x * a);
            this._updateScales(c, d)
        },
        _updateScales: function (a, b) {
            a.metric && b && this._updateMetric(b);
            a.imperial && b && this._updateImperial(b)
        },
        _updateMetric: function (a) {
            var b = this._getRoundNum(a);
            this._mScale.style.width = this._getScaleWidth(b / a) + "px";
            this._mScale.innerHTML = 1E3 > b ? b + " m" : b / 1E3 + " km"
        },
        _updateImperial: function (a) {
            var b, c, d;
            a *= 3.2808399;
            var e = this._iScale;
            5280 < a ? (b = a / 5280, c = this._getRoundNum(b), e.style.width = this._getScaleWidth(c / b) + "px", e.innerHTML = c + " mi") :
                (d = this._getRoundNum(a), e.style.width = this._getScaleWidth(d / a) + "px", e.innerHTML = d + " ft")
        },
        _getScaleWidth: function (a) {
            return Math.round(this.options.maxWidth * a) - 10
        },
        _getRoundNum: function (a) {
            var b = Math.pow(10, (Math.floor(a) + "").length - 1);
            a /= b;
            return a = 10 <= a ? 10 : 5 <= a ? 5 : 3 <= a ? 3 : 2 <= a ? 2 : 1, b * a
        }
    });
    d.control.scale = function (a) {
        return new d.Control.Scale(a)
    };
    d.Control.Layers = d.Control.extend({
        options: {
            collapsed: !0,
            position: "topright",
            autoZIndex: !0
        },
        initialize: function (a, b, c) {
            d.setOptions(this, c);
            this._layers = {};
            this._lastZIndex = 0;
            this._handlingClick = !1;
            for (var e in a) this._addLayer(a[e], e);
            for (e in b) this._addLayer(b[e], e, !0)
        },
        onAdd: function (a) {
            return this._initLayout(), this._update(), a.on("layeradd", this._onLayerChange, this).on("layerremove", this._onLayerChange, this), this._container
        },
        onRemove: function (a) {
            a.off("layeradd", this._onLayerChange).off("layerremove", this._onLayerChange)
        },
        addBaseLayer: function (a, b) {
            return this._addLayer(a, b), this._update(), this
        },
        addOverlay: function (a, b) {
            return this._addLayer(a,
                b, !0), this._update(), this
        },
        removeLayer: function (a) {
            a = d.stamp(a);
            return delete this._layers[a], this._update(), this
        },
        _initLayout: function () {
            var a = this._container = d.DomUtil.create("div", "leaflet-control-layers");
            a.setAttribute("aria-haspopup", !0);
            d.Browser.touch ? d.DomEvent.on(a, "click", d.DomEvent.stopPropagation) : d.DomEvent.disableClickPropagation(a).disableScrollPropagation(a);
            var b = this._form = d.DomUtil.create("form", "leaflet-control-layers-list");
            if (this.options.collapsed) {
                d.Browser.android || d.DomEvent.on(a,
                    "mouseover", this._expand, this).on(a, "mouseout", this._collapse, this);
                var c = this._layersLink = d.DomUtil.create("a", "leaflet-control-layers-toggle", a);
                c.href = "#";
                c.title = "Layers";
                d.Browser.touch ? d.DomEvent.on(c, "click", d.DomEvent.stop).on(c, "click", this._expand, this) : d.DomEvent.on(c, "focus", this._expand, this);
                d.DomEvent.on(b, "click", function () {
                    setTimeout(d.bind(this._onInputClick, this), 0)
                }, this);
                this._map.on("click", this._collapse, this)
            } else this._expand();
            this._baseLayersList = d.DomUtil.create("div",
                "leaflet-control-layers-base", b);
            this._separator = d.DomUtil.create("div", "leaflet-control-layers-separator", b);
            this._overlaysList = d.DomUtil.create("div", "leaflet-control-layers-overlays", b);
            a.appendChild(b)
        },
        _addLayer: function (a, b, c) {
            var e = d.stamp(a);
            this._layers[e] = {
                layer: a,
                name: b,
                overlay: c
            };
            this.options.autoZIndex && a.setZIndex && (this._lastZIndex++, a.setZIndex(this._lastZIndex))
        },
        _update: function () {
            if (this._container) {
                this._baseLayersList.innerHTML = "";
                this._overlaysList.innerHTML = "";
                var a, b, c = !1,
                    d = !1;
                for (a in this._layers) b = this._layers[a], this._addItem(b), d = d || b.overlay, c = c || !b.overlay;
                this._separator.style.display = d && c ? "" : "none"
            }
        },
        _onLayerChange: function (a) {
            var b = this._layers[d.stamp(a.layer)];
            b && (this._handlingClick || this._update(), (a = b.overlay ? "layeradd" === a.type ? "overlayadd" : "overlayremove" : "layeradd" === a.type ? "baselayerchange" : null) && this._map.fire(a, b))
        },
        _createRadioElement: function (a, c) {
            var d = '<input type="radio" class="leaflet-control-layers-selector" name="' + a + '"';
            c && (d += ' checked="checked"');
            var d = d + "/>",
                e = b.createElement("div");
            return e.innerHTML = d, e.firstChild
        },
        _addItem: function (a) {
            var c, e = b.createElement("label"),
                g = this._map.hasLayer(a.layer);
            a.overlay ? (c = b.createElement("input"), c.type = "checkbox", c.className = "leaflet-control-layers-selector", c.defaultChecked = g) : c = this._createRadioElement("leaflet-base-layers", g);
            c.layerId = d.stamp(a.layer);
            d.DomEvent.on(c, "click", this._onInputClick, this);
            g = b.createElement("span");
            g.innerHTML = " " + a.name;
            e.appendChild(c);
            e.appendChild(g);
            return (a.overlay ?
                this._overlaysList : this._baseLayersList).appendChild(e), e
        },
        _onInputClick: function () {
            var a, b, c, d = this._form.getElementsByTagName("input"),
                e = d.length;
            this._handlingClick = !0;
            for (a = 0; e > a; a++) b = d[a], c = this._layers[b.layerId], b.checked && !this._map.hasLayer(c.layer) ? this._map.addLayer(c.layer) : !b.checked && this._map.hasLayer(c.layer) && this._map.removeLayer(c.layer);
            this._handlingClick = !1;
            this._refocusOnMap()
        },
        _expand: function () {
            d.DomUtil.addClass(this._container, "leaflet-control-layers-expanded")
        },
        _collapse: function () {
            this._container.className =
                this._container.className.replace(" leaflet-control-layers-expanded", "")
        }
    });
    d.control.layers = function (a, b, c) {
        return new d.Control.Layers(a, b, c)
    };
    d.PosAnimation = d.Class.extend({
        includes: d.Mixin.Events,
        run: function (a, b, c, e) {
            this.stop();
            this._el = a;
            this._inProgress = !0;
            this._newPos = b;
            this.fire("start");
            a.style[d.DomUtil.TRANSITION] = "all " + (c || 0.25) + "s cubic-bezier(0,0," + (e || 0.5) + ",1)";
            d.DomEvent.on(a, d.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
            d.DomUtil.setPosition(a, b);
            d.Util.falseFn(a.offsetWidth);
            this._stepTimer = setInterval(d.bind(this._onStep, this), 50)
        },
        stop: function () {
            this._inProgress && (d.DomUtil.setPosition(this._el, this._getPos()), this._onTransitionEnd(), d.Util.falseFn(this._el.offsetWidth))
        },
        _onStep: function () {
            var a = this._getPos();
            return a ? (this._el._leaflet_pos = a, void this.fire("step")) : void this._onTransitionEnd()
        },
        _transformRe: /([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,
        _getPos: function () {
            var b, c, e = a.getComputedStyle(this._el);
            if (d.Browser.any3d) {
                if (c = e[d.DomUtil.TRANSFORM].match(this._transformRe), !c) return;
                b = parseFloat(c[1]);
                c = parseFloat(c[2])
            } else b = parseFloat(e.left), c = parseFloat(e.top);
            return new d.Point(b, c, !0)
        },
        _onTransitionEnd: function () {
            d.DomEvent.off(this._el, d.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
            this._inProgress && (this._inProgress = !1, this._el.style[d.DomUtil.TRANSITION] = "", this._el._leaflet_pos = this._newPos, clearInterval(this._stepTimer), this.fire("step").fire("end"))
        }
    });
    d.Map.include({
        setView: function (a, b, e) {
            if (b = b === c ? this._zoom : this._limitZoom(b), a = this._limitCenter(d.latLng(a),
                b, this.options.maxBounds), e = e || {}, this._panAnim && this._panAnim.stop(), this._loaded && !e.reset && !0 !== e)
                if (e.animate !== c && (e.zoom = d.extend({
                    animate: e.animate
                }, e.zoom), e.pan = d.extend({
                    animate: e.animate
                }, e.pan)), this._zoom !== b ? this._tryAnimatedZoom && this._tryAnimatedZoom(a, b, e.zoom) : this._tryAnimatedPan(a, e.pan)) return clearTimeout(this._sizeTimer), this;
            return this._resetView(a, b), this
        },
        panBy: function (a, b) {
            if (a = d.point(a).round(), b = b || {}, !a.x && !a.y) return this;
            if (this._panAnim || (this._panAnim = new d.PosAnimation,
                this._panAnim.on({
                    step: this._onPanTransitionStep,
                    end: this._onPanTransitionEnd
                }, this)), b.noMoveStart || this.fire("movestart"), !1 !== b.animate) {
                d.DomUtil.addClass(this._mapPane, "leaflet-pan-anim");
                var c = this._getMapPanePos().subtract(a);
                this._panAnim.run(this._mapPane, c, b.duration || 0.25, b.easeLinearity)
            } else this._rawPanBy(a), this.fire("move").fire("moveend");
            return this
        },
        _onPanTransitionStep: function () {
            this.fire("move")
        },
        _onPanTransitionEnd: function () {
            d.DomUtil.removeClass(this._mapPane, "leaflet-pan-anim");
            this.fire("moveend")
        },
        _tryAnimatedPan: function (a, b) {
            var c = this._getCenterOffset(a)._floor();
            return !0 === (b && b.animate) || this.getSize().contains(c) ? (this.panBy(c, b), !0) : !1
        }
    });
    d.PosAnimation = d.DomUtil.TRANSITION ? d.PosAnimation : d.PosAnimation.extend({
        run: function (a, b, c, e) {
            this.stop();
            this._el = a;
            this._inProgress = !0;
            this._duration = c || 0.25;
            this._easeOutPower = 1 / Math.max(e || 0.5, 0.2);
            this._startPos = d.DomUtil.getPosition(a);
            this._offset = b.subtract(this._startPos);
            this._startTime = +new Date;
            this.fire("start");
            this._animate()
        },
        stop: function () {
            this._inProgress && (this._step(), this._complete())
        },
        _animate: function () {
            this._animId = d.Util.requestAnimFrame(this._animate, this);
            this._step()
        },
        _step: function () {
            var a = +new Date - this._startTime,
                b = 1E3 * this._duration;
            b > a ? this._runFrame(this._easeOut(a / b)) : (this._runFrame(1), this._complete())
        },
        _runFrame: function (a) {
            a = this._startPos.add(this._offset.multiplyBy(a));
            d.DomUtil.setPosition(this._el, a);
            this.fire("step")
        },
        _complete: function () {
            d.Util.cancelAnimFrame(this._animId);
            this._inProgress = !1;
            this.fire("end")
        },
        _easeOut: function (a) {
            return 1 - Math.pow(1 - a, this._easeOutPower)
        }
    });
    d.Map.mergeOptions({
        zoomAnimation: !0,
        zoomAnimationThreshold: 4
    });
    d.DomUtil.TRANSITION && d.Map.addInitHook(function () {
        (this._zoomAnimated = this.options.zoomAnimation && d.DomUtil.TRANSITION && d.Browser.any3d && !d.Browser.android23 && !d.Browser.mobileOpera) && d.DomEvent.on(this._mapPane, d.DomUtil.TRANSITION_END, this._catchTransitionEnd, this)
    });
    d.Map.include(d.DomUtil.TRANSITION ? {
        _catchTransitionEnd: function (a) {
            this._animatingZoom &&
                0 <= a.propertyName.indexOf("transform") && this._onZoomTransitionEnd()
        },
        _nothingToAnimate: function () {
            return !this._container.getElementsByClassName("leaflet-zoom-animated").length
        },
        _tryAnimatedZoom: function (a, b, c) {
            if (this._animatingZoom) return !0;
            if (c = c || {}, !this._zoomAnimated || !1 === c.animate || this._nothingToAnimate() || Math.abs(b - this._zoom) > this.options.zoomAnimationThreshold) return !1;
            var d = this.getZoomScale(b),
                e = this._getCenterOffset(a)._divideBy(1 - 1 / d),
                g = this._getCenterLayerPoint()._add(e);
            return !0 ===
                c.animate || this.getSize().contains(e) ? (this.fire("movestart").fire("zoomstart"), this._animateZoom(a, b, g, d, null, !0), !0) : !1
        },
        _animateZoom: function (a, b, c, e, g, n) {
            this._animatingZoom = !0;
            d.DomUtil.addClass(this._mapPane, "leaflet-zoom-anim");
            this._animateToCenter = a;
            this._animateToZoom = b;
            d.Draggable && (d.Draggable._disabled = !0);
            this.fire("zoomanim", {
                center: a,
                zoom: b,
                origin: c,
                scale: e,
                delta: g,
                backwards: n
            })
        },
        _onZoomTransitionEnd: function () {
            this._animatingZoom = !1;
            d.DomUtil.removeClass(this._mapPane, "leaflet-zoom-anim");
            this._resetView(this._animateToCenter, this._animateToZoom, !0, !0);
            d.Draggable && (d.Draggable._disabled = !1)
        }
    } : {});
    d.TileLayer.include({
        _animateZoom: function (a) {
            this._animating || (this._animating = !0, this._prepareBgBuffer());
            var b = this._bgBuffer,
                c = d.DomUtil.TRANSFORM,
                e = a.delta ? d.DomUtil.getTranslateString(a.delta) : b.style[c],
                g = d.DomUtil.getScaleString(a.scale, a.origin);
            b.style[c] = a.backwards ? g + " " + e : e + " " + g
        },
        _endZoomAnim: function () {
            var a = this._tileContainer,
                b = this._bgBuffer;
            a.style.visibility = "";
            a.parentNode.appendChild(a);
            d.Util.falseFn(b.offsetWidth);
            this._animating = !1
        },
        _clearBgBuffer: function () {
            var a = this._map;
            !a || a._animatingZoom || a.touchZoom._zooming || (this._bgBuffer.innerHTML = "", this._bgBuffer.style[d.DomUtil.TRANSFORM] = "")
        },
        _prepareBgBuffer: function () {
            var a = this._tileContainer,
                b = this._bgBuffer,
                c = this._getLoadedTilesPercentage(b),
                e = this._getLoadedTilesPercentage(a);
            return b && 0.5 < c && 0.5 > e ? (a.style.visibility = "hidden", void this._stopLoadingImages(a)) : (b.style.visibility = "hidden", b.style[d.DomUtil.TRANSFORM] = "",
                this._tileContainer = b, b = this._bgBuffer = a, this._stopLoadingImages(b), void clearTimeout(this._clearBgBufferTimer))
        },
        _getLoadedTilesPercentage: function (a) {
            var b, c = a.getElementsByTagName("img"),
                d = 0;
            a = 0;
            for (b = c.length; b > a; a++) c[a].complete && d++;
            return d / b
        },
        _stopLoadingImages: function (a) {
            var b, c, e = Array.prototype.slice.call(a.getElementsByTagName("img"));
            a = 0;
            for (b = e.length; b > a; a++) c = e[a], c.complete || (c.onload = d.Util.falseFn, c.onerror = d.Util.falseFn, c.src = d.Util.emptyImageUrl, c.parentNode.removeChild(c))
        }
    });
    d.Map.include({
        _defaultLocateOptions: {
            watch: !1,
            setView: !1,
            maxZoom: 1 / 0,
            timeout: 1E4,
            maximumAge: 0,
            enableHighAccuracy: !1
        },
        locate: function (a) {
            if (a = this._locateOptions = d.extend(this._defaultLocateOptions, a), !navigator.geolocation) return this._handleGeolocationError({
                code: 0,
                message: "Geolocation not supported."
            }), this;
            var b = d.bind(this._handleGeolocationResponse, this),
                c = d.bind(this._handleGeolocationError, this);
            return a.watch ? this._locationWatchId = navigator.geolocation.watchPosition(b, c, a) : navigator.geolocation.getCurrentPosition(b,
                c, a), this
        },
        stopLocate: function () {
            return navigator.geolocation && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = !1), this
        },
        _handleGeolocationError: function (a) {
            var b = a.code;
            a = a.message || (1 === b ? "permission denied" : 2 === b ? "position unavailable" : "timeout");
            this._locateOptions.setView && !this._loaded && this.fitWorld();
            this.fire("locationerror", {
                code: b,
                message: "Geolocation error: " + a + "."
            })
        },
        _handleGeolocationResponse: function (a) {
            var b = a.coords.latitude,
                c = a.coords.longitude,
                e = new d.LatLng(b, c),
                g = 180 * a.coords.accuracy / 40075017,
                n = g / Math.cos(d.LatLng.DEG_TO_RAD * b),
                b = d.latLngBounds([b - g, c - n], [b + g, c + n]),
                c = this._locateOptions;
            c.setView && (c = Math.min(this.getBoundsZoom(b), c.maxZoom), this.setView(e, c));
            var e = {
                    latlng: e,
                    bounds: b,
                    timestamp: a.timestamp
                },
                r;
            for (r in a.coords) "number" == typeof a.coords[r] && (e[r] = a.coords[r]);
            this.fire("locationfound", e)
        }
    })
}(window, document);

function readOpenCTM_RAW(a, b) {
    var c = a.getString(4);
    if ("INDX" != c) return null;
    for (var e = b.vertexCount, d = b.triangleCount, g = function (a) {
        return a.buffer.slice(a.byteOffset, a.byteOffset + a.length)
    }, f = b.indices = new Uint16Array(3 * d), c = 0, d = 3 * d; c < d; c++) f[c] = a.getInt32();
    c = a.getString(4);
    if ("VERT" != c) return null;
    b.vertices = new Float32Array(g(a.getBytes(12 * e)));
    if (b.flags & 1) {
        c = a.getString(4);
        if ("NORM" != c) return null;
        b.normals = new Float32Array(g(a.getBytes(12 * e)))
    }
    for (f = 0; f < b.texMapCount; f++) {
        c = a.getString(4);
        if ("TEXC" != c) return null;
        c = {
            name: a.getString(a.getInt32()),
            file: a.getString(a.getInt32()),
            data: new Float32Array(g(a.getBytes(8 * e)))
        };
        b.uvs.push(c)
    }
    for (f = 0; f < b.attribMapCount; f++) {
        c = a.getString(4);
        if ("ATTR" != c) return null;
        c = {
            name: a.getString(a.getInt32()),
            data: new Float32Array(g(a.getBytes(16 * e)))
        };
        if (-1 != c.name.indexOf("Color")) {
            for (var d = new Float32Array(c.data.length / 4 * 3), k = 0, h = 0, l = d.length; k < l; k += 3, h += 4) d[k] = c.data[h], d[k + 1] = c.data[h + 1], d[k + 2] = c.data[h + 2];
            b.colors = d
        } else b.attrs.push(c)
    }
}
var readOpenCTM = function (a) {
        function b(a) {
            for (var b = 0; b < a.uvs.length; b++)
                for (var c = a.uvs[b].data, d = 0, e = 2 * a.vertexCount; d < e; d += 2) {
                    var m = c[d],
                        n = c[d + 1];
                    if (2 < m || 0 > m || 2 < n || 0 > n) {
                        a.uvs[b].isPattern = !0;
                        break
                    }
                }
        }

        function c(a) {
            a.vbstride = 3;
            a.flags & 1 && (a.vbstride += 3);
            a.vbstride += 2 * a.texMapCount;
            0 < a.attribMapCount && (a.vbstride += 3);
            var b = a.vb = new Float32Array(a.vertexCount * a.vbstride),
                c = a.vertices,
                d = a.normals,
                e = a.colors;
            a.vblayout = {};
            var m = 0;
            a.vblayout.position = {
                offset: m,
                itemSize: 3
            };
            m += 3;
            d && (a.vblayout.normal = {
                offset: m,
                itemSize: 3
            }, m += 3);
            for (var n = 0; n < a.uvs.length; n++) {
                var r = "uv";
                n && (r += (n + 1).toString());
                a.vblayout[r] = {
                    offset: m,
                    itemSize: 2,
                    isPattern: a.uvs[n].isPattern
                };
                m += 2
            }
            e && (a.vblayout.color = {
                offset: m,
                itemSize: 3
            });
            n = m = 0;
            for (r = a.vertexCount; n < r; n++) {
                b[m++] = c[3 * n];
                b[m++] = c[3 * n + 1];
                b[m++] = c[3 * n + 2];
                d && (b[m++] = d[3 * n], b[m++] = d[3 * n + 1], b[m++] = d[3 * n + 2]);
                for (var s = 0; s < a.uvs.length; s++) b[m++] = a.uvs[s].data[2 * n], b[m++] = a.uvs[s].data[2 * n + 1];
                e && (b[m++] = e[3 * n], b[m++] = e[3 * n + 1], b[m++] = e[3 * n + 2])
            }
            delete a.vertices;
            delete a.normals;
            delete a.uvs;
            delete a.colors
        }
        if ("OCTM" != a.getString(4) || 5 != a.getInt32()) return null;
        var e = a.getString(3);
        a.getUint8();
        var d = {
            vertices: null,
            indices: null,
            normals: null,
            colors: null,
            uvs: [],
            attrs: []
        };
        d.vertexCount = a.getInt32();
        d.triangleCount = a.getInt32();
        d.texMapCount = a.getInt32();
        d.attribMapCount = a.getInt32();
        d.flags = a.getInt32();
        d.comment = a.getString(a.getInt32());
        return "RAW" == e ? (readOpenCTM_RAW(a, d), computeBounds(d), b(d), c(d), d) : "MG2" == e ? (readOpenCTM_MG2(a, d), computeBounds(d), b(d), c(d), d) : null
    },
    readLines =
    function (a) {
        var b = {
            isLines: !0,
            vertices: null,
            indices: null,
            colors: null,
            normals: null,
            uvs: [],
            attrs: []
        };
        b.vertexCount = a.readU32V();
        var c = a.readU32V(),
            e = a.readU32V(),
            d = 0 != a.stream.getUint8(),
            g = function (a) {
                return a.buffer.slice(a.byteOffset, a.byteOffset + a.length)
            };
        b.vertices = new Float32Array(g(a.stream.getBytes(12 * b.vertexCount)));
        if (d)
            for (var d = new Float32Array(g(a.stream.getBytes(16 * b.vertexCount))), f = b.colors = new Float32Array(d.length / 4 * 3), k = 0, h = 0, l = f.length; k < l; k += 3, h += 4) f[k] = d[h], f[k + 1] = d[h + 1], f[k +
                2] = d[h + 2];
        c = new Int32Array(g(a.stream.getBytes(4 * c)));
        b.polyLineBoundBuffer = new Int32Array(g(a.stream.getBytes(4 * e)));
        a = [];
        for (g = 0; g < e; g++)
            for (d = b.polyLineBoundBuffer[g]; d + 1 < b.polyLineBoundBuffer[g + 1]; d++) a.push(c[d]), a.push(c[d + 1]);
        b.indices = new Uint16Array(a.length);
        for (g = 0; g < a.length; g++) b.indices[g] = a[g];
        computeBounds(b);
        return b
    },
    computeBounds = function (a) {
        for (var b = Infinity, c = Infinity, e = Infinity, d = -Infinity, g = -Infinity, f = -Infinity, k = a.vertices, h = 0, l = 3 * a.vertexCount; h < l; h += 3) {
            var m = k[h],
                n = k[h +
                    1],
                r = k[h + 2];
            m < b && (b = m);
            n < c && (c = n);
            r < e && (e = r);
            m > d && (d = m);
            n > g && (g = n);
            r > f && (f = r)
        }
        a.boundingBox = new THREE.Box3;
        a.boundingBox.min.set(b, c, e);
        a.boundingBox.max.set(d, g, f);
        b = 0.5 * (b + d);
        c = 0.5 * (c + g);
        e = 0.5 * (e + f);
        a.boundingSphere = new THREE.Sphere;
        a.boundingSphere.center.set(b, c, e);
        h = f = 0;
        for (l = 3 * a.vertexCount; h < l; h += 3) g = k[h] - b, d = k[h + 1] - c, m = k[h + 2] - e, g = g * g + d * d + m * m, g > f && (f = g);
        a.boundingSphere.radius = Math.sqrt(f)
    };

function readGeometry(a, b, c) {
    return (b = a.seekToEntry(b)) ? "Autodesk.CloudPlatform.OpenCTM" == b.entryType ? readOpenCTM(a.stream) : "Autodesk.CloudPlatform.Lines" == b.entryType ? readLines(a) : null : null
};

function convertMaterials(a) {
    var b = function (a, b) {
            var c = new THREE.Color;
            if (!a || !a.colors) return c.setRGB(1, 0, 0);
            var d = a.colors[b];
            if (!d) return c.setRGB(0, 0, 0);
            d = d.values;
            if (!d || !d.length) return c.setRGB(1, 0, 0);
            d = d[0];
            return c.setRGB(d.r, d.g, d.b)
        },
        c = function (a, b) {
            if (!a || !a.scalars) return 0;
            var c = a.scalars[b];
            return c ? c.values[0] : void 0
        },
        e = function (a, b) {
            if (!a || !a.booleans) return 0;
            var c = a.booleans;
            return c ? c[b] : void 0
        },
        d = a.materials.materials;
    a.simplemats = {};
    for (var g in d) {
        var f = d[g],
            k = f.materials,
            h = k[f.userassets[0]];
        if (h && "SimplePhong" == h.definition) {
            var f = h.properties,
                l = {};
            l.ambient = b(f, "generic_ambient");
            l.color = b(f, "generic_diffuse");
            l.specular = b(f, "generic_specular");
            l.emissive = b(f, "generic_emissive");
            var m = c(f, "generic_glossiness");
            m || (m = 30);
            l.shininess = m;
            (m = c(f, "generic_transparency")) || (m = 0);
            l.opacity = 1 - m;
            (m = c(f, "generic_reflectivity_at_0deg")) || (m = 0);
            l.reflectivity = m;
            m = e(f, "generic_is_metal");
            void 0 !== m && (l.metal = m);
            m = e(f, "generic_backface_cull");
            void 0 !== m && (l.doubleSided = !m);
            l.transparent =
                h.transparent;
            var h = h.textures,
                n;
            for (n in h) {
                var m = k[h[n].connections[0]].properties,
                    r = m.uris.unifiedbitmap_Bitmap.values[0],
                    s = null;
                if (r)
                    if ("generic_diffuse" == n) {
                        if (s = "map", !l.color || 0 == l.color.r && 0 == l.color.g && 0 == l.color.b) l.color = new THREE.Color(1, 1, 1)
                    } else "generic_bump" == n ? (s = e(f, "generic_bump_is_normal") ? "normalMap" : "bumpMap", l.bumpScale = c(f, "generic_bump_amount")) : "generic_specular" == n ? s = "specularMap" : "generic_reflection" == n ? s = "envMap" : "generic_alpha" == n && (s = "opacityMap");
                s && (l["uri_" + s] = r, (r =
                    c(m, "texture_UScale")) && (l["uscale_" + s] = r), (r = c(m, "texture_VScale")) && (l["vscale_" + s] = r))
            }
            a.simplemats[g] = l
        }
    }
};

function readLightDefinition(a, b) {
    var c = a.seekToEntry(b);
    if (!c || 1 < c.version) return null;
    c = a.stream;
    return {
        position: a.readVector3f(),
        dir: a.readVector3f(),
        r: c.getFloat32(),
        g: c.getFloat32(),
        b: c.getFloat32(),
        intensity: c.getFloat32(),
        spotAngle: c.getFloat32(),
        size: c.getFloat32(),
        type: c.getUint8()
    }
};

function readCameraDefinition(a, b) {
    var c = a.seekToEntry(b.definition);
    if (!c || 2 < c.version) return null;
    var e = a.stream,
        d = {
            isPerspective: !e.getUint8(),
            position: a.readVector3f(),
            target: a.readVector3f(),
            up: a.readVector3f(),
            aspect: e.getFloat32(),
            fov: THREE.Math.radToDeg(e.getFloat32())
        };
    2 > c.version && (e.getFloat32(), e.getFloat32());
    d.orthoScale = e.getFloat32();
    d.inst = b;
    return d
};

function FragList() {
    this.length = 0
}

function readGeometryMetadata(a, b) {
    var c = a.getEntryCounts(),
        e = a.stream;
    b.length = c;
    for (var d = b.fragTypes = new Uint8Array(c), g = b.primCounts = new Uint16Array(c), f = b.packIds = new Int32Array(c), k = b.entityIndexes = new Int32Array(c), h = 0; h < c && a.seekToEntry(h); h++) d[h] = e.getUint8(), e.seek(e.offset + 24), g[h] = e.getUint16(), f[h] = parseInt(a.readString()), k[h] = a.readU32V()
}

function readFragments(a, b) {
    function c(a) {
        a *= 6;
        for (var b = 0; 6 > b; b++) f[a++] = g.getFloat32()
    }

    function e(a, b, c) {
        a *= 6;
        for (var d = 0; 6 > d; d++) f[a++] = g.getFloat32() + b[c + d % 3]
    }
    var d = a.getEntryCounts(),
        g = a.stream;
    b.length = d;
    b.numLoaded = 0;
    for (var f = b.boxes = new Float32Array(6 * d), k = b.transforms = new Float32Array(16 * d), h = b.materials = new Int32Array(d), l = b.packIds = new Int32Array(d), m = b.entityIndexes = new Int32Array(d), n = b.geomDataIndexes = new Int32Array(d), d = b.fragId2dbId = new Int32Array(d), r = 0, s = b.length; r < s; r++) {
        var t =
            a.seekToEntry(r);
        if (!t) break;
        if (4 < t.version) break;
        h[r] = a.readU32V();
        2 < t.version ? n[r] = a.readU32V() : (l[r] = parseInt(a.readString()), m[r] = a.readU32V());
        a.readTransform(r, k, 16 * r);
        3 < t.version ? e(r, k, 16 * r + 12) : c(r);
        1 < t.version && (d[r] = a.readU32V());
        a.readPathID()
    }
}

function filterFragments(a, b) {
    a.length = b.length;
    a.numLoaded = 0;
    for (var c = a.length, e = [Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity], d = new Float32Array(6 * c), g = new Float32Array(16 * c), f = new Int32Array(c), k = new Int32Array(c), c = new Int32Array(c), h = {}, l = 0; l < b.length; ++l) {
        for (var m = b[l], n = 6 * m, r = 6 * l, s = 0; 6 > s; ++s) d[r++] = a.boxes[n++];
        n = 16 * m;
        r = 16 * l;
        for (s = 0; 16 > s; ++s) g[r++] = a.transforms[n++];
        f[l] = a.materials[m];
        k[l] = a.packIds[m];
        c[l] = a.entityIndexes[m];
        s = a.packIds[m] + ":" + a.entityIndexes[m];
        m = h[s];
        void 0 ==
            m ? h[s] = l : Array.isArray(m) ? m.push(l) : h[s] = [m, l];
        m = 6 * l;
        for (s = 0; 3 > s; ++s) d[m + s] < e[s] && (e[s] = d[m + s]);
        for (s = 3; 6 > s; ++s) d[m + s] > e[s] && (e[s] = d[m + s])
    }
    a.boxes = d;
    a.transforms = g;
    a.materials = f;
    a.packIds = k;
    a.entityIndexes = c;
    a.mesh2frag = h;
    return e
};

function readInstance(a, b) {
    var c = a.seekToEntry(b);
    return !c || 1 < c.version ? null : {
        definition: a.stream.getUint32(),
        transform: a.readTransform(),
        instanceNodePath: a.readPathID()
    }
};

function Package() {
    this.fragments = this.metadata = this.simplemats = this.materials = this.manifest = null;
    this.geompacks = [];
    this.instances = [];
    this.cameras = [];
    this.lights = [];
    this.propertydb = {
        attrs: [],
        avs: [],
        ids: [],
        values: [],
        offsets: []
    };
    this.bbox = null;
    this.pendingRequests = 0
}
Package.prototype.loadAsyncResource = function (a, b, c, e) {
    function d(b) {
        g.pendingRequests--;
        this.response && (b = new Uint8Array(this.response), 31 == b[0] && 139 == b[1] && (b = (new Zlib.Gunzip(b)).decompress()), e(b));
        0 == g.pendingRequests && g.postLoad(a)
    }
    if (c) e(c);
    else {
        var g = this;
        this.pendingRequests++;
        (new Xhr(a.errorHandler, a.auth, a.viewing_url)).get(a.basePath + b, a.headers, "arraybuffer", d)
    }
};
Package.prototype.load = function (a, b) {
    var c = this,
        e = new Zlib.Unzip(b),
        d = e.decompress("manifest.json");
    if (!d) return !1;
    var g = new InputStream(d),
        f = JSON.parse(g.getString(d.byteLength)),
        d = e.decompress("metadata.json"),
        g = new InputStream(d);
    3 < d.byteLength && 0 !== d[3] && (this.metadata = JSON.parse(g.getString(d.byteLength)).metadata) && (g = this.metadata["world bounding box"], this.bbox = new THREE.Box3({
        x: g.minXYZ[0],
        y: g.minXYZ[1],
        z: g.minXYZ[2]
    }, {
        x: g.maxXYZ[0],
        y: g.maxXYZ[1],
        z: g.maxXYZ[2]
    }));
    this.manifest = f;
    for (var k =
        f.typesets, g = {}, d = 0; d < k.length; d++) {
        var h = k[d];
        g[h.id] = h.types
    }
    f = f.assets;
    for (d = 0; d < f.length; d++) {
        h = f[d];
        k = h.type;
        0 == k.indexOf("Autodesk.CloudPlatform.") && (k = k.substr(23));
        var l = h.URI,
            m = h.typeset ? g[h.typeset] : null;
        0 != l.indexOf("embed:/") && ("PackFile" == k ? "Autodesk.CloudPlatform.Geometry" == (m ? m[0]["class"] : null) && this.geompacks.push({
                id: h.id,
                uri: l
            }) : "PropertyAttributes" == k ? this.propertydb.attrs.push(l) : "PropertyAVs" == k ? this.propertydb.avs.push(l) : "PropertyIDs" == k ? this.propertydb.ids.push(l) : "PropertyOffsets" ==
            k ? this.propertydb.offsets.push(l) : "PropertyValues" == k && this.propertydb.values.push(l));
        var h = h.URI,
            n;
        0 == h.indexOf("embed:/") && (h = h.substr(7), n = e.decompress(h));
        "ProteinMaterials" == k ? -1 == h.indexOf("Protein") ? this.loadAsyncResource(a, h, n, function (a) {
            var b = new InputStream(a);
            a = a.byteLength;
            0 < a ? (c.materials = JSON.parse(b.getString(a)), convertMaterials(c)) : c.materials = null
        }) : this.proteinMaterials = !0 : "FragmentList" == k ? this.loadAsyncResource(a, h, n, function (a) {
            a = new PackFileReader(a);
            var b = c.fragments = new FragList;
            readFragments(a, b)
        }) : "GeometryMetadataList" == k ? this.loadAsyncResource(a, h, n, function (a) {
            a = new PackFileReader(a);
            c.geomMetadata = {};
            readGeometryMetadata(a, c.geomMetadata)
        }) : "PackFile" == k && (-1 != h.indexOf("CameraDefinitions.bin") ? this.loadAsyncResource(a, h, n, function (a) {
            c.camDefPack = new PackFileReader(a)
        }) : -1 != h.indexOf("CameraList.bin") ? this.loadAsyncResource(a, h, n, function (a) {
            c.camInstPack = new PackFileReader(a)
        }) : -1 != h.indexOf("LightDefinitions.bin") ? this.loadAsyncResource(a, h, n, function (a) {
            c.lightDefPack =
                new PackFileReader(a)
        }) : -1 != h.indexOf("LightList.bin") && this.loadAsyncResource(a, h, n, function (a) {
            c.lightInstPack = new PackFileReader(a)
        }))
    }
    0 == this.pendingRequests && this.postLoad(a)
};
Package.prototype.postLoad = function (a) {
    if (this.camDefPack && this.camInstPack) {
        for (var b = 0, c = this.camInstPack.getEntryCounts(); b < c; b++) {
            var e = readInstance(this.camInstPack, b);
            this.cameras.push(readCameraDefinition(this.camDefPack, e))
        }
        delete this.camDefPack;
        delete this.camInstPack
    }
    if (this.lightDefPack && this.lightInstPack) {
        b = 0;
        for (c = this.lightInstPack.getEntryCounts(); b < c; b++) e = readInstance(this.lightInstPack, b), this.lights.push(readLightDefinition(this.lightDefPack, e.definition));
        delete this.lightInstPack;
        delete this.lightDefPack
    }
    e = this.fragments;
    if (this.geomMetadata) {
        for (var c = this.geomMetadata, b = 0, d = e.length; b < d; b++) {
            var g = e.geomDataIndexes[b];
            e.entityIndexes[b] = c.entityIndexes[g];
            e.packIds[b] = c.packIds[g]
        }
        delete this.geomMetadata
    }
    for (var g = e.mesh2frag = {}, c = e.packIds, f = e.entityIndexes, b = 0, d = e.length; b < d; b++) {
        var k = c[b] + ":" + f[b],
            h = g[k];
        void 0 === h ? g[k] = b : Array.isArray(h) ? h.push(b) : g[k] = [h, b]
    }
    if (!this.bbox) {
        c = [Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity];
        d = e.boxes;
        g = 0;
        for (e = e.length; g <
            e; g++) {
            f = 6 * g;
            for (b = 0; 3 > b; b++) d[f + b] < c[b] && (c[b] = d[f + b]);
            for (b = 3; 6 > b; b++) d[f + b] > c[b] && (c[b] = d[f + b])
        }
        this.bbox = new THREE.Box3(new THREE.Vector3(c[0], c[1], c[2]), new THREE.Vector3(c[3], c[4], c[5]))
    }
    g = a.objectIds;
    if (null != g) {
        c = [];
        e = [];
        for (b = 0; b < g.length; ++b)
            for (d = 0; d < this.fragments.length; ++d) this.fragments.fragId2dbId[d] == g[b] && (c.push(this.fragments.packIds[d]), e.push(d));
        d = 1;
        g = c.length;
        for (b = 1; b < g;) {
            for (; b < g && c[b] == c[b - 1];)++b;
            if (g == b) break;
            c[d++] = c[b++]
        }
        c.splice(d - 1, g - d);
        g = [];
        for (b = 0; b < this.geompacks.length; ++b)
            for (d =
                0; d < c.length; ++d) parseInt(this.geompacks[b].id) == c[d] && g.push(this.geompacks[b]);
        this.geompacks = g;
        b = filterFragments(this.fragments, e);
        this.bbox = new THREE.Box3(new THREE.Vector3(b[0], b[1], b[2]), new THREE.Vector3(b[3], b[4], b[5]))
    }
    a.loadDoneCB(!0)
};

function InputStream(a) {
    this.buffer = a;
    this.offset = 0;
    this.byteLength = a.length;
    this.convBuf = new ArrayBuffer(8);
    this.convUint8 = new Uint8Array(this.convBuf);
    this.convUint16 = new Uint16Array(this.convBuf);
    this.convInt32 = new Int32Array(this.convBuf);
    this.convUint32 = new Uint32Array(this.convBuf);
    this.convFloat32 = new Float32Array(this.convBuf);
    this.convFloat64 = new Float64Array(this.convBuf)
}
InputStream.prototype.seek = function (a) {
    this.offset = a
};
InputStream.prototype.getBytes = function (a) {
    var b = new Uint8Array(this.buffer.buffer, this.offset, a);
    this.offset += a;
    return b
};
InputStream.prototype.getUint8 = function () {
    return this.buffer[this.offset++]
};
InputStream.prototype.getUint16 = function () {
    this.convUint8[0] = this.buffer[this.offset++];
    this.convUint8[1] = this.buffer[this.offset++];
    return this.convUint16[0]
};
InputStream.prototype.getInt32 = function () {
    var a = this.buffer,
        b = this.convUint8,
        c = this.offset;
    b[0] = a[c];
    b[1] = a[c + 1];
    b[2] = a[c + 2];
    b[3] = a[c + 3];
    this.offset += 4;
    return this.convInt32[0]
};
InputStream.prototype.getUint32 = function () {
    var a = this.buffer,
        b = this.convUint8,
        c = this.offset;
    b[0] = a[c];
    b[1] = a[c + 1];
    b[2] = a[c + 2];
    b[3] = a[c + 3];
    this.offset += 4;
    return this.convUint32[0]
};
InputStream.prototype.getFloat32 = function () {
    var a = this.buffer,
        b = this.convUint8,
        c = this.offset;
    b[0] = a[c];
    b[1] = a[c + 1];
    b[2] = a[c + 2];
    b[3] = a[c + 3];
    this.offset += 4;
    return this.convFloat32[0]
};
InputStream.prototype.getFloat64 = function () {
    for (var a = this.buffer, b = this.convUint8, c = this.offset, e = 0; 8 > e; e++) b[e] = a[c + e];
    this.offset += 8;
    return this.convFloat64[0]
};
InputStream.prototype.getString = function (a) {
    for (var b = this.buffer, c = "", e = this.offset, d = this.offset + a; e < d; e++) c += String.fromCharCode(b[e]);
    this.offset += a;
    return decodeURIComponent(escape(c))
};

function PackFileReader(a) {
    31 == a[0] && 139 == a[1] && (a = (new Zlib.Gunzip(a)).decompress());
    this.tempQuat = new THREE.Quaternion;
    this.tempTrans = new THREE.Vector3;
    this.tempScale = new THREE.Vector3;
    this.tempMat = new THREE.Matrix4;
    a = this.stream = new InputStream(a);
    var b = a.getInt32();
    this.type = a.getString(b);
    this.version = a.getInt32();
    this.types = null;
    this.entryOffsets = [];
    a.seek(a.byteLength - 8);
    var c = a.getUint32();
    this.typesOffset = a.getUint32();
    a.seek(this.typesOffset);
    var e = this.readU32V();
    this.types = [];
    for (b = 0; b <
        e; ++b) this.types.push({
        entryClass: this.readString(),
        entryType: this.readString(),
        version: this.readU32V()
    });
    a.seek(c);
    c = this.readU32V();
    e = this.entryOffsets;
    for (b = 0; b < c; ++b) e.push(a.getUint32());
    a.seek(0)
}
PackFileReader.prototype.readVarint = function () {
    var a, b = 0,
        c = 0;
    do a = this.stream.getUint8(), b |= (a & 127) << c, c += 7; while (a & 128);
    return b
};
PackFileReader.prototype.readU32V = PackFileReader.prototype.readVarint;
PackFileReader.prototype.readString = function () {
    return this.stream.getString(this.readU32V())
};
PackFileReader.prototype.readVector3f = function () {
    var a = this.stream;
    return new THREE.Vector3(a.getFloat32(), a.getFloat32(), a.getFloat32())
};
PackFileReader.prototype.readTransform = function (a, b, c) {
    function e(a) {
        a.set(f.getFloat32(), f.getFloat32(), f.getFloat32(), f.getFloat32())
    }

    function d(a) {
        a.set(f.getFloat64(), f.getFloat64(), f.getFloat64())
    }

    function g() {
        m.identity();
        for (var a = 0; 3 > a; ++a)
            for (var b = 0; 3 > b; ++b) m.elements[4 * a + b] = f.getFloat32()
    }
    var f = this.stream,
        k = this.tempTrans,
        h = this.tempQuat,
        l = this.tempScale,
        m = this.tempMat;
    switch (f.getUint8()) {
    case 4:
        m.identity();
        break;
    case 0:
        d(k);
        m.makeTranslation(k.x, k.y, k.z);
        break;
    case 1:
        e(h);
        d(k);
        m.compose(k,
            h, l.set(1, 1, 1));
        break;
    case 2:
        var n = f.getFloat32();
        e(h);
        d(k);
        m.compose(k, h, l.set(n, n, n));
        break;
    case 3:
        g(), d(k), m.setPosition(k)
    }
    if (void 0 !== a)
        for (a = m.elements, k = 0; 16 > k; k++) b[c++] = a[k];
    else return (new THREE.Matrix4).copy(m)
};
PackFileReader.prototype.getEntryCounts = function () {
    return this.entryOffsets.length
};
PackFileReader.prototype.seekToEntry = function (a) {
    var b = this.getEntryCounts();
    if (a >= b) return null;
    this.stream.seek(this.entryOffsets[a]);
    a = this.stream.getUint32();
    return a >= this.types.length ? null : this.types[a]
};
PackFileReader.prototype.readPathID = function () {
    var a = this.stream;
    if (2 > this.version) {
        var b = a.getUint16();
        if (!b) return null;
        a.getUint16();
        if (1 == b) return "";
        for (var c = a.getUint16(), e = 2; e < b; ++e) c += "/" + a.getUint16()
    } else {
        b = this.readU32V();
        if (!b) return null;
        this.readU32V();
        if (1 == b) return "";
        c = this.readU32V();
        for (e = 2; e < b; ++e) c += "/" + this.readU32V()
    }
    return c
};

function PropertyDatabase(a) {
    function b(a) {
        for (var b = "", c = 0; c < a.length; c++) b += String.fromCharCode(a[c]);
        a = decodeURIComponent(escape(b));
        return JSON.parse(a)
    }

    function c(a, b) {
        for (var c = b, d = ""; c < a.length - 1;) {
            var e = a[c];
            if (44 == e && (10 == a[c + 1] || 13 == a[c + 1])) break;
            if (10 == e || 13 == e) break;
            d += String.fromCharCode(e);
            c++
        }
        c = decodeURIComponent(escape(d));
        return JSON.parse(c)
    }

    function e(a, b) {
        for (var c = 0, d = 0, e = a.length; d < e; d++) 44 == a[d] && c++;
        c++;
        for (var e = new Uint32Array(c + (b ? 1 : 0)), d = 0, f = a.length; 91 != a[d] && d < f;) d++;
        if (d == a.length) return null;
        d++;
        for (var g = !1, k = c = 0; d < f;) {
            var h = a[d];
            48 <= h && 57 >= h ? (k = 10 * k + (h - 48), g = !0) : 44 == h || 93 == h ? g && (e[c++] = k, g = !1, k = 0) : (g = !1, k = 0);
            d++
        }
        return e
    }

    function d(a) {
        for (var b = 0, c = a.length - 1, d = 0; d < c; d++) 44 != a[d] || 10 != a[d + 1] && 13 != a[d + 1] || b++;
        if (!b) return null;
        b++;
        for (var e = new Uint32Array(b), b = d = 0; 91 != a[d] && d < c;) d++;
        d++;
        e[b++] = d;
        for (var f = !1; d < c;) 10 == a[d] || 13 == a[d] ? f = !0 : f && (f = !1, e[b++] = d), d++;
        return e
    }
    var g, f, k, h, l, m, n, r, s, t, p;
    for (p in a.attrs) {
        g = b(a.attrs[p]);
        for (var u = 0; u < g.length; u++) {
            var v =
                g[u][1];
            "__parent__" == v ? s = u : "__child__" == v ? r = u : "__name__" == v && (t = u)
        }
        break
    }
    for (p in a.avs) {
        k = e(a.avs[p], 0);
        delete a.avs;
        break
    }
    for (p in a.offsets) {
        f = e(a.offsets[p], 1);
        f[f.length - 1] = k.length / 2;
        delete a.offsets;
        break
    }
    for (p in a.values) {
        h = a.values[p];
        l = d(h);
        break
    }
    for (p in a.ids) {
        m = a.ids[p];
        n = d(m);
        break
    }
    this.getObjectCount = function () {
        return f.length - 1
    };
    this.getValueAt = function (a) {
        return c(h, l[a])
    };
    this.getIntValueAt = function (a) {
        var b = 0;
        a = l[a];
        for (34 == h[a] && a++; a < h.length - 1;) {
            var c = h[a];
            if (44 == c && (10 == h[a +
                1] || 13 == h[a + 1] || 34 == h[a + 1])) break;
            if (10 == c || 13 == c) break;
            48 <= c && 57 >= c && (b += 10 * b + (c - 48));
            a++
        }
        return b
    };
    this.getIdAt = function (a) {
        return c(m, n[a])
    };
    this.getObjectProperties = function (a) {
        var b = {
                dbId: a,
                name: "",
                properties: []
            },
            c = 2 * f[a + 1];
        for (a = 2 * f[a]; a < c; a += 2) {
            var d = k[a];
            if (d == t) d = this.getValueAt(k[a + 1]), b.name = d;
            else if (d != s && d != r) {
                var e = g[d],
                    d = this.getValueAt(k[a + 1]),
                    h = e[5] ? e[5] : e[0];
                null != e[3] ? b.properties.push({
                    displayName: h,
                    displayValue: d + " " + e[3]
                }) : b.properties.push({
                    displayName: h,
                    displayValue: d
                })
            }
        }
        return b
    };
    this.findRootNodes = function () {
        for (var a = [], b = 1, c = f.length; b < c; b++) {
            for (var d = !1, e = !1, g = !1, h = 2 * f[b + 1], l = 2 * f[b]; l < h; l += 2) {
                var m = k[l];
                m == s ? this.getIntValueAt(k[l + 1]) && (e = !0) : m == r ? d = !0 : m == t && (g = !0)
            }
            d && g && !e && a.push(b)
        }
        return a
    };
    this.getNodeNameAndChildren = function (a) {
        for (var b = a.dbId, c = 2 * f[b + 1], d, b = 2 * f[b]; b < c; b += 2) {
            var e = k[b];
            e != s && (e == r ? (e = this.getValueAt(k[b + 1]), e = {
                dbId: e,
                parent: a
            }, d ? d.push(e) : d = [e]) : e == t && (e = this.getValueAt(k[b + 1]), a.name = e))
        }
        return d
    };
    this.buildObjectTree = function (a, b, c, d) {
        c > d[0] &&
            (d[0] = c);
        var e = this.getNodeNameAndChildren(a);
        if (e) {
            for (var f = 0; f < e.length; f++) this.buildObjectTree(e[f], b, c + 1, d);
            for (f = 0; f < e.length; f++)
                if (e[f].children || void 0 !== e[f].fragIds) a.children ? a.children.push(e[f]) : a.children = [e[f]]
        } else b = b[a.dbId], void 0 !== b && (a.fragIds = b)
    };
    this.bruteForceSearch = function (a) {
        a = a.toLowerCase();
        for (var b = [], c = [], d = 0, e = l.length; d < e; d++) {
            var g = this.getValueAt(d);
            "string" == typeof g ? -1 != g.toLowerCase().indexOf(a) && c.push(d) : -1 != g.toString().toLowerCase().indexOf(a) && c.push(d)
        }
        a =
            1;
        for (e = f.length; a < e; a++)
            for (g = 2 * f[a + 1], d = 2 * f[a]; d < g; d += 2)
                if (-1 != c.indexOf(k[d + 1])) {
                    b.push(a);
                    break
                }
        return b
    }
};
var Auth = function () {
    var a = function () {};
    a.prototype.configureOAuthNone = function () {
        this.oauthNone = !0;
        this.oauth2 = this.oauth1 = this.oauth0 = !1
    };
    a.prototype.configureOAuthZero = function (a) {
        this.oauthNone = !1;
        this.oauth0 = !0;
        this.oauth2 = this.oauth1 = !1;
        this.access_token = a
    };
    a.prototype.configureOAuthOne = function (a, c, e, d) {
        this.oauth0 = this.oauthNone = !1;
        this.oauth1 = !0;
        this.oauth2 = !1;
        this.oauth1msg = {
            method: "",
            action: "",
            parameters: {
                oauth_version: "1.0",
                oauth_consumer_key: a,
                oauth_timestamp: OAuth.timestamp(),
                oauth_nonce: OAuth.nonce(11),
                oauth_signature_method: "HMAC-SHA1",
                oauth_token: e
            }
        };
        this.oauth1accessor = {
            consumerSecret: c,
            tokenSecret: d
        }
    };
    a.prototype.configureOAuthTwo = function () {
        this.oauth1 = this.oauth0 = this.oauthNone = !1;
        this.oauth2 = !0;
        var a = new XMLHttpRequest;
        a.open("POST", "https://ec2-50-19-204-59.compute-1.amazonaws.com:19031/as/token.oauth2?client_id=vs-test-2leg&client_secret=Passw0rd1&grant_type=client_credentials", !1);
        a.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
        a.setRequestHeader("Access-Control-Allow-Origin",
            "*");
        a.send();
        200 == a.status && (this.access_token = JSON.parse(a.responseText).access_token, console.log("access token : " + this.access_token))
    };
    a.prototype.getAuthHeader = function (a, c) {
        if (this.oauth2) return "Bearer " + this.access_token;
        this.oauth1msg.method = a;
        this.oauth1msg.action = c;
        OAuth.completeRequest(this.oauth1msg, this.oauth1accessor);
        var e = c;
        0 <= e.indexOf("?") && (e = e.substring(0, e.indexOf("?")));
        0 <= e.indexOf("#") && (e = e.substring(0, e.indexOf("#")));
        return OAuth.getAuthorizationHeader(e, this.oauth1msg.parameters)
    };
    return a
}();
var OAuth;
null == OAuth && (OAuth = {});

function b64_hmac_sha1(a, b, c, e) {
    function d(a, b) {
        var c = (a & 65535) + (b & 65535);
        return (a >> 16) + (b >> 16) + (c >> 16) << 16 | c & 65535
    }

    function g(a, b) {
        a[b >> 5] |= 128 << 24 - b % 32;
        a[(b + 64 >> 9 << 4) + 15] = b;
        for (var c = [80], e = 1732584193, f = -271733879, g = -1732584194, s = 271733878, t = -1009589776, p = 0; p < a.length; p += 16) {
            for (var u = e, v = f, w = g, y = s, x = t, A = 0; 80 > A; A++) {
                if (16 > A) c[A] = a[p + A];
                else {
                    var N = c[A - 3] ^ c[A - 8] ^ c[A - 14] ^ c[A - 16];
                    c[A] = N << 1 | N >>> 31
                }
                var N = e << 5 | e >>> 27,
                    B;
                B = 20 > A ? f & g | ~f & s : 40 > A ? f ^ g ^ s : 60 > A ? f & g | f & s | g & s : f ^ g ^ s;
                N = d(d(N, B), d(d(t, c[A]), 20 > A ? 1518500249 :
                    40 > A ? 1859775393 : 60 > A ? -1894007588 : -899497514));
                t = s;
                s = g;
                g = f << 30 | f >>> 2;
                f = e;
                e = N
            }
            e = d(e, u);
            f = d(f, v);
            g = d(g, w);
            s = d(s, y);
            t = d(t, x)
        }
        return [e, f, g, s, t]
    }

    function f(a) {
        for (var b = [], c = (1 << e) - 1, d = 0; d < a.length * e; d += e) b[d >> 5] |= (a.charCodeAt(d / 8) & c) << 32 - e - d % 32;
        return b
    }
    c || (c = "=");
    e || (e = 8);
    return function (a) {
        for (var b = "", d = 0; d < 4 * a.length; d += 3)
            for (var e = (a[d >> 2] >> 8 * (3 - d % 4) & 255) << 16 | (a[d + 1 >> 2] >> 8 * (3 - (d + 1) % 4) & 255) << 8 | a[d + 2 >> 2] >> 8 * (3 - (d + 2) % 4) & 255, f = 0; 4 > f; f++) b = 8 * d + 6 * f > 32 * a.length ? b + c : b + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e >>
                6 * (3 - f) & 63);
        return b
    }(function (a, b) {
        var c = f(a);
        16 < c.length && (c = g(c, a.length * e));
        for (var d = [16], n = [16], r = 0; 16 > r; r++) d[r] = c[r] ^ 909522486, n[r] = c[r] ^ 1549556828;
        c = g(d.concat(f(b)), 512 + b.length * e);
        return g(n.concat(c), 672)
    }(a, b))
}
OAuth.setProperties = function (a, b) {
    if (null != a && null != b)
        for (var c in b) a[c] = b[c];
    return a
};
OAuth.setProperties(OAuth, {
    percentEncode: function percentEncode(b) {
        if (null == b) return "";
        if (b instanceof Array) {
            for (var c = ""; 0 < b.length; ++b) "" != c && (c += "&"), c += percentEncode(b[0]);
            return c
        }
        b = encodeURIComponent(b);
        b = b.replace(/\!/g, "%21");
        b = b.replace(/\*/g, "%2A");
        b = b.replace(/\'/g, "%27");
        b = b.replace(/\(/g, "%28");
        return b = b.replace(/\)/g, "%29")
    },
    decodePercent: function (a) {
        null != a && (a = a.replace(/\+/g, " "));
        return decodeURIComponent(a)
    },
    getParameterList: function (a) {
        if (null == a) return [];
        if ("object" != typeof a) return decodeForm(a +
            "");
        if (a instanceof Array) return a;
        var b = [],
            c;
        for (c in a) b.push([c, a[c]]);
        return b
    },
    getParameterMap: function getParameterMap(b) {
        if (null == b) return {};
        if ("object" != typeof b) return getParameterMap(decodeForm(b + ""));
        if (b instanceof Array) {
            for (var c = {}, e = 0; e < b.length; ++e) {
                var d = b[e][0];
                void 0 === c[d] && (c[d] = b[e][1])
            }
            return c
        }
        return b
    },
    getParameter: function (a, b) {
        if (a instanceof Array)
            for (var c = 0; c < a.length; ++c) {
                if (a[c][0] == b) return a[c][1]
            } else return OAuth.getParameterMap(a)[b];
        return null
    },
    formEncode: function (a) {
        var b =
            "";
        a = OAuth.getParameterList(a);
        for (var c = 0; c < a.length; ++c) {
            var e = a[c][1];
            null == e && (e = "");
            "" != b && (b += "&");
            b += OAuth.percentEncode(a[c][0]) + "=" + OAuth.percentEncode(e)
        }
        return b
    },
    decodeForm: function (a) {
        var b = [];
        a = a.split("&");
        for (var c = 0; c < a.length; ++c) {
            var e = a[c];
            if ("" != e) {
                var d = e.indexOf("="),
                    g;
                0 > d ? (g = OAuth.decodePercent(e), e = null) : (g = OAuth.decodePercent(e.substring(0, d)), e = OAuth.decodePercent(e.substring(d + 1)));
                b.push([g, e])
            }
        }
        return b
    },
    setParameter: function (a, b, c) {
        var e = a.parameters;
        if (e instanceof Array) {
            for (a = 0; a < e.length; ++a) e[a][0] == b && (void 0 === c ? e.splice(a, 1) : (e[a][1] = c, c = void 0));
            void 0 !== c && e.push([b, c])
        } else e = OAuth.getParameterMap(e), e[b] = c, a.parameters = e
    },
    setParameters: function (a, b) {
        for (var c = OAuth.getParameterList(b), e = 0; e < c.length; ++e) OAuth.setParameter(a, c[e][0], c[e][1])
    },
    completeRequest: function (a, b) {
        null == a.method && (a.method = "GET");
        var c = OAuth.getParameterMap(a.parameters);
        null == c.oauth_consumer_key && OAuth.setParameter(a, "oauth_consumer_key", b.consumerKey || "");
        null == c.oauth_token &&
            null != b.token && OAuth.setParameter(a, "oauth_token", b.token);
        null == c.oauth_version && OAuth.setParameter(a, "oauth_version", "1.0");
        null == c.oauth_timestamp && OAuth.setParameter(a, "oauth_timestamp", OAuth.timestamp());
        null == c.oauth_nonce && OAuth.setParameter(a, "oauth_nonce", OAuth.nonce(6));
        OAuth.SignatureMethod.sign(a, b)
    },
    setTimestampAndNonce: function (a) {
        OAuth.setParameter(a, "oauth_timestamp", OAuth.timestamp());
        OAuth.setParameter(a, "oauth_nonce", OAuth.nonce(6))
    },
    addToURL: function (a, b) {
        newURL = a;
        if (null != b) {
            var c =
                OAuth.formEncode(b);
            0 < c.length && (newURL = 0 > a.indexOf("?") ? newURL + "?" : newURL + "&", newURL += c)
        }
        return newURL
    },
    getAuthorizationHeader: function (a, b) {
        for (var c = 'OAuth realm="' + OAuth.percentEncode(a) + '"', e = OAuth.getParameterList(b), d = 0; d < e.length; ++d) {
            var g = e[d],
                f = g[0];
            0 == f.indexOf("oauth_") && (c += "," + OAuth.percentEncode(f) + '="' + OAuth.percentEncode(g[1]) + '"')
        }
        return c
    },
    timestamp: function () {
        return Math.floor((new Date).getTime() / 1E3)
    },
    nonce: function (a) {
        for (var b = OAuth.nonce.CHARS, c = "", e = 0; e < a; ++e) var d = Math.floor(Math.random() *
                b.length),
            c = c + b.substring(d, d + 1);
        return c
    }
});
OAuth.nonce.CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
OAuth.declareClass = function (a, b, c) {
    var e = a[b];
    a[b] = c;
    if (null != c && null != e)
        for (var d in e) "prototype" != d && (c[d] = e[d]);
    return c
};
OAuth.declareClass(OAuth, "SignatureMethod", function () {});
OAuth.setProperties(OAuth.SignatureMethod.prototype, {
    sign: function (a) {
        var b = OAuth.SignatureMethod.getBaseString(a),
            b = this.getSignature(b);
        OAuth.setParameter(a, "oauth_signature", b);
        return b
    },
    initialize: function (a, b) {
        var c;
        c = null != b.accessorSecret && 9 < a.length && "-Accessor" == a.substring(a.length - 9) ? b.accessorSecret : b.consumerSecret;
        this.key = OAuth.percentEncode(c) + "&" + OAuth.percentEncode(b.tokenSecret)
    }
});
OAuth.setProperties(OAuth.SignatureMethod, {
    sign: function (a, b) {
        var c = OAuth.getParameterMap(a.parameters).oauth_signature_method;
        if (null == c || "" == c) c = "HMAC-SHA1", OAuth.setParameter(a, "oauth_signature_method", c);
        OAuth.SignatureMethod.newMethod(c, b).sign(a)
    },
    newMethod: function (a, b) {
        var c = OAuth.SignatureMethod.REGISTERED[a];
        if (null != c) {
            var e = new c;
            e.initialize(a, b);
            return e
        }
        var c = Error("signature_method_rejected"),
            d = "";
        for (e in OAuth.SignatureMethod.REGISTERED) "" != d && (d += "&"), d += OAuth.percentEncode(e);
        c.oauth_acceptable_signature_methods = d;
        throw c;
    },
    REGISTERED: {},
    registerMethodClass: function (a, b) {
        for (var c = 0; c < a.length; ++c) OAuth.SignatureMethod.REGISTERED[a[c]] = b
    },
    makeSubclass: function (a) {
        var b = OAuth.SignatureMethod,
            c = function () {
                b.call(this)
            };
        c.prototype = new b;
        c.prototype.getSignature = a;
        return c.prototype.constructor = c
    },
    getBaseString: function (a) {
        var b = a.action,
            c = b.indexOf("?");
        if (0 > c) c = a.parameters;
        else
            for (var c = OAuth.decodeForm(b.substring(c + 1)), e = OAuth.getParameterList(a.parameters), d = 0; d < e.length; ++d) c.push(e[d]);
        return OAuth.percentEncode(a.method.toUpperCase()) + "&" + OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(b)) + "&" + OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(c))
    },
    normalizeUrl: function (a) {
        var b = OAuth.SignatureMethod.parseUri(a);
        a = b.protocol.toLowerCase();
        var c = b.authority.toLowerCase();
        if ("http" == a && 80 == b.port || "https" == a && 443 == b.port) {
            var e = c.lastIndexOf(":");
            0 <= e && (c = c.substring(0, e))
        }(b = b.path) || (b = "/");
        return a + "://" + c + b
    },
    parseUri: function (a) {
        var b = "source protocol authority userInfo user password host port relative path directory file query anchor".split(" ");
        a = /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(a);
        for (var c = {}, e = 14; e--;) c[b[e]] = a[e] || "";
        return c
    },
    normalizeParameters: function (a) {
        if (null == a) return "";
        var b = OAuth.getParameterList(a);
        a = [];
        for (var c = 0; c < b.length; ++c) {
            var e = b[c];
            "oauth_signature" != e[0] && a.push([OAuth.percentEncode(e[0]) + " " + OAuth.percentEncode(e[1]), e])
        }
        a.sort(function (a, b) {
            return a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0
        });
        b = [];
        for (c = 0; c < a.length; ++c) b.push(a[c][1]);
        return OAuth.formEncode(b)
    }
});
OAuth.SignatureMethod.registerMethodClass(["PLAINTEXT", "PLAINTEXT-Accessor"], OAuth.SignatureMethod.makeSubclass(function (a) {
    return this.key
}));
OAuth.SignatureMethod.registerMethodClass(["HMAC-SHA1", "HMAC-SHA1-Accessor"], OAuth.SignatureMethod.makeSubclass(function (a) {
    b64pad = "=";
    return b64_hmac_sha1(this.key, a, null, null)
}));
var VIEWER2D_NAVIGATION_MODE = {
    PAN: 1,
    ZOOM: 2
};

function Viewer2DImpl(a, b) {
    this.api = a;
    this.config = b;
    this.parent = b.domElement;
    this.navigationMode = null
}
Viewer2DImpl.prototype.constructor = Viewer2DImpl;
Viewer2DImpl.prototype.initialize = function () {
    var a = document.createElement("canvas");
    a.width = 1;
    a.height = 1;
    this.selCtx = a.getContext("2d");
    this.selCtx.globalCompositeOperation = "copy";
    this.selCtx.imageSmoothingEnabled = !1;
    this.container = document.createElement("div");
    this.container.style.width = "100%";
    this.container.style.height = "100%";
    this.parent.appendChild(this.container);
    return !0
};
Viewer2DImpl.prototype.load = function (a) {
    var b = this.config.tileSize ? this.config.tileSize : 1024,
        c = this.config.maxZoom ? this.config.maxZoom : 6,
        e = a.indexOf("urn:"); - 1 != e && (a = a.substr(0, e) + encodeURIComponent(a.substr(e)));
    var e = [a],
        d = [];
    for (a = 0; a < e.length; a++) {
        var g = L.tileLayer(e[a] + "/{z}/{x}/c{y}.png", {
            maxZoom: c,
            noWrap: !0,
            continuousWorld: !1,
            detectRetina: !0,
            tileSize: b
        });
        d.push(g)
    }
    var f = this.map = L.map(this.container, {
        center: new L.LatLng(0, 0),
        zoom: 0,
        zoomControl: !1,
        attributionControl: !1,
        layers: [d[0]]
    });
    f.options.crs.scale =
        function (a) {
            return b * Math.pow(2, a)
    };
    c = {};
    for (a = 0; a < e.length; a++) c[e[a]] = d[3 * a];
    L.control.layers(c, void 0).addTo(f);
    c = document.getElementsByClassName("leaflet-control-layers");
    for (a = 0; a < c.length; a++) c[a].style.visibility = "hidden";
    f.on("baselayerchange", function (a) {
        console.log(a);
        var b = [],
            c;
        for (c in f._layers) {
            var d = f._layers[c];
            d != a.layer && b.push(d)
        }
        for (c = 0; c < b.length; c++) f.removeLayer(b[c]);
        a.layer.idTileLayer && (f.addLayer(a.layer.idTileLayer), f.addLayer(a.layer.canvasLayer))
    });
    var k = this,
        h = !1,
        l,
        m, n, r, s;
    this.mousemove = function (a) {
        if (h && k.navigationMode === VIEWER2D_NAVIGATION_MODE.ZOOM) {
            var b = a.clientX - l,
                c = a.clientY - m,
                c = -c;
            if (2 < Math.abs(b) || 2 < Math.abs(c)) b = Math.abs(b) > Math.abs(c) ? b : c, b = Math.round(n + b / s), b = Math.max(f.getMinZoom(), Math.min(b, f.getMaxZoom())), f.setZoomAround(r, b, {
                animate: !0
            }), a.preventDefault(), a.stopPropagation()
        }
    };
    f.on("mousedown", function (a) {
        h = !0;
        if (k.navigationMode === VIEWER2D_NAVIGATION_MODE.ZOOM) {
            l = a.originalEvent.clientX;
            m = a.originalEvent.clientY;
            n = f.getZoom();
            r = f.getCenter();
            var b = f.getSize(),
                b = b.x < b.y ? b.x : b.y,
                c = f.getMaxZoom() - f.getMinZoom();
            s = b / (2 * c);
            f.scrollWheelZoom.disable();
            window.addEventListener("mousemove", k.mousemove, !1);
            a.originalEvent.preventDefault();
            a.originalEvent.stopPropagation()
        }
    });
    f.on("mouseup", function (a) {
        h = !1;
        k.navigationMode === VIEWER2D_NAVIGATION_MODE.ZOOM && (f.scrollWheelZoom.enable(), window.removeEventListener("mousemove", k.mousemove, !1), a.originalEvent.preventDefault(), a.originalEvent.stopPropagation())
    });
    this.setNavigationMode(VIEWER2D_NAVIGATION_MODE.PAN);
    this.keyup = function (a) {
        var b = document.activeElement.nodeName;
        if ("INPUT" !== b && "TEXTAREA" !== b) {
            b = !1;
            if (27 === a.keyCode) k.api.fireEvent({
                type: Autodesk.Viewing.ESCAPE_EVENT
            }), b = !0;
            else if (36 === a.keyCode || 70 === a.keyCode || 72 === a.keyCode) k.goHome(), b = !0;
            b && (a.preventDefault(), a.stopPropagation())
        }
    };
    window.addEventListener("keyup", this.keyup, !1);
    f.fitWorld();
    return !0
};
Viewer2DImpl.prototype.uninitialize = function () {
    window.removeEventListener("mousemove", this.mousemove, !1);
    window.removeEventListener("keyup", this.keyup, !1);
    this.map.remove()
};
Viewer2DImpl.prototype.resize = function () {
    this.map.invalidateSize(!1)
};
Viewer2DImpl.prototype.setNavigationMode = function (a) {
    var b = !1;
    this.navigationMode !== a && (this.navigationMode = a, this.map && (a === VIEWER2D_NAVIGATION_MODE.PAN ? (this.map.dragging.enable(), window.removeEventListener("mousemove", this.mousemove, !1)) : a === VIEWER2D_NAVIGATION_MODE.ZOOM && this.map.dragging.disable()), this.api.fireEvent({
        type: Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT,
        value: a
    }), b = !0);
    return b
};
Viewer2DImpl.prototype.goHome = function () {
    this.map.setView([0, 0], 0, {
        reset: !0
    })
};
var Xhr = function () {
        var a = function (a, c, e) {
            this.xhr = new XMLHttpRequest;
            this.errorHandler = a;
            this.success = !1;
            this.viewing_url = e;
            void 0 != c && (this.auth = new Auth, c.oauth0 ? this.auth.configureOAuthZero(c.access_token) : c.oauth1 ? this.auth.configureOAuthOne(c.oauth1msg.parameters.oauth_consumer_key, c.oauth1accessor.consumerSecret, c.oauth1msg.parameters.oauth_token, c.oauth1accessor.tokenSecret) : c.oauth2 ? this.auth.configureOAuthTwo() : c.oauthNone && this.auth.configureOAuthNone())
        };
        a.prototype.get = function (a, c, e,
            d) {
            function g() {
                4 === k.xhr.readyState && k.xhr.status && 200 != k.xhr.status ? k.errorHandler && k.errorHandler.unsuccessfulResponse(a, k.xhr.status, k.xhr.statusText) : k.success = !0
            }
            var f = a.indexOf("urn:"); - 1 != f && (a = this.viewing_url + "/items/" + encodeURIComponent(a.substr(f)), this.auth.oauth0 ? a = a + "?oauth_token=" + encodeURIComponent(this.auth.access_token) : !0 != this.auth.oauthNone ? c.Authorization = this.auth.getAuthHeader("GET", a) : this.auth.oauthNone && (c["Access-Control-Allow-Credentials"] = !0), c["Access-Control-Allow-Origin"] =
                "*");
            var k = this;
            try {
                this.xhr.open("GET", a, !!d);
                this.xhr.responseType = e;
                this.success = !1;
                this.auth && this.auth.oauthNone && (this.xhr.withCredentials = !0);
                d && (this.xhr.onload = d);
                this.xhr.onerror = g;
                for (var h in c) this.xhr.setRequestHeader(h, c[h]);
                this.xhr.send()
            } catch (l) {
                return this.errorHandler && this.errorHandler.networkFailure(a, l), null
            }
            g();
            return this.xhr.response
        };
        a.prototype.post = function (a, c, e, d) {
            try {
                this.xhr.open("POST", a, !1);
                this.xhr.responseType = d;
                this.success = !1;
                this.auth && this.auth.oauthNone &&
                    (this.xhr.withCredentials = !0);
                for (var g in c) this.xhr.setRequestHeader(g, c[g]);
                this.xhr.send(e)
            } catch (f) {
                return this.errorHandler && this.errorHandler.networkFailure(a, f), null
            }
            4 === this.xhr.readyState && this.xhr.status && 200 != this.xhr.status ? this.errorHandler && this.errorHandler.unsuccessfulResponse(a, this.xhr.status, this.xhr.statusText) : this.success = !0;
            return this.xhr.response
        };
        return a
    }(),
    XhrErrorHandler = function () {
        var a = function (a) {
            this.host = a;
            this.ignoreFileNotFound = !1
        };
        a.prototype.networkFailure = function (a,
            c) {
            this.host.raiseError(Autodesk.Viewing.ErrorCodes.NETWORK_FAILURE, "Network failure", {
                url: a,
                exception: c.toString(),
                stack: c.stack
            })
        };
        a.prototype.unsuccessfulResponse = function (a, c, e) {
            403 == c ? this.host.raiseError(Autodesk.Viewing.ErrorCodes.NETWORK_ACCESS_DENIED, "Access denied to remote resource", {
                url: a,
                httpStatus: c,
                httpStatusText: e
            }) : 404 == c ? this.ignoreFileNotFound || this.host.raiseError(Autodesk.Viewing.ErrorCodes.NETWORK_FILE_NOT_FOUND, "Remote resource not found", {
                url: a,
                httpStatus: c,
                httpStatusText: e
            }) :
                500 <= c && 600 > c ? this.host.raiseError(Autodesk.Viewing.ErrorCodes.NETWORK_SERVER_ERROR, "Server error when accessing resource", {
                    url: a,
                    httpStatus: c,
                    httpStatusText: e
                }) : this.host.raiseError(Autodesk.Viewing.ErrorCodes.NETWORK_UNHANDLED_RESPONSE_CODE, "Unhandled response code from server", {
                    url: a,
                    httpStatus: c,
                    httpStatusText: e
                })
        };
        return a
    }();
var propdb = null,
    propdbFailed = !1;

function loadAsyncResource(a, b, c) {}

function loadPropertyPacks(a, b) {
    if (propdb) return !0;
    if (propdbFailed) return !1;
    var c = a.propertydb,
        e = {
            ids: {},
            attrs: {},
            offsets: {},
            values: {},
            avs: {}
        },
        d = 0,
        g, f;
    g = c.attrs.length ? c.attrs[0] : "objects_attrs.json.gz";
    (f = requestFile(a.url + g, a)) && (e.attrs[g] = f);
    d += !!f;
    g = c.values.length ? c.values[0] : "objects_vals.json.gz";
    (f = requestFile(a.url + g, a)) && (e.values[g] = f);
    d += !!f;
    g = c.avs.length ? c.avs[0] : "objects_avs.json.gz";
    (f = requestFile(a.url + g, a)) && (e.avs[g] = f);
    d += !!f;
    g = c.offsets.length ? c.offsets[0] : "objects_offs.json.gz";
    (f = requestFile(a.url + g, a)) && (e.offsets[g] = f);
    d += !!f;
    if (4 == d) return propdb = new PropertyDatabase(e), !0;
    g = "objects_attrs.json";
    f = requestFile(a.url + g, a);
    e.attrs[g] = f;
    d += !!f;
    g = "objects_vals.json";
    f = requestFile(a.url + g, a);
    e.values[g] = f;
    d += !!f;
    g = "objects_avs.json";
    f = requestFile(a.url + g, a);
    e.avs[g] = f;
    d += !!f;
    g = "objects_offs.json";
    f = requestFile(a.url + g, a);
    e.offsets[g] = f;
    if (4 == d + !!f) return propdb = new PropertyDatabase(e), !0;
    propdbFailed = !0;
    return !1
}

function doPropertyGet(a, b) {
    var c = b.dbId,
        e = null;
    loadPropertyPacks(b, c) && (e = propdb.getObjectProperties(c));
    a.postMessage({
        result: e,
        dbId: c
    })
}

function computeTreeBBoxes(a, b, c) {
    var e = 6 * a.dbId;
    b[e] = b[e + 1] = b[e + 2] = Infinity;
    b[e + 3] = b[e + 4] = b[e + 5] = -Infinity;
    var d = a.children;
    if (d)
        for (var g = 0, f = d.length; g < f; g++) {
            computeTreeBBoxes(d[g], b, c);
            for (var k = 6 * (d[g].dbId | 0), h = 0; 3 > h; h++) b[e + h] > b[k + h] && (b[e + h] = b[k + h]), b[e + h + 3] < b[k + h + 3] && (b[e + h + 3] = b[k + h + 3])
        }
    if (void 0 !== a.fragIds)
        if (!Array.isArray(a.fragIds))
            for (d = 6 * (a.fragIds | 0), h = 0; 3 > h; h++) b[e + h] > c[d + h] && (b[e + h] = c[d + h]), b[e + h + 3] < c[d + h + 3] && (b[e + h + 3] = c[d + h + 3]);
        else if (a.fragIds.length)
        for (g = 0; g < a.fragIds.length; g++)
            for (d =
                6 * (a.fragIds[g] | 0), h = 0; 3 > h; h++) b[e + h] > c[d + h] && (b[e + h] = c[d + h]), b[e + h + 3] < c[d + h + 3] && (b[e + h + 3] = c[d + h + 3])
}

function buildDbIdToFragMap(a) {
    for (var b = {}, c = 0, e = a.length; c < e; c++) {
        var d = a[c],
            g = b[d];
        void 0 === g ? b[d] = c : Array.isArray(g) ? g.push(c) : b[d] = [g, c]
    }
    return b
}

function doObjectTreeParse(a, b) {
    if (loadPropertyPacks(b, null)) {
        var c = buildDbIdToFragMap(b.fragToDbId),
            e = propdb.findRootNodes(),
            d, g = [0];
        if (1 == e.length) d = {
            dbId: e[0]
        }, propdb.buildObjectTree(d, c, 0, g);
        else {
            d = {
                dbId: 0,
                children: []
            };
            for (var f = 0; f < e.length; f++) {
                var k = {
                    dbId: e[f]
                };
                d.children.push(k);
                propdb.buildObjectTree(k, c, 0, g)
            }
        }
        a.postMessage({
            instanceTree: d,
            maxTreeDepth: g[0]
        });
        b.fragBoxes && (c = new Float32Array(6 * propdb.getObjectCount()), computeTreeBBoxes(d, c, b.fragBoxes), a.postMessage({
            instanceBoxes: c
        }))
    }
}

function doPropertySearch(a, b) {
    var c = [];
    loadPropertyPacks(b, null) && (c = propdb.bruteForceSearch(b.searchText));
    a.postMessage(c)
};

function doGeomLoad(a, b) {
    var c = new Xhr(b.errorHandler, b.auth, b.viewing_url),
        e = c.get(b.url, b.headers, "arraybuffer");
    if (c.success) {
        a.postMessage({
            url: b.url,
            workerId: b.workerId,
            progress: 0.5
        });
        try {
            var d = new PackFileReader(new Uint8Array(e))
        } catch (g) {
            a.raiseError(Autodesk.Viewing.ErrorCodes.BAD_DATA, "Unhandled exception while reading pack file", {
                url: b.url,
                exception: g.toString(),
                stack: g.stack
            });
            a.postMessage(null);
            return
        }
        for (var e = c = !1, f = 0, k = d.getEntryCounts(); f < k; f++) {
            try {
                var h = readGeometry(d, f, null)
            } catch (l) {
                e ||
                    (a.raiseError(Autodesk.Viewing.ErrorCodes.BAD_DATA, "Unhandled exception while reading geometry", {
                    url: b.url,
                    exception: l.toString(),
                    stack: l.stack
                }), c = e = !0), h = null
            }
            var m = {
                packId: b.packId,
                meshIndex: f,
                mesh: h,
                workerId: b.workerId,
                progress: 0.5 + (f + 1) / k * 0.5
            };
            h || c || (a.raiseError(Autodesk.Viewing.ErrorCodes.BAD_DATA, "Unable to load geometry", {
                url: b.url
            }), c = !0);
            a.postMessage(m)
        }
    } else a.postMessage(null)
};

function doLoadSvf(a, b) {
    b.basePath = "";
    var c = b.url.lastIndexOf("/"); - 1 != c && (b.basePath = b.url.substr(0, c + 1));
    var c = new Xhr(b.errorHandler, b.auth, b.viewing_url),
        e = c.get(b.url, b.headers, "arraybuffer");
    if (c.success) {
        a.postMessage({
            progress: 0.5
        });
        var d = new Package;
        b.loadDoneCB = function (c) {
            c ? a.postMessage({
                svf: d
            }) : (a.raiseError(Autodesk.Viewing.ErrorCodes.BAD_DATA, "Failure while loading SVF", {
                url: b.url
            }), a.postMessage(null))
        };
        try {
            d.load(b, new Uint8Array(e))
        } catch (g) {
            a.raiseError(Autodesk.Viewing.ErrorCodes.BAD_DATA,
                "Unhandled exception while loading SVF", {
                    url: b.url,
                    exception: g.toString(),
                    stack: g.stack
                }), a.postMessage(null)
        }
    } else a.postMessage(null)
};
var elementId2DbId = null,
    SKIP_OAUTH = !1;

function buildElementId2DbIdMapping(a) {
    if (elementId2DbId) return elementId2DbId;
    a = requestFile(a + "objects_ids.json.gz", {});
    elementId2DbId = {};
    if (a)
        for (var b = 1; b < a.length; ++b) elementId2DbId[a[b]] = b;
    return elementId2DbId
}

function query(a, b) {
    var c = {
        query: {
            match: {
                type: "bool",
                query: "keyword",
                searchFields: [{
                    fieldName: "content.name",
                    searchFlags: ["generic", "simple", "startsWith"]
                }]
            }
        },
        options: {
            paging: {
                first: 0,
                count: 10
            },
            restrictions: {
                sourceIds: [{
                    sourceSystem: "adsk.a360",
                    type: "file",
                    id: "samplelmv00001",
                    version: "samplelmvv01"
                }],
                tipVersionOnly: !0,
                childObjects: {
                    childSearchType: "parentsAndChildren"
                },
                accessEntities: [{
                    id: "ZD3ZLK7V8HWS",
                    type: "user",
                    accessProvider: "adsk.a360",
                    idProvider: "adsk.oxygen"
                }]
            }
        }
    };
    c.query.match.query = a;
    b &&
        (c.options.restrictions.sourceIds[0] = {
        sourceSystem: b.sourceSystem,
        type: b.type,
        id: b.id,
        version: b.version
    });
    debug("keyword: " + a);
    var c = JSON.stringify(c),
        e = new Xhr(new XhrErrorHandler(self), auth);
    SKIP_OAUTH ? c = e.post("http://ec2-50-17-84-60.compute-1.amazonaws.com:9000/search", {
        "Content-Type": "application/json"
    }, c, "text") : (c = e.post("https://search-dev.api.autodesk.com/search/v1", {
        Authorization: 'OAuth oauth_signature_method="HMAC-SHA1",oauth_version="1.0",oauth_nonce="U1KVox",oauth_timestamp="1392156436",oauth_consumer_key="0d9f8dae-8c36-4642-a511-0a70c8814fd9",oauth_token="",oauth_signature="TNLe5xGugp6HkqljjCxWKiMNkOI%3D"',
        "Access-Control-Allow-Origin": "*"
    }, c, "text"), debug("search worker debug response : " + c));
    return c
}

function debug(a) {
    self.postMessage(JSON.stringify({
        type: "debug",
        debug: a
    }))
}

function doSearch(a, b) {
    try {
        for (var c = buildElementId2DbIdMapping(b.url), e = JSON.parse(query(b.keyword, b.id)).results, d = [], g = 0; g < e.length; ++g) {
            var f = e[g].elementId;
            debug("id : " + f);
            d.push(c[f])
        }
        debug(d);
        a.postMessage(JSON.stringify({
            type: "response",
            response: d
        }))
    } catch (k) {
        c = k.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@").split("\n"), debug(k + "\n" + c), a.raiseError(Autodesk.Viewing.ErrorCodes.UNKNOWN_FAILURE, "Unhandled exception while performing search query", {
            exception: k.toString(),
            stack: k.stack
        })
    }
};
var ENABLE_OCTM_MG2 = !1,
    IS_WORKER = "undefined" !== typeof self && "undefined" === typeof window;
if (IS_WORKER) {
    IS_CONCAT_BUILD || (importScripts("../AutodeskNamespace.js"), importScripts("../compatibility.js"), importScripts("../render/adsk_three.js"), importScripts("../zlib/gunzip.min.js"), importScripts("../zlib/unzip.min.js"), ENABLE_OCTM_MG2 && (importScripts("../zlib/inflate.min.js"), importScripts("../lmvtk/octm_mg2.js")), importScripts("../lmvtk/packreader.js"), importScripts("../lmvtk/geoms.js"), importScripts("../lmvtk/materials.js"), importScripts("../lmvtk/lights.js"), importScripts("../lmvtk/cameras.js"),
        importScripts("../lmvtk/fragments.js"), importScripts("../lmvtk/instances.js"), importScripts("../lmvtk/package.js"), importScripts("../lmvtk/packreader.js"), importScripts("../lmvtk/propdb.js"), importScripts("../net/xhr.js"), importScripts("../auth/auth.js"), importScripts("../auth/oauth1.js"), importScripts("geomworker.js"), importScripts("svfworker.js"), importScripts("propworker.js"), importScripts("searchworker.js"), importScripts("../../api/Viewer.js"), importScripts("../../api/ErrorCodes.js"));
    self.addEventListener("message",
        function (a) {
            var b = a.data;
            b.errorHandler = new XhrErrorHandler(self);
            a = a.data.operation;
            "LOAD_GEOMETRY" == a ? doGeomLoad(self, b) : "LOAD_SVF" == a ? doLoadSvf(self, b) : "GET_PROPERTIES" == a ? doPropertyGet(self, b) : "SEARCH_PROPERTIES" == a ? doPropertySearch(self, b) : "GET_OBJECT_TREE" == a ? doObjectTreeParse(self, b) : "SEARCH" == a && doSearch(self, b)
        }, !1);
    self.raiseError = function (a, b, c) {
        self.postMessage({
            error: {
                code: a,
                msg: b,
                args: c
            }
        })
    };
    var requestFile = function (a, b) {
        b.errorHandler.ignoreFileNotFound = !0;
        var c = new Xhr(b.errorHandler,
            b.auth, b.viewing_url);
        if (-1 !== a.indexOf(".gz", a.length - 3)) {
            var e = c.get(a, b.headers, "arraybuffer");
            if (c.success) try {
                var d = new Uint8Array(e);
                31 == d[0] && 139 == d[1] && (d = (new Zlib.Gunzip(d)).decompress());
                return d
            } catch (g) {
                return self.raiseError(Autodesk.Viewing.ErrorCodes.BAD_DATA, "Malformed data received when requesting file", {
                    url: a,
                    exception: g.toString(),
                    stack: g.stack
                }), null
            } else return null
        } else return e = c.get(a, b.headers, "arraybuffer"), c.success ? new Uint8Array(e) : null
    }
};

function ViewController(a) {
    function b(a) {
        a = THREE.Math.degToRad(a);
        0 >= a && (a = 1E-4);
        return Math.round(m / Math.tan(0.5 * a))
    }

    function c(a) {
        0 >= a && (a = 1E-4);
        a = 2 * Math.atan(m / a);
        return THREE.Math.radToDeg(a)
    }

    function e(a) {
        u !== a && (v.api.fireEvent({
            type: Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT,
            value: a
        }), u = a)
    }

    function d(a, b, c) {
        b = 2 * b - 1;
        c = 2 * (1 - c) - 1;
        return (new CameraRaycaster(v, a)).castRayViewport(b, c, !1).intersectPoint
    }

    function g() {
        return z.ALT && z.SHIFT || z.LOCK_ROLL
    }

    function f() {
        return Q === t && !z.CONTROL && !z.SHIFT ||
            Q === s && (z.F2 || z.SPACE || z.LOCK_PAN) || Q === p && !z.ALT && !z.LOCK_PAN || ea.PAN
    }

    function k() {
        return -1 != navigator.userAgent.search("Mac OS") ? !z.CONTROL && z.SHIFT || z.LOCK_FOV : z.CONTROL && z.SHIFT || z.LOCK_FOV
    }
    var h = 0.5 * Math.PI,
        l = 2 * Math.PI;
    this.NAVIGATION_MODE = {
        ORBIT: 0,
        PAN: 1,
        DOLLY: 2,
        ROLL: 3,
        FOV: 4,
        OTHER: 5
    };
    var m = 12;
    this.setClickBehavior = function (a) {
        this.clickConfig = a
    };
    var n = function () {
        var a = new THREE.Matrix4,
            b = new THREE.Vector3,
            c = new THREE.Vector3,
            d = new THREE.Vector3;
        return function (e, f, g, k) {
            var h = a.elements;
            d.subVectors(g,
                f).normalize();
            0 === d.lengthSq() && (d.z = 1);
            b.crossVectors(k, d).normalize();
            0 === b.lengthSq() && (k.z > k.y ? d.y -= 1E-4 : d.z += 1E-4, b.crossVectors(k, d).normalize());
            c.crossVectors(d, b);
            h[0] = b.x;
            h[4] = c.x;
            h[8] = d.x;
            h[1] = b.y;
            h[5] = c.y;
            h[9] = d.y;
            h[2] = b.z;
            h[6] = c.z;
            h[10] = d.z;
            e.setRotationFromMatrix(a)
        }
    }();
    THREE.EventDispatcher.call(this);
    this.camera = a.camera;
    this.domElement = a.canvas;
    this.viewport = {
        left: 0,
        top: 0,
        width: 1,
        height: 1
    };
    this.downY = this.downX = -1;
    this.isDragging = !1;
    var r = new function (a) {
            var b = 0,
                c = 0,
                d = 0,
                e = 0,
                f = 4,
                g = 0.025,
                k = !1,
                m = !1,
                r = null,
                p = {
                    left: 0,
                    top: 0,
                    width: 1,
                    height: 1
                },
                s = new THREE.Vector3(0, 0, 0),
                t = a.position.clone(),
                u = new THREE.Vector2(0, 0),
                x = a.up.clone();
            this.saveCOI = function () {
                r = this.getPivotPoint().clone()
            };
            this.restoreCOI = function () {
                null !== r && (this.setPivotPoint(r, !0), r = null)
            };
            this.isDirty = function () {
                return k
            };
            this.setScreenViewport = function (a) {
                p = a
            };
            this.getPosition = function () {
                return t.clone().add(this.getViewOffset())
            };
            this.setPosition = function (a) {
                this.setView(a, s)
            };
            this.getPivotDistance = function () {
                return d
            };
            this.setPivotPoint = function (a, b) {
                if (b) {
                    var c = k,
                        d = this.getPosition(),
                        e = new THREE.Vector3;
                    e.subVectors(a, d);
                    var f = this.getCameraRightVector(),
                        g = this.getCameraUpVector(),
                        h = f.dot(e),
                        e = g.dot(e);
                    f.multiplyScalar(h);
                    g.multiplyScalar(e);
                    d.add(f);
                    d.add(g);
                    this.setView(d, a, -h, -e);
                    k = c
                } else this.setView(t, a)
            };
            this.getPivotPoint = function () {
                return s
            };
            this.getLookAtPoint = function () {
                return this.getEyeVector().add(t).add(this.getViewOffset())
            };
            this.getForwardLookAtPoint = function (b) {
                var c = this.getEyeVector().normalize(),
                    d = this.getPosition();
                b = (b = b(a, 0.5, 0.5)) ? b.sub(d).length() : 0.5 * (a.near + a.far);
                return d.add(c.multiplyScalar(b))
            };
            this.getCameraUpVector = function () {
                var a = this.getCameraRightVector(),
                    b = this.getEyeVector();
                return a.crossVectors(b, a).normalize()
            };
            this.getCameraRightVector = function () {
                var a = new THREE.Vector3,
                    b = this.getWorldUpVector(),
                    c = this.getEyeVector();
                c.set(-c.x, -c.y, -c.z);
                a.crossVectors(c, b);
                0 === a.lengthSq() && (b.z > b.y ? c.y -= 1E-4 : c.z += 1E-4, a.crossVectors(c, b));
                return a.normalize()
            };
            this.setWorldUpVector =
                function (b) {
                    x.copy(b);
                    x.normalize();
                    a.up = x;
                    this.setView(t, s, u.x, u.y)
            };
            this.getWorldUpVector = function () {
                return x.clone()
            };
            this.getWorldRightVector = function () {
                var a = this.getWorldUpVector();
                Math.abs(a.z) <= Math.abs(a.y) ? a.set(a.y, -a.x, 0) : 0 <= a.z ? a.set(a.z, 0, -a.x) : a.set(-a.z, 0, a.x);
                return a.normalize()
            };
            this.getEyeVector = function () {
                var a = new THREE.Vector3;
                a.subVectors(s, t);
                m && a.set(-a.x, -a.y, -a.z);
                return a
            };
            this.setTrackingDistance = function (a) {
                e = a
            };
            this.getTrackingSpeed = function () {
                var b = p.width / p.height,
                    c = 2 * e * Math.tan(THREE.Math.degToRad(0.5 * a.fov));
                return new THREE.Vector2(c * b, c)
            };
            this.trackRelative = function (a, b) {
                var c = this.getTrackingSpeed();
                u.set(u.x + a * c.x, u.y + b * c.y);
                k = !0
            };
            this.getViewOffset = function () {
                var a = this.getCameraUpVector(),
                    b = this.getCameraRightVector().multiplyScalar(u.x),
                    a = a.multiplyScalar(u.y);
                return b.add(a)
            };
            this.adjustDollyLookSpeed = function (a) {
                0 === a ? (g = 0.025, f = 4) : (g *= 0 < a ? 1.15 : 0.85, f *= 0 < a ? 1.05 : 0.95, 1E-6 > g && (g = 1E-6), 1E-6 > f && (f = 1E-6))
            };
            this.getDollySpeed = function () {
                var a = d * g;
                return 0.01 >
                    a ? 0.01 : a
            };
            this.coiIsActive = function () {
                return !0
            };
            this.coiIsVisible = function () {
                if (m) return !1;
                var b = Math.abs(u.x),
                    c = Math.abs(u.y),
                    e = d * Math.tan(THREE.Math.degToRad(0.5 * a.fov));
                return b < p.width / p.height * e && c < e
            };
            this.orbitRelative = function (a, e, g, k) {
                1E-6 < Math.abs(g) && this.dollyRelative(g, k);
                (1E-6 < Math.abs(a) || 1E-6 < Math.abs(e)) && this.look(b - a * f, c + e * f, d, !0)
            };
            this.dollyRelative = function (a, b) {
                var c, d = this.coiIsActive() && this.coiIsVisible();
                d || (this.saveCOI(), c = this.getForwardLookAtPoint(b), this.setPivotPoint(c, !0));
                a *= this.getDollySpeed();
                c = s.clone().sub(t);
                var e = c.length(),
                    f = e + a;
                0.01 > f && (f = 0.01);
                e = f / e;
                1E-6 < Math.abs(e - 1) && (c.multiplyScalar(e), c.set(-c.x, -c.y, -c.z), c.add(s), this.setView(c, s, u.x * e, u.y * e));
                d || this.restoreCOI()
            };
            this.setView = function (a, b, c, d, e) {
                var f = new THREE.Vector3;
                f.subVectors(a, b);
                var g = 0,
                    h = 0,
                    l = 10,
                    n = f.lengthSq();
                if (0 < n) {
                    var h = this.getWorldUpVector(),
                        g = this.getWorldRightVector(),
                        l = g.clone().cross(h).normalize(),
                        h = h.dot(f),
                        g = g.dot(f),
                        l = l.dot(f),
                        r = (new THREE.Vector2(g, l)).length(),
                        h = Math.atan2(h,
                            r),
                        g = Math.atan2(g, l),
                        l = Math.sqrt(n);
                    m = e ? !1 : 0 < f.dot(this.getEyeVector())
                }
                s.copy(b);
                t.copy(a);
                u.set(c || 0, d || 0);
                k = !0;
                this.look(g, h, l, !1)
            };
            this.look = function (a, f, g, m) {
                0.01 > g && (g = 0.01);
                a > l ? a -= l : 0 > a && (a += l);
                f > h ? f = h - 1E-6 : f < -h && (f = -h + 1E-6);
                if (1E-6 < Math.abs(b - a) || 1E-6 < Math.abs(c - f) || 1E-6 < Math.abs(d - g)) k = !0;
                b = a;
                c = f;
                e = d = g;
                m && (a = new THREE.Quaternion, f = this.getWorldUpVector(), g = this.getWorldRightVector(), m = g.clone().cross(f).normalize(), a.setFromAxisAngle(g, -c), m.applyQuaternion(a), a.setFromAxisAngle(f, b), m.applyQuaternion(a),
                    t.set(s.x, s.y, s.z), t.add(m.multiplyScalar(d)), k = !0)
            };
            this.updateCamera = function () {
                a.position = this.getPosition();
                n(a, this.getLookAtPoint(), a.position, a.up);
                k = !1
            };
            this.oneStepTowards = function (b, c, d, e) {
                if (0 < e) {
                    e = 1 / e;
                    var f = new THREE.Vector2(-u.x, -u.y);
                    b = b.clone().sub(t);
                    c = c.clone().sub(s);
                    d -= a.fov;
                    f.multiplyScalar(e).add(u);
                    b.multiplyScalar(e).add(t);
                    c.multiplyScalar(e).add(s);
                    a.fov += d * e;
                    this.setView(b, c, f.x, f.y, !0)
                }
            };
            this.changeFOV = function (e) {
                6.88 > e ? e = 6.88 : 100 < e && (e = 100);
                if (e !== a.fov) {
                    if (this.coiIsVisible()) {
                        var f =
                            THREE.Math.degToRad(a.fov),
                            g = THREE.Math.degToRad(e),
                            f = d * Math.tan(0.5 * f) / Math.tan(0.5 * g);
                        this.look(b, c, f, !0)
                    }
                    a.fov = e;
                    k = !0
                }
            }
        }(this.camera),
        s = 0,
        t = 1,
        p = 2,
        u = -1,
        v = a,
        w = new THREE.Vector3,
        y = new THREE.Vector3,
        x = 0,
        A = null,
        N = null,
        B = !1,
        G = new THREE.Vector3,
        C = [!1, !1, !1, !1, !1, !1],
        P, z = {
            SHIFT: 0,
            ALT: 0,
            CONTROL: 0,
            SPACE: 0,
            F1: 0,
            F2: 0,
            F3: 0,
            F4: 0,
            LOCK_PAN: 0,
            LOCK_DOLLY: 0,
            LOCK_FOV: 0,
            LOCK_ROLL: 0
        },
        Q = 0,
        F = !1,
        O = null,
        T = new function (a) {
            var b = 0,
                c = new THREE.SphereGeometry(1),
                d = new THREE.MeshPhongMaterial({
                    color: 32512,
                    ambient: 32512,
                    opacity: 0.6,
                    transparent: !0
                }),
                e = new THREE.MeshPhongMaterial({
                    color: 32512,
                    ambient: 32512,
                    opacity: 0.6,
                    transparent: !0
                }),
                f = new THREE.Mesh(c, e);
            a.createOverlayScene("pivot", d, e);
            this.shown = function () {
                return f.visible
            };
            this.show = function (c, g, k) {
                f.scale.x = g;
                f.scale.y = g;
                f.scale.z = g;
                f.position.set(c.x, c.y, c.z);
                e.opacity = 0.6;
                d.opacity = 0.6;
                f.visible = !0;
                a.addOverlay("pivot", f);
                b = k ? (new Date).getTime() + 750 : 0
            };
            this.hide = function () {
                f.visible && (f.visible = !1, a.removeOverlay("pivot", f), b = 0)
            };
            this.fade = function () {
                if (0 < b) {
                    var a = b -
                        (new Date).getTime();
                    if (0 >= a) return this.hide(), !0;
                    a = a / 750 * 0.6;
                    d.opacity = a;
                    e.opacity = a;
                    return !0
                }
                return !1
            };
            this.fading = function () {
                return 0 < b
            }
        }(a),
        D = new function (a, b) {
            function c(a, b, d, e) {
                a = new THREE.Vector3(a, b, d);
                b = e.dot(a);
                e = s.copy(e);
                e.multiplyScalar(b);
                return a.sub(e)
            }

            function d(a, b) {
                var c = Math.abs(a - b);
                return c > l ? c : Math.min(l - c, c)
            }

            function e(a) {
                return a > l ? a : 0 >= a ? a + Math.PI : a - Math.PI
            }

            function f(a, b, g, k) {
                if (!B) {
                    B = new THREE.Object3D;
                    var h = new THREE.RingGeometry(0.49, 0.5, 60);
                    A = h = new THREE.Mesh(h, m);
                    var l = new THREE.BoxGeometry(0.93, 0.007, 0.007),
                        q = new THREE.BoxGeometry(0.007, 0.93, 0.007),
                        r = new THREE.BoxGeometry(0.007, 0.007, 0.93);
                    v = new THREE.Mesh(l, m);
                    w = new THREE.Mesh(q, m);
                    y = new THREE.Mesh(r, m);
                    B.add(v);
                    B.add(w);
                    B.add(y);
                    N = new THREE.Mesh(new THREE.CircleGeometry(0.005), m);
                    B.add(N);
                    G = Array(6);
                    C = Array(6);
                    for (l = 0; 6 > l; ++l) G[l] = new THREE.Mesh(new THREE.CircleGeometry(0.005, 16), m), C[l] = new THREE.Mesh(new THREE.CircleGeometry(0.0025, 16), m), C[l].visible = !1, G[l].add(C[l]), h.add(G[l]);
                    B.add(h)
                }
                a *= 2 * g.length() *
                    Math.tan(THREE.Math.degToRad(0.5 * u.fov));
                n(A, b, u.position, k);
                h = g.clone().normalize();
                l = Array(3);
                g = Array(6);
                l[0] = c(1, 0, 0, h);
                l[1] = c(0, 1, 0, h);
                l[2] = c(0, 0, 1, h);
                q = k.clone().cross(h).normalize();
                for (h = 0; 3 > h; ++h) r = l[h], g[h] = r.length(), g[h] < Q ? z[h] = K : (r.multiplyScalar(1 / g[h]), z[h] = Math.atan2(q.dot(r), k.dot(r)));
                z[3] = e(z[0]);
                z[4] = e(z[1]);
                z[5] = e(z[2]);
                g[3] = g[0];
                g[4] = g[1];
                g[5] = g[2];
                k = J + O + 2 * Math.PI / 180;
                for (h = 0; 6 > h; ++h)
                    if (z[h] !== K)
                        for (l = h + 1; 6 > l; ++l)
                            if (z[l] !== K && d(z[h], z[l]) < k)
                                if (g[h] < g[l]) {
                                    z[h] = K;
                                    break
                                } else z[l] =
                                    K;
                for (h = 0; 6 > h; ++h) z[h] !== K ? (k = s.set(0, 0, 1), t.setFromAxisAngle(k, z[h]), k = s.set(0, 0.54, 0), k.applyQuaternion(t), G[h].position.copy(k), G[h].visible = !0) : G[h].visible = !1;
                B.scale.x = a;
                B.scale.y = a;
                B.scale.z = a;
                B.position.copy(b);
                return B
            }

            function g(a, b) {
                for (var c = d(z[0], a), e = 0, f = 1; 6 > f; ++f) {
                    var k = d(z[f], a);
                    k < c && (c = k, e = f)
                }
                return c < b ? e : -1
            }

            function k(a, b, c) {
                if (0 !== a) {
                    var d = 30 * Math.PI / 180;
                    b = s.copy(u.position).sub(b).normalize();
                    t.setFromAxisAngle(b, a);
                    a = p.copy(u.up);
                    b = Math.abs(b.angleTo(a));
                    (b < d || Math.PI - b < d) &&
                        a.copy(c.getCameraUp());
                    a.applyQuaternion(t);
                    c.setWorldUp(a)
                }
            }

            function h(a, b) {
                n(N, b, u.position, a);
                N.position.copy(a.multiplyScalar(0.495));
                v.visible = q;
                w.visible = q;
                for (var c = (y.visible = q) ? O : J, e = 0; 6 > e; ++e) {
                    var f = d(z[e], F),
                        g = f < c,
                        f = g ? 4 : 3 * (1 - 3 * f / Math.PI);
                    1 > f && (f = 1);
                    f *= x;
                    C[e].visible = g;
                    g = G[e];
                    g.scale.x = f;
                    g.scale.y = f;
                    g.scale.z = f
                }
            }
            var m = new THREE.MeshLambertMaterial({
                    color: 12303291,
                    opacity: 0.5,
                    transparent: !0
                }),
                r = new THREE.MeshLambertMaterial({
                    color: 12303291,
                    opacity: 0.5,
                    transparent: !0
                }),
                p = new THREE.Vector3,
                s = new THREE.Vector3,
                t = new THREE.Quaternion,
                u = new THREE.PerspectiveCamera(b.fov, b.aspect, b.near, b.far),
                x = 1,
                A = null,
                v = null,
                w = null,
                y = null,
                B = null,
                N = null,
                G = null,
                C = null,
                z = Array(6),
                F = 0,
                q = !0,
                P = 0,
                J = 5 * Math.PI / 180,
                O = 7 * Math.PI / 180,
                K = 1E3,
                Q = 0.1;
            a.createOverlayScene("roll", m, r, u);
            this.updateRollCamera = function () {
                u.position.copy(b.position);
                u.quaternion.copy(b.quaternion);
                u.up.copy(b.up);
                u.aspect = b.aspect;
                u.fov = 30;
                u.near = b.near;
                u.far = b.far;
                u.updateProjectionMatrix()
            };
            this.isSnapped = function () {
                return q
            };
            this.start =
                function (b, c) {
                    this.updateRollCamera();
                    x = 0.85 / 0.7;
                    var d = p.copy(b).sub(u.position);
                    a.addOverlay("roll", f(0.7, b, d, c));
                    P = F = 0;
                    h(c, b)
            };
            this.handleRoll = function (a, b, c, d, e) {
                this.updateRollCamera();
                h(e.getCameraUp(), d);
                B.position.copy(d);
                if (0 !== a || 0 !== b) {
                    a = c.x - a - 0.5;
                    b = c.y - b - 0.5;
                    c = Math.atan2(c.y - 0.5, c.x - 0.5) - Math.atan2(b, a);
                    F += c;
                    F > Math.PI ? F -= l : F <= -Math.PI && (F = l + F);
                    a: {
                        if (!q && (b = g(F, J), 0 <= b)) {
                            q = !0;
                            F = z[b];
                            p.set(0, 0, 0);
                            0 <= b && (a = 3 <= b ? -1 : 1, b %= 3, 0 === b && (p.x = a), 1 === b && (p.y = a), 2 === b && (p.z = a));
                            b = p;
                            break a
                        }
                        b = !1
                    }
                    b ? (P =
                        F, e.setWorldUp(b)) : (q && 0 > g(F, O) ? (q = !1, b = !0) : b = !1, b ? (k(F - P, d, e), P = 0) : q || k(c, d, e));
                    return !0
                }
                return !1
            };
            this.end = function () {
                a.removeOverlay("roll", B)
            }
        }(a, this.camera),
        J = !1,
        I = !1,
        U = !1,
        M = !1,
        Y = !1,
        S = !1,
        X = !1,
        K = 0,
        ca = null,
        ba = 0,
        aa = null,
        ga = null,
        pa = null,
        ea = {
            PAN: !1,
            DOLLY: !1,
            ORBIT: !1
        },
        R = this;
    this.homePosition = new THREE.Vector3(0, 0, 1);
    this.homeTarget = new THREE.Vector3(0, 0, 0);
    this.homeUp = new THREE.Vector3(0, 1, 0);
    this.homeFov = this.camera.fov;
    this.setViewpoint = function (a, b) {
        r.setView(a, b, 0, 0, !0)
    };
    this.setCOI = function (a,
        b) {
        r.setPivotPoint(a, b);
        T.shown() && this.activatePivot()
    };
    this.setSelector = function (a) {
        O = a
    };
    this.getNavigationMode = function () {
        return z.LOCK_DOLLY ? this.NAVIGATION_MODE.DOLLY : z.LOCK_PAN ? this.NAVIGATION_MODE.PAN : z.LOCK_FOV ? this.NAVIGATION_MODE.FOV : z.LOCK_ROLL ? this.NAVIGATION_MODE.ROLL : this.NAVIGATION_MODE.ORBIT
    };
    this.setNavigationMode = function (a) {
        if (a !== this.getNavigationMode()) {
            z.LOCK_DOLLY = 0;
            z.LOCK_PAN = 0;
            z.LOCK_ROLL = 0;
            z.LOCK_FOV = 0;
            switch (a) {
            case this.NAVIGATION_MODE.PAN:
                z.LOCK_PAN = 1;
                break;
            case this.NAVIGATION_MODE.DOLLY:
                z.LOCK_DOLLY =
                    1;
                break;
            case this.NAVIGATION_MODE.ROLL:
                z.LOCK_ROLL = 1;
                break;
            case this.NAVIGATION_MODE.FOV:
                z.LOCK_FOV = 1
            }
            e(this.getNavigationMode())
        }
    };
    this.setSceneBounds = function (a) {
        P = a
    };
    this.recordHomeView = function () {
        this.homePosition.copy(r.getPosition());
        this.homeTarget.copy(r.getLookAtPoint());
        this.homeUp.copy(r.getWorldUpVector());
        this.homeFov = this.camera.fov
    };
    this.goHome = function () {
        this.changeWorldUp(this.homeUp.x, this.homeUp.y, this.homeUp.z);
        this.transitionView(this.homePosition, this.homeTarget, this.homeFov,
            10)
    };
    this.getBoundingBox = function (a) {
        var b;
        null !== O && (b = O.getSelectionBounds());
        b && !b.empty() || !v.modelQueue || v.modelQueue.areAllVisible() || (b = v.modelQueue.getVisibleBounds(a));
        if (!b || b.empty()) b = P;
        return b
    };
    this.setWorldUp = function (a) {
        a && 1E-5 < r.getWorldUpVector().sub(a).lengthSq() && (r.setWorldUpVector(a), M = !0)
    };
    this.getCOI = function () {
        return r.getPivotPoint()
    };
    this.getLookAtPoint = function () {
        return r.getLookAtPoint()
    };
    this.changeWorldUp = function (a, b, c) {
        ca = new THREE.Vector3(a, b, c);
        a = r.getWorldUpVector();
        K = 10;
        b = ca.clone().sub(a);
        b.multiplyScalar(1 / K);
        this.setWorldUp(a.add(b));
        --K
    };
    this.getWorldUp = function () {
        return r.getWorldUpVector()
    };
    this.getCameraUp = function () {
        return r.getCameraUpVector()
    };
    this.getFOV = function () {
        return this.camera.fov
    };
    this.setFOV = function (a) {
        r.changeFOV(a)
    };
    this.getFocalLength = function () {
        return b(this.camera.fov)
    };
    this.setFocalLength = function (a) {
        r.changeFOV(c(a))
    };
    this.transitionView = function (a, b, c, d) {
        ba = d - 1;
        aa = a;
        ga = b;
        pa = c;
        r.oneStepTowards(a, b, c, d);
        this.pivotActive(!1)
    };
    this.fitToView =
        function (b, c) {
            var d = 0 < a.explodeScale;
            c || (c = this.getBoundingBox(d));
            var d = r.getPosition(),
                e = c.center(),
                f = c.size(),
                f = 0.5 * Math.sqrt(f.x * f.x + f.y * f.y + f.z * f.z),
                g = Math.max(1, 0.9 + this.camera.fov / 100 * 0.5),
                f = f * g,
                g = r.getPivotDistance(),
                f = f / Math.tan(THREE.Math.degToRad(0.5 * this.camera.fov)) / g,
                g = r.getViewOffset();
            if (1E-5 < Math.abs(f - 1) || 0 < g.lengthSq()) g = new THREE.Vector3, g.subVectors(r.getLookAtPoint(), d), g.set(-g.x, -g.y, -g.z), g.multiplyScalar(f), d = e.clone(), d.add(g), b ? r.setView(d, e, 0, 0, !0) : (this.transitionView(d,
                e, this.camera.fov, 10), F = !0), T.shown() && this.activatePivot(T.fading());
            return {
                position: d,
                target: e
            }
    };
    this.handleEvent = function (a) {
        if ("function" === typeof this[a.type]) this[a.type](a)
    };
    this.setViewport = function (a) {
        this.viewport = a;
        r.setScreenViewport(a)
    };
    this.activatePivot = function (a) {
        var b = 10 * r.getPivotDistance() * Math.tan(THREE.Math.degToRad(0.5 * this.camera.fov)) / (this.viewport.height * (window.devicePixelRatio || 1));
        T.show(r.getPivotPoint(), b, a)
    };
    this.pivotActive = function (a, b) {
        b = b || !1;
        !a && T.shown() ? T.hide() :
            a && this.activatePivot(b)
    };
    this.interactionStart = function (a, b) {
        if (b || a > Q) Q = a, X = !0, this.pivotActive(!0, -1 === a)
    };
    this.interactionEnd = function (a) {
        a === Q && (-1 !== a && this.pivotActive(!1), X = !1)
    };
    this.autoMove = function (a, b) {
        0 > a ? C[0] = C[1] = C[2] = C[3] = C[4] = C[5] = b : C[a] = b;
        b ? this.interactionStart(-2) : C[0] || C[1] || C[2] || C[3] || C[4] || C[5] || this.interactionEnd(-2)
    };
    this.getMotionDelta = function (a, b) {
        C[0] && (y.x += 0.01);
        C[1] && (y.x -= 0.01);
        C[2] && (y.y += 0.01);
        C[3] && (y.y -= 0.01);
        C[4] && (y.z += -2.4);
        C[5] && (y.z -= -2.4);
        var c = y.x - w.x,
            d = y.y - w.y,
            e = y.z - w.z;
        0.001 > Math.abs(c) && (c = 0);
        0.001 > Math.abs(d) && (d = 0);
        0.001 > Math.abs(e) && (e = 0);
        !b || 0 == c && 0 == d && 0 == e ? w.copy(y) : (w.x += 0.6 * c, w.y += 0.6 * d, w.z += 0.6 * e);
        a.set(c, d, e)
    };
    this.getAccumulatedWheelDelta = function () {
        var a = Date.now(),
            b = 0;
        N && 100 < a - N ? (b = 0 > x && -3 < x ? -3 : 0 < x && 3 > x ? 3 : x, x = 0, N = A = null, B = !1) : A && 100 < a - A && (B ? b = x : (b = 0 > x && -3 < x ? -3 : 0 < x && 3 > x ? 3 : x, B = !0), x = 0);
        return b
    };
    this.adjustSpeed = function (a) {
        r.adjustDollyLookSpeed(a)
    };
    this.update = function () {
        var a = !1,
            h = !1;
        this.getMotionDelta(G, !Y && !f() && !J && !g());
        var l =
            G.x,
            m = G.y,
            n = G.z,
            u = this.getAccumulatedWheelDelta();
        if (!J && g()) {
            J = !0;
            var x = r.getLookAtPoint(),
                A = x.sub(this.camera.position),
                x = 0.5 * (this.camera.near + this.camera.far);
            A.normalize().multiplyScalar(x);
            x = A.add(this.camera.position);
            r.saveCOI();
            r.setPivotPoint(x, !0);
            this.pivotActive(!0);
            this.interactionStart(-2);
            D.start(x, r.getCameraUpVector());
            M = !0;
            e(this.NAVIGATION_MODE.ROLL)
        }!U && k() && (U = !0, this.interactionStart(-2), e(this.NAVIGATION_MODE.FOV));
        if (I || 0 !== l || 0 !== m || 0 !== n || 0 !== u) {
            ba = K = 0;
            I = F = !1;
            !(Q === p && z.ALT &&
                !z.SHIFT || Q === t && z.CONTROL && !z.SHIFT || Q === s && (z.F3 || z.LOCK_DOLLY) || ea.DOLLY) || J || U || f() || (m = -m, n = Math.abs(l) > Math.abs(m) ? l : m, n *= -120, m = l = 0, e(this.NAVIGATION_MODE.DOLLY));
            if (J) Y = !1, I = D.handleRoll(l, m, y, r.getLookAtPoint(), this);
            else if (U) Y = !1, Q >= s ? (m = -m, n = Math.abs(l) > Math.abs(m) ? l : m, 0 !== n && (n *= -1, r.changeFOV(this.camera.fov * (1 + n)))) : 0 !== u && r.changeFOV(c(b(this.camera.fov) + u / 3));
            else if (f()) {
                this.pivotActive(X);
                if (!1 == Y) {
                    x = r.getPivotDistance();
                    if (u = d(this.camera, y.x, y.y)) u = u.sub(r.getPosition()), x = r.getEyeVector().normalize(),
                        x = Math.abs(x.dot(u));
                    r.setTrackingDistance(x);
                    Y = !0;
                    e(this.NAVIGATION_MODE.PAN)
                }
                r.trackRelative(l, m)
            } else e(0 !== n ? this.NAVIGATION_MODE.DOLLY : this.NAVIGATION_MODE.ORBIT), r.orbitRelative(0.6 * l, 0.6 * m, n, d), S = !0, Y = !1;
            this.pivotActive(X, -1 === Q)
        } - 1 === Q && 1E-6 > Math.abs(n) && (this.interactionEnd(-1), a = !0);
        J && !g() || U && !k() ? (this.interactionEnd(-2), h = !0) : !J && !U || X || this.interactionStart(-2, !0);
        if (a && !U && !J || h || !X && (J || Y || U || -3 < Q)) S && !D.isSnapped() && this.setWorldUp(r.getCameraUpVector()), J && (D.end(), J = !1, r.restoreCOI(),
            M = !0), -1 < Q && w.copy(y), S = U = Y = !1, h || (Q = -3), e(this.getNavigationMode());
        0 < K && ca && (a = r.getWorldUpVector(), h = ca.clone().sub(a), h.multiplyScalar(1 / K), this.setWorldUp(a.add(h)), --K);
        0 < ba && aa && ga && (r.oneStepTowards(aa, ga, pa, ba), --ba, 0 == ba && F && (this.pivotActive(!0, !0), F = !1));
        T.shown() && T.fade() && (v.overlayDirty = !0);
        return M || r.isDirty() ? (r.updateCamera(), M = !1, !0) : !1
    };
    this.clientToCanvasCoords = function (a, b) {
        var c = this.domElement.getBoundingClientRect(),
            d = c.width,
            e = c.height,
            f = a.clientX - c.left,
            c = a.clientY - c.top;
        a.canvasX = f;
        a.canvasY = c;
        a.normalizedX = f / d * 2 - 1;
        a.normalizedY = (e - c) / e * 2 - 1;
        null !== b && b.set(f / d, c / e, 0)
    };
    this.handleResize = function () {
        this.setViewport(v.api.container.getBoundingClientRect())
    };
    this.setCOIFromMouse = function (a, b) {
        var c = (new CameraRaycaster(v, this.camera)).castRayViewport(a, b, !0);
        c.intersectPoint && this.setCOI(c.intersectPoint, !0)
    };
    this.handleSingleClick = function (a) {
        if (Q == s) {
            a = (new CameraRaycaster(v, this.camera)).castRay(a.clientX, a.clientY, !1);
            var b = "click";
            z.CONTROL && (b += "Ctrl");
            z.SHIFT &&
                (b += "Shift");
            z.ALT && (b += "Alt");
            z.SPACE && (b += "Space");
            z.F1 && (b += "F1");
            z.F2 && (b += "F2");
            z.F3 && (b += "F3");
            z.F4 && (b += "F4");
            var c = "",
                c = a.node || a.intersectPoint ? "onObject" : "offObject";
            this.clickConfig && this.clickConfig[b] && this.clickConfig[b][c] && this.handleAction(this.clickConfig[b][c], a)
        }
    };
    this.handleAction = function (a, b) {
        for (var c = 0; c < a.length; ++c) switch (a[c]) {
        case "selectOnly":
            O && b.node && O.setSelection([b.node]);
            break;
        case "deselectAll":
            O && O.setSelection([]);
            break;
        case "selectToggle":
            O && b.node && O.toggleSelection(b.node);
            break;
        case "isolate":
            b.node && v.api.isolate(b.node);
            break;
        case "showAll":
            v.visibilityManager.isolateNone();
            break;
        case "setCOI":
            b.intersectPoint && (this.setCOI(b.intersectPoint, !0), this.pivotActive(!0, !0));
            break;
        case "hide":
            b.node && v.hideMultiple([b.node]);
            break;
        case "show":
            b.node && v.showMultiple([b.node]);
            break;
        case "toggleVisibility":
            b.node && v.toggleVisibility(b.node);
            break;
        case "focus":
            O && (b.node ? O.setSelection([b.node]) : O.setSelection([]), this.fitToView())
        }
    };
    this.handleDoubleClick = function (a) {
        null !=
            O && 0 == a.button && (O.clearSelection(), a = (new CameraRaycaster(v, this.camera)).castRay(a.clientX, a.clientY, !1), a.node && O.toggleSelection(a.node), this.fitToView())
    };
    this.handleWheelInput = function (a) {
        y.z += -0.6 * a;
        x += a;
        var b = Date.now();
        A || (A = b);
        N = b;
        0 != a && this.interactionStart(-1)
    };
    this.applyKepMappings = function (a) {
        switch (a.keyCode) {
        case 91:
            return 17;
        case 93:
            return 17;
        case 224:
            return 17;
        case 17:
            if (-1 != navigator.userAgent.search("Mac OS")) return null;
            break;
        case 188:
        case 59:
        case 186:
            return 37;
        case 190:
        case 222:
            return 39;
        case 219:
            return 33;
        case 191:
            return 34;
        case 72:
            return 36;
        case 61:
            return 187;
        case 109:
            return 189
        }
        return a.keyCode
    };
    this.handleKeyDown = function (a) {
        switch (this.applyKepMappings(a)) {
        case 16:
            z.SHIFT = 1;
            break;
        case 17:
            z.CONTROL = 1;
            break;
        case 18:
            z.ALT = 1;
            break;
        case 32:
            z.SPACE = 1;
            break;
        case 112:
            z.F1 = 1;
            break;
        case 113:
            z.F2 = 1;
            break;
        case 114:
            z.F3 = 1;
            break;
        case 115:
            z.F4 = 1;
            break;
        case 36:
            this.goHome();
            break;
        case 70:
            this.fitToView();
            break;
        case 187:
            this.adjustSpeed(1);
            break;
        case 189:
            this.adjustSpeed(-1);
            break;
        case 48:
            this.adjustSpeed(0);
            break;
        case 88:
            this.changeWorldUp(1, 0, 0);
            break;
        case 89:
            this.changeWorldUp(0, 1, 0);
            break;
        case 90:
            this.changeWorldUp(0, 0, 1);
            break;
        case 37:
            this.autoMove(0, !0);
            break;
        case 39:
            this.autoMove(1, !0);
            break;
        case 33:
            this.autoMove(2, !0);
            break;
        case 34:
            this.autoMove(3, !0);
            break;
        case 38:
            this.autoMove(4, !0);
            break;
        case 40:
            this.autoMove(5, !0);
            break;
        default:
            return !1
        }
        return !0
    };
    this.handleKeyUp = function (b) {
        switch (this.applyKepMappings(b)) {
        case 16:
            z.SHIFT = 0;
            break;
        case 17:
            z.CONTROL = 0;
            break;
        case 18:
            z.ALT = 0;
            break;
        case 32:
            z.SPACE =
                0;
            break;
        case 112:
            z.F1 = 0;
            break;
        case 113:
            z.F2 = 0;
            break;
        case 114:
            z.F3 = 0;
            break;
        case 115:
            z.F4 = 0;
            break;
        case 36:
        case 70:
            break;
        case 37:
            this.autoMove(0, !1);
            break;
        case 39:
            this.autoMove(1, !1);
            break;
        case 33:
            this.autoMove(2, !1);
            break;
        case 34:
            this.autoMove(3, !1);
            break;
        case 38:
            this.autoMove(4, !1);
            break;
        case 40:
            this.autoMove(5, !1);
            break;
        case 27:
            if (a.objectContextMenu.hide()) break;
            a.api.fireEvent({
                type: Autodesk.Viewing.ESCAPE_EVENT
            });
            this.autoMove(-1, !1);
            z.SHIFT = 0;
            z.CONTROL = 0;
            z.ALT = 0;
            z.SPACE = 0;
            z.F1 = 0;
            z.F2 = 0;
            z.F3 = 0;
            z.F4 = 0;
            break;
        default:
            return !1
        }
        return !0
    };
    this.handleButtonDown = function (a) {
        this.interactionStart(a)
    };
    this.handleButtonUp = function (a) {
        this.interactionEnd(a)
    };
    this.resize = function (a) {
        R.handleResize()
    };
    this.keydown = function (a) {
        "INPUT" != document.activeElement.nodeName && "TEXTAREA" != document.activeElement.nodeName && R.handleKeyDown(a) && (a.preventDefault(), a.stopPropagation())
    };
    this.keyup = function (a) {
        "INPUT" != document.activeElement.nodeName && "TEXTAREA" != document.activeElement.nodeName && R.handleKeyUp(a) && (a.preventDefault(),
            a.stopPropagation())
    };
    this.updateModifierState = function (a) {
        var b = -1 != navigator.userAgent.search("Mac OS");
        z.CONTROL = b && a.metaKey || !b && a.ctrlKey ? 1 : 0;
        z.SHIFT = a.shiftKey ? 1 : 0;
        z.ALT = a.altKey ? 1 : 0
    };
    this.mousedown = function (a) {
        function b(a) {
            a.button === c && (document.removeEventListener("mouseup", b), R.mouseup(a))
        }
        if (!R.isDragging && !R.inTouch) {
            _isIE11 && inFullscreen() || document.activeElement.blur();
            a.preventDefault();
            a.stopPropagation();
            R.updateModifierState(a);
            R.clientToCanvasCoords(a, w);
            y.copy(w);
            R.handleButtonDown(a.button);
            R.downX = a.canvasX;
            R.downY = a.canvasY;
            R.isDragging = !0;
            var c = a.button;
            document.addEventListener("mouseup", b, !1)
        }
    };
    this.mousemove = function (a) {
        if (!R.inTouch && R.isDragging) {
            a.preventDefault();
            a.stopPropagation();
            R.updateModifierState(a);
            R.clientToCanvasCoords(a, y);
            var b = R.downY - a.canvasY;
            if (2 < Math.abs(R.downX - a.canvasX) || 2 < Math.abs(b)) R.downX = -1, R.downY = -1
        }
    };
    this.mouseup = function (a) {
        a.preventDefault();
        a.stopPropagation();
        R.updateModifierState(a);
        R.clientToCanvasCoords(a, y);
        R.handleButtonUp(a.button);
        var b =
            R.downY - a.canvasY;
        (2 >= Math.abs(R.downX - a.canvasX) || 2 >= Math.abs(b)) && R.handleSingleClick(a);
        R.downX = -1;
        R.downY = -1;
        R.isDragging = !1
    };
    this.doubleclick = function (a) {
        a.preventDefault();
        a.stopPropagation();
        R.clientToCanvasCoords(a, w);
        y.copy(w);
        R.downX = a.canvasX;
        R.downY = a.canvasY;
        R.handleDoubleClick(a)
    };
    this.mousewheel = function (a) {
        a.preventDefault();
        a.stopPropagation();
        var b = 0;
        a.wheelDelta ? b = a.wheelDelta / 40 : a.detail && (b = -a.detail);
        R.handleWheelInput(b)
    };
    this.touchstart = function (a) {
        function b(a) {
            a.button ===
                d && (document.removeEventListener("touchend", b), R.touchend(a))
        }
        R.inTouch = !0;
        a.preventDefault();
        a.stopPropagation();
        ea = {};
        switch (a.targetTouches.length) {
        case 1:
            ea.ORBIT = !0;
            break;
        case 2:
            ea.PAN = !0;
            break;
        case 3:
            ea.DOLLY = !0;
            break;
        default:
            ea.ORBIT = !0
        }
        var c = a.targetTouches[0];
        a.clientX = c.pageX;
        a.clientY = c.pageY;
        if (!R.isDragging) {
            document.activeElement.blur();
            R.updateModifierState(a);
            R.clientToCanvasCoords(a, w);
            y.copy(w);
            R.handleButtonDown(a.button);
            R.downX = a.canvasX;
            R.downY = a.canvasY;
            R.isDragging = !0;
            var d =
                a.button;
            document.addEventListener("touchend", b, !1)
        }
    };
    this.touchmove = function (a) {
        a.preventDefault();
        a.stopPropagation();
        ea = {};
        switch (a.targetTouches.length) {
        case 1:
            ea.ORBIT = !0;
            break;
        case 2:
            ea.PAN = !0;
            break;
        case 3:
            ea.DOLLY = !0;
            break;
        default:
            ea.ORBIT = !0
        }
        var b = a.targetTouches[0];
        a.clientX = b.pageX;
        a.clientY = b.pageY;
        R.isDragging && (R.updateModifierState(a), R.clientToCanvasCoords(a, y), b = R.downY - a.canvasY, 2 < Math.abs(R.downX - a.canvasX) || 2 < Math.abs(b)) && (R.downX = -1, R.downY = -1)
    };
    this.touchend = function (a) {
        R.inTouch = !1;
        a.preventDefault();
        a.stopPropagation();
        ea.PAN = !1;
        ea.DOLLY = !1;
        ea.ORBIT = !1;
        var b = a.changedTouches[0];
        a.clientX = b.pageX;
        a.clientY = b.pageY;
        R.updateModifierState(a);
        R.clientToCanvasCoords(a, y);
        R.handleButtonUp(a.button);
        b = R.downY - a.canvasY;
        (2 >= Math.abs(R.downX - a.canvasX) || 2 >= Math.abs(b)) && R.handleSingleClick(a);
        R.downX = -1;
        R.downY = -1;
        R.isDragging = !1
    };
    this.domElement.addEventListener("mousedown", this.mousedown, !1);
    window.addEventListener("mousemove", this.mousemove, !1);
    this.domElement.addEventListener("dblclick",
        this.doubleclick, !1);
    this.domElement.addEventListener("mousewheel", this.mousewheel, !1);
    this.domElement.addEventListener("DOMMouseScroll", this.mousewheel, !1);
    this.domElement.addEventListener("touchstart", function (a) {
        R.touchstart(a)
    }, !1);
    this.domElement.addEventListener("touchend", function (a) {
        R.touchend(a)
    }, !1);
    this.domElement.addEventListener("touchmove", function (a) {
        R.touchmove(a)
    }, !1);
    window.addEventListener("keydown", this.keydown, !1);
    window.addEventListener("keyup", this.keyup, !1);
    window.addEventListener("resize",
        this.resize, !1);
    this.handleResize();
    this.uninitialize = function () {
        window.removeEventListener("mousemove", this.mousemove, !1);
        window.removeEventListener("keydown", this.keydown, !1);
        window.removeEventListener("keyup", this.keyup, !1);
        window.removeEventListener("resize", this.resize, !1)
    }
}
ViewController.prototype = Object.create(THREE.EventDispatcher.prototype);
var Autodesk = Autodesk || {};
Autodesk.Selector = function (a) {
    function b(a) {
        var c = a.dbId || a.fragIds;
        if (0 < f[c]) {
            if (f[c]--, 0 == f[c] && (c = a.fragIds, "undefined" != typeof c)) {
                Array.isArray(c) || (c = [c]);
                for (var d = 0; d < c.length; ++d) {
                    var e = c[d],
                        n = g.viewer.modelQueue.vizmeshes[e];
                    g.viewer.modelQueue.setHightlighted(e, !1);
                    g.viewer.needsClear = !0;
                    n.selectionProxy && (g.viewer.removeOverlay("selection", n.selectionProxy), delete n.selectionProxy)
                }
            }
        } else if (0 > f[c]) throw "Selection State machine broken. Negatively selected object!";
        if (a.children)
            for (d =
                0; d < a.children.length; d++) b(a.children[d])
    }

    function c(a, b) {
        var d = a.dbId || a.fragIds;
        if (f[d]) f[d]++;
        else {
            var e = a.fragIds;
            if ("undefined" != typeof e) {
                Array.isArray(e) || (e = [e]);
                for (var n = 0; n < e.length; ++n) {
                    var r = e[n],
                        s = g.viewer.modelQueue.vizmeshes[r];
                    b ? g.viewer.modelQueue.setHightlighted(r, !0) : (s.selectionProxy = new THREE.Mesh(s.geometry, s.material, !0), s.selectionProxy.matrixWorld = s.matrixWorld, g.viewer.addOverlay("selection", s.selectionProxy))
                }
            }
            f[d] = 1
        } if (a.children)
            for (n = 0; n < a.children.length; n++) c(a.children[n], !0);
        b && (g.viewer.needsClear = !0)
    }

    function e(a) {
        -1 == g.findSelection(a) && (g.selectedObjects.push(a), c(a))
    }

    function d(a) {
        var c = g.findSelection(a);
        0 <= c && (b(a), g.selectedObjects.splice(c, 1))
    }
    var g = this;
    this.viewer = a;
    this.projector = new THREE.Projector;
    this.raycaster = new THREE.Raycaster;
    this.selectedObjects = [];
    this.intersectPoint = null;
    var f = {};
    a.api.addEventListener("isolate", function (a) {
        g.deselectInvisible()
    });
    a.api.addEventListener("hide", function (a) {
        g.deselectInvisible()
    });
    this.setIntersectPoint = function (a) {
        g.intersectPoint =
            a
    };
    this.getIntersectPoint = function () {
        return g.intersectPoint
    };
    this.getSelectionLength = function () {
        return g.selectedObjects.length
    };
    this.getSelection = function () {
        for (var a = [], b = 0; b < g.selectedObjects.length; b++) a.push(g.selectedObjects[b]);
        return a
    };
    this.clearSelection = function () {
        if (0 < this.selectedObjects.length) {
            for (var a = 0; a < g.selectedObjects.length; a++) b(g.selectedObjects[a]);
            g.selectedObjects.length = 0;
            this.fireSelectionChangedEvent()
        }
    };
    this.fireSelectionChangedEvent = function () {
        for (var a = [], b = [], c =
            0; c < g.selectedObjects.length; c++) a.push(g.selectedObjects[c].dbId), b.push(g.selectedObjects[c].fragIds);
        a = {
            type: Autodesk.Viewing.SELECTION_CHANGED_EVENT,
            dbIdArray: a,
            fragIdsArray: b,
            nodeArray: this.getSelection()
        };
        this.viewer.api.fireEvent(a)
    };
    this.isSelected = function (a) {
        return -1 != this.findSelection(a)
    };
    this.findSelection = function (a) {
        return this.selectedObjects.indexOf(a)
    };
    this.toggleSelection = function (a) {
        a && (this.isSelected(a) ? d(a) : e(a), g.fireSelectionChangedEvent())
    };
    this.setSelectionIds = function (a) {
        this.setSelection(this.viewer.getNodesByIds(a))
    };
    this.setSelection = function (a) {
        this.clearSelection();
        if (null != a) {
            for (var b = 0; b < a.length; b++) e(a[b]);
            0 < a.length && this.fireSelectionChangedEvent()
        }
    };
    this.deselectInvisible = function () {
        for (var a = !1, b = 0; b < g.selectedObjects.length; b++) {
            var c = g.selectedObjects[b];
            !1 == c.visible && (d(c), a = !0)
        }
        a && this.fireSelectionChangedEvent()
    };
    this.toggleSelectionId = function (a) {
        this.toggleSelection(this.viewer.getNodesByIds([a])[0])
    };
    this.isSelectedOrParentIsSelected = function (a) {
        for (; a;) {
            if (0 <= this.findSelection(a)) return !0;
            a = a.parent
        }
        return !1
    };
    this.getSelectionMeshes = function () {
        for (var a = [], b = 0; b < g.selectedObjects.length; ++b) {
            var c = g.selectedObjects[b].fragIds;
            Array.isArray(c) || (c = [c]);
            for (var d = 0; d < c.length; ++d) a.push(g.viewer.modelQueue.vizmeshes[c[d]])
        }
        return a
    };
    this.getSelectionFragIds = function () {
        for (var a = Array(this.selectedObjects.length), b = 0; b < g.selectedObjects.length; ++b) {
            var c = function (b) {
                var d = b.fragIds;
                Array.isArray(d) || (d = [d]);
                for (var e = 0; e < d.length; ++e) a.push(d[e]);
                if (b.children)
                    for (d = 0; d < b.children.length; d++) c(b.children[d])
            };
            c(g.selectedObjects[b])
        }
        return a
    };
    this.getSelectionBounds = function () {
        var a = new THREE.Box3,
            b = new THREE.Vector3,
            c = new THREE.Vector3,
            d = new THREE.Box3,
            e = 0 < g.viewer.explodeScale,
            f = this.viewer.svf.fragments,
            s = f.boxes,
            t = g.getSelectionFragIds();
        if (e) var p = g.viewer.modelQueue.vizmeshes,
            u = f.transforms;
        for (f = 0; f < t.length; ++f) {
            var v = 6 * t[f];
            b.x = s[v];
            b.y = s[v + 1];
            b.z = s[v + 2];
            c.x = s[v + 3];
            c.y = s[v + 4];
            c.z = s[v + 5];
            if (e && t[f]) {
                var w = t[f],
                    v = 16 * w,
                    w = p[w].matrixWorld.elements;
                b.x += w[12] - u[v + 12];
                c.x += w[12] - u[v + 12];
                b.y += w[13] -
                    u[v + 13];
                c.y += w[13] - u[v + 13];
                b.z += w[14] - u[v + 14];
                c.z += w[14] - u[v + 14]
            }
            d.set(b, c);
            a.union(d)
        }
        return a
    }
};
VisibilityManager = function (a) {
    this.viewerImpl = a
};
VisibilityManager.prototype.isolate = function (a) {
    a ? this.isolateMultiple([a]) : this.isolateNone()
};
VisibilityManager.prototype.isolateNone = function () {
    this.viewerImpl.modelQueue.setAllVisibility(!0);
    this.viewerImpl.svf.instanceTree && this.setVisibiltyOnNode(this.viewerImpl.svf.instanceTree, !0);
    this.viewerImpl.modelQueue.setOverrideMaterial(null);
    this.viewerImpl.needGhostedPass = !1;
    this.viewerImpl.needsClear = !0;
    this.viewerImpl.api.fireEvent({
        type: Autodesk.Viewing.ISOLATE_EVENT,
        nodeIdArray: []
    })
};
VisibilityManager.prototype.isolateMultiple = function (a) {
    var b = (new Date).getTime();
    if (a && 0 != a.length) {
        this.viewerImpl.svf.instanceTree && this.setVisibiltyOnNode(this.viewerImpl.svf.instanceTree, !1);
        this.viewerImpl.modelQueue.setAllVisibility(!1);
        for (var c = 0; c < a.length; c++) this.setVisibiltyOnNode(a[c], !0), this.viewerImpl.needGhostedPass = !0;
        this.viewerImpl.api.fireEvent({
            nodeIdArray: a,
            type: "isolate"
        })
    } else this.isolateNone();
    a = (new Date).getTime() - b;
    stderr("Isolate time: " + a);
    this.viewerImpl.needsClear = !0
};
VisibilityManager.prototype.hideMultiple = function (a) {
    for (var b = 0; b < a.length; ++b) this.setVisibiltyOnNode(a[b], !1);
    0 < a.length && this.viewerImpl.api.fireEvent({
        type: Autodesk.Viewing.HIDE_EVENT,
        nodeIdArray: a
    })
};
VisibilityManager.prototype.hide = function (a) {
    this.setVisibiltyOnNode(a, !1);
    this.viewerImpl.api.fireEvent({
        type: Autodesk.Viewing.HIDE_EVENT,
        nodeIdArray: [a]
    })
};
VisibilityManager.prototype.showMultiple = function (a) {
    for (var b = 0; b < a.length; ++b) this.setVisibiltyOnNode(a[b], !0);
    0 < a.length && this.viewerImpl.api.fireEvent({
        type: Autodesk.Viewing.SHOW_EVENT,
        nodeIdArray: a
    })
};
VisibilityManager.prototype.show = function (a) {
    this.setVisibiltyOnNode(a, !0);
    this.viewerImpl.api.fireEvent({
        type: Autodesk.Viewing.SHOW_EVENT,
        nodeIdArray: [a]
    })
};
VisibilityManager.prototype.toggleVisibility = function (a) {
    var b = this.isVisible(a);
    this.setVisibiltyOnNode(a, !b);
    this.viewerImpl.api.fireEvent(b ? {
        type: Autodesk.Viewing.HIDE_EVENT,
        nodeIdArray: [a]
    } : {
        type: Autodesk.Viewing.SHOW_EVENT,
        nodeIdArray: [a]
    })
};
VisibilityManager.prototype.setVisibiltyOnNode = function (a, b) {
    var c = (new Date).getTime(),
        e = this.viewerImpl;
    (function g(a) {
        a.visible = b;
        var c = a.fragIds;
        if (void 0 !== c)
            if (Array.isArray(c))
                for (var h = 0; h < c.length; h++) e.modelQueue.setVisibility(c[h], b);
            else e.modelQueue.setVisibility(c, b);
        if (a.children)
            for (c = 0; c < a.children.length; c++) g(a.children[c])
    })(a);
    this.viewerImpl.needGhostedPass = !0;
    c = (new Date).getTime() - c;
    stderr("Hide time: " + c);
    this.viewerImpl.needsClear = !0
};
VisibilityManager.isVisible = function (a) {
    return null != a.visible ? a.visible : !0
};
VisibilityManager.prototype.areAllVisible = function () {
    return this.viewerImpl.modelQueue.areAllVisible()
};
var backimage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAwBJREFUeF7tl8GNIjEQRUmADIiADEiADIiAAAiABLgTAGfuBEAIG9I+8T2W1d2s5oNpadF/B9Qum5qpN2W7ZxE8/oRfEFkGkWUQWQaRZRBZBpFlEFkGkWUQWQaRZRBZBpFlEFkGkWUQWQaRZRBZBpFlEFkGkWUQWQaRZRBZBpFlEFkGkWUQWQaRZRBZBpFlEFkGkWUQWQaRZRBZBpFlEFkGkWXQX1bJOGKz2RwOh/v9Xtb15nK56AeV8QdQ/jlkifV6/SFf/7GsMvgBQefzeblcMrXb7Uq0K98jS+CLKZSVcVe+TRZMzlLndrtV38FqtaL7brdbmf6B9uTUY1bL2NGn06nMPZF1vV6Vtl35Mso/kyzVQ7Vl/ID69ZUBFNn6qmUPqJt6LKuvKVD+j8tqz6zj8Viij3q0nqAOfj55VnC/32sZ0EdE+EQKw3aZIgNZ3U2B8veX9Yy2fmBIcHzkEyHO24aG9bCT0Er79VbWJ0yB8s8ni7NpUPAk2ptVloZjpy1V1odMgfL3l1UGDRSDKaYmX7WIsIDy8IIjJamyFGFKw0mqLG1YoB/LXCeUdg5ZQmW3xxYl1QtuwGuyQH+V8bZ9EyWfT5Y2FMVoqMMIKAwjnEEsoGwte02Wdp/6a3BEvonyzy2rWlBPjS3o5K7Lnt0DLVXWYMiDIu+jhPPJ0h+8bkMtHtTD65VO6Crr2W0oI8TrM2gKpHjwWvcOyj+HLC6pepTUt011FnFFcMEmkimoskCW+axmMaiVasyxLLK1C95H+fvL+gftjc5ziTZgsL5wlnUP15P3APrUbmNZUPOP/3l6AaWaQxZVceiMf2kaRF0D6KALKL42BY7KukenMFuV8a32Vp2UBboc2iZ9GeXvKeuLiSyDyDKILIPIMogsg8gyiCyDyDKILIPIMogsg8gyiCyDyDKILIPIMogsg8gyiCyDyDKILIPIMogsg8gyiCyDyDKILIPIMogsg8gyiCyDyDKILIPIMogsg8gyiCyDyDKILIPIMogsgyIr/IrF4i9O3m/GBVQ86AAAAABJRU5ErkJggg==",
    frontimage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAkhJREFUeF7t18Ft4kAcRnEaoINUQAc0QAdUQAEUQAPcKYAz9xRACVvSfsl/MrLW68gvjiJE3u+AmPEw4CfjkJWYP5rBWICxAGMBxgKMBRgLMBZgLMBYgLEAYwHGAowFGAswFmAswFiAsQBjAcYCjAUYCzAWYCzAWICxAGMBxgKMBRgLMBZgLMBYgLEAYwHGAn5FrPv93p4t852x2l7TttttW/pTrtfry8tLHtt4mXYabbRM22vaz8fKO+Z9HzdWGzwGYwHPEOt4PGZlzuFwONSrht/QzO92u/V6nfk87vf72+3Wjr3LgnpJ7tw5OlzZ7+X1FkOZqUNf1jZqo2Xmb1VnkiL1ksjz4aGx8/lcC6Ji5c5dmYYyWb2eLVbUtRCvr6+Zv1wufb5m8tib9uurYkVi9Yin06km86Rm4tG/hlOGn7hi5VTb+MNms8l8v8q6OucUrGGPlbg1U7JguCyeJ9bwPhW5vmplXVNDdcX1uD1WDbvxto8eqw0+VWeVxzZ+N5WgDA/Vyn9ah7Ga4SFjGWvCf2PRe9avjhWf/zXs88Z6g35nzY81fqOvefsQ0UbLzN9qKlbUobHxL/g5seqXV1merG3URsvM3+qTWJEW/WrKfSonPPW/YRt/GMfKfbBvNf52U7XP98R6esYCjAUYCzAWYCzAWICxAGMBxgKMBRgLMBZgLMBYgLEAYwHGAowFGAswFmAswFiAsQBjAcYCjAUYCzAWYCzAWICxAGMBxgKMBRgLMBZgLMBYgLEAYwHGAowFtFiaZbX6C2hay0Y0gxV3AAAAAElFTkSuQmCC",
    leftimage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAh5JREFUeF7t1sGt2kAYRWEaoAMqoAMaoAMqoAAKoAH2FJA1ewqghJSUK//ziGWZxEexF3k+Z4GYwYzlTxjPxlg/bUJigcQCiQUSCyQWSCyQWCCxQGKBxAKJBRILJBZILJBYILFAYoHEAokFEgskFkgskFggsUBigcQCiQUSCyQWSCyQWCCxQGKBxAKJBRILJBZILNA3wXq9Xu3dki2LNfviQTkej9vttlb+0bXb7fLajliyOul/g3U4HGrNKkY1I9ZIteD1em3jLz6xRqoF+zRrxMqf0eVy2e/39ZW8ybB91jW4AUcbfGX22mnaaO4mLh6pN1O/TL4fc2K1CiI09/u9ZvKm+PLsq5mqW2/Ft+Hj8cgxefwP9koZ1hbh+Xy2KbFy7+SY0TvofD7no/6zr1tvxVh//TPqO9aMWB8T63d1tRMfZLXgerHqj+l0OrXxH6sF14uVXUIdlsdim/qqdg+3262NxUp1wdkoxKU2EIHLDiuTgy1Ft94I1sS7+B+rsy+L9alcZx0WjtEdfPgGP7ea72Pl/q3JtDRZO00bzV1b/UNvrBSvXOqbLD+oKPS3o1V92sfKF+s3mAbb/dmrsyyF9c0SCyQWSCyQWCCxQGKBxAKJBRILJBZILJBYILFAYoHEAokFEgskFkgskFggsUBigcQCiQUSCyQWSCyQWCCxQGKBxAKJBRILJBZILJBYILFAYoHEAokFalg2qc3mF7emV+lhX3Y0AAAAAElFTkSuQmCC",
    rightimage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAwdJREFUeF7tl8GV4jAQREmADIiADEiADIiAAAiABLgTAGfuBEAIhLQ1rqafVzaMa+RZDFv/MM/dljTSpyXEzGjczAAsS8CyBCxLwLIELEvAsgQsS8CyBCxLwLIELEvAsgQsS8CyBCxLwLIELEvAsgQsS8CyBCxLwLIELEvAsgQsS8CyBCxLwLIELEvAsgQsS8CyBCxLwLIELEvAsgQsS+DzZV2v13iqZjRZMVAfi8Vis9mcz+doeodvIxjM6XRCr9VqFfFj0BL/Gn8jroYT/l1ZyfF4jNYNTEYwmOGy0AYtpysrgr+Bo+Vyibfz+TxSFXy4LICDA6bQoH7qny8LdKfe2yXLEKzXa5x0u90Oz2knZeEDwCucSgjxSeBYzLOcXdogw1c1xFgRVfB8nN7K6nbZbrdMJugFZXgoZEFoOk2Qoa93lYXZHw4HLgxVENmGogstACyMa0aVUTEoZAG8wshsud/vmUSGzUC3livhvxhN1hOwtuL2wHwEtxsrCMUVcQO6sFlXVtsLwDZEst39LWWhrLAGlkAbvo3gHl4ul4jv9G5DwDDh1stmYOqyImjAJ49qAo/Oi3aXRwpAYYEt21LIe8sCqaDYXISv+GxZX3ANoLi+A+b5bFkBvwqxH4tjq+jCcOCZ9bGysmqKzchkBHcpWHPEDXDHZv+LLABNbNC+PTATQcspls0aRIYXdPBjWYX9Gr7mASKq4Pk4WDy2IRpgS0aqr0s6TdCrqLjhsnjzIqMoi7EiquDbcXCTYBvctplhyOfk0W/DH8jCJ0TRAA+RrYBDjSDr92CBjFIaldDVJGRxJsUNI/dv9+bx7+EMJyGLWwZ7ML1gD3JLFr/AX0WjahqyoIZFVIBk+zv0hcSEIno1uFXhhMrrAh4Qdq+pr4KzmvQBPx0sS8CyBCxLwLIELEvAsgQsS8CyBCxLwLIELEvAsgQsS8CyBCxLwLIELEvAsgQsS8CyBCxLwLIELEvAsgQsS8CyBCxLwLIELEvAsgQsS8CyBCxLwLIELEvAsgRClhnEbPYH0gUbEtCHMj0AAAAASUVORK5CYII=",
    topimage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAldJREFUeF7t10FxAkEYRGEM4AAFOMAADlCAAARggDsCOHNHABIiKV30ZGprIcl2yGSS1HsndpnwL18NsJlR1gtNCKwgsILACgIrCKwgsILACgIrCKwgsILACgIrCKwgsILACgIrCKwgsILACgIrCKwgsILACgIrCKwgsILACgIrCKwgsILACgIrCKwgsILACgIrCKwgsILACmqLtdvtyoDPKn/wu2t7rWA91Wq10jghluM/la3AmpStfgXW5XLZbDaLxcKXtF6vj8djee7W6XTyU3qsV/DK+Xyuv7per17TNE/vjyUXvW1fzDBBlBUDLJ30g5r+VtZlXbPKsHLUvodYep+WWi6X5/NZZ7RTtOZ2abP9fu9lFUtp31lHJ73F9Mpe1i6P7oy13W51Uu959Gmyl877sGKNXOTr84Zul6d0xtKG0snD4VCO35Ld7eqKQsXSAy+oaaPp/Ohlvz1P74zla7gnUF7vpyqWnxrmPSiyctwmT/8nWFpcjtvk6f8Ea/jT2SJP74yVfmfdf5H7O6v+bjbK0ztjffxrqLsKH1as0Q6qv4atb7U8pTPWF+6z9Kxl691s68+g8ujOWCq6g/fHdpjOjHZli8qwctS+97CU9pdoKtkH/xvKRZ/cuhkfvlqLPP3nsJ6pYpXjH8/TwZqUp4M1KU8Ha1KeDtakPP1vYHUPrCCwgsAKAisIrCCwgsAKAisIrCCwgsAKAisIrCCwgsAKAisIrCCwgsAKAisIrCCwgsAKAisIrCCwgsAKAisIrCCwgsAKAisIrCCwgsAKKlg0qdnsFfMOaseS92wDAAAAAElFTkSuQmCC",
    bottomimage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAxtJREFUeF7tlssN4kAQREmADIiADEiADIiAAAiABLgTAGfuBEAIhLS1rnZvawzGhVbCEvUOiJnp+T33jL0wGg8zAcsSsCwByxKwLAHLErAsAcsSsCwByxKwLAHLErAsAcsSsCwByxKwLAHLErAsAcsSsCwByxKwLAHLErAsAcsSsCwByxKwLAHLErAsAcsSsCwByxKwLAHLErAsgRnJut/v8a9nWPNdNFkRPWCz2RwOh4/3drlcVqsVfqPccTwel8tlFOZB7DZK74joF6zX6898wTW6N7I4ZhTmAZekyYpCDwSdz2dkAZp2u13UKvyQLAJfaPrs4PycLPC09Xa7Id1wJbF1u91Ca7Q9HrjpWJ+ghu4q1SP+YxAmMn4x+PV6jbYOjolBkPJoZSQWkPPiNuR62H361YEuf4nSO0aCsQc0YRFR7sjj2ZCnVZU1jCen04kBgDG4QAFbE6wHU0ehB9NFz3dEhyi942lwvbPw0KK2yylWYtF8+IjM3dbIiccQs7ASG8bgqMEvsoyVmV85Rb5hEUZxuUhmE/50gf/6jsNgTdYr9vt9xHWgiEqsuMlzbqbm4ERZ3DDsRLmH3YfZWhUw8QFao6qDY9YnNwJH+D+ysI3qheuoB4QghvG5mSmyshdzqsKMQ9awSFmYncWk690mEaduDL6CI2iyolDAPnkcsMT0xeBGAWnsTJGF1qamUpsoC2OymNSY5AuyCCfOlGawZT2Hq8w7hcGW9Zxmld+9s+Yuq3mzjL8Nc29giizA8V+9DbN+7rKQI7zgoSCfPP7wuwabZBLBGncC6tv66YoZVg1K31lzkTVCc+jyY7Uhv4lI/arOdSMlo6ooS9cNwy/4+cpC7uTTbkAlmlIZEgEGo60HGZcJkqcJmcJzB2oaQlwGY1gMnjlF5iLrx7EsAcsSsCwByxKwLAHLErAsAcsSsCwByxKwLAHLErAsAcsSsCwByxKwLAHLErAsAcsSsCwByxKwLAHLErAsAcsSsCwByxKwLAHLErAsAcsSsCwByxKwLAHLErAsAcsSsCwByxKwLAHLEghZZhKLxR8vGE8Vs0exkQAAAABJRU5ErkJggg==";

function ViewCube(a, b) {
    var c = new FireflyWebGLRenderer({
        alpha: !0
    });
    c.setSize(150, 150);
    a.appendChild(c.domElement);
    var e = new THREE.PerspectiveCamera(45, 1, 1, 1E3);
    e.position.z = 600;
    var d = new THREE.Scene,
        g = new THREE.Vector3(0, 0, 0),
        f = new THREE.BoxGeometry(200, 200, 200),
        k = c.getMaxAnisotropy(),
        h = [];
    h.push(new THREE.MeshBasicMaterial({
        map: textureFromString(rightimage),
        anisotropy: k
    }));
    h.push(new THREE.MeshBasicMaterial({
        map: textureFromString(leftimage),
        anisotropy: k
    }));
    h.push(new THREE.MeshBasicMaterial({
        map: textureFromString(topimage),
        anisotropy: k
    }));
    h.push(new THREE.MeshBasicMaterial({
        map: textureFromString(bottomimage),
        anisotropy: k
    }));
    h.push(new THREE.MeshBasicMaterial({
        map: textureFromString(frontimage),
        anisotropy: k
    }));
    h.push(new THREE.MeshBasicMaterial({
        map: textureFromString(backimage),
        anisotropy: k
    }));
    var k = new THREE.MeshFaceMaterial(h),
        l = new THREE.Mesh(f, k);
    d.add(l);
    b.addEventListener("cameraChanged", function (a) {
        var b = a.camera.matrixWorldInverse.elements;
        g.set(b[2], b[6], b[10]);
        e.position.set(600 * g.x, 600 * g.y, 600 * g.z);
        g.set(0,
            0, 0);
        e.lookAt(g);
        e.up = a.camera.up;
        g.set(0, 1, 0);
        a = g.angleTo(e.up);
        b = g.cross(e.up).normalize();
        0 == b.lengthSq() && b.set(0, 0, 1);
        l.setRotationFromAxisAngle(b, a);
        c.render(d, e)
    });
    c.render(d, e)
}

function textureFromString(a) {
    var b = document.createElement("img"),
        c = new THREE.Texture(b);
    b.addEventListener("load", function (a) {
        c.needsUpdate = !0
    });
    b.src = a;
    return c
};
var CameraRaycaster = function (a, b) {
    this.projector = new THREE.Projector;
    this.raycaster = new THREE.Raycaster;
    this.camera = b;
    this.viewer = a;
    this.viewer.svf.fragments.fragToCachedNode || (this.viewer.svf.fragments.fragToCachedNode = [])
};
CameraRaycaster.prototype.castRay = function (a, b, c) {
    var e = this.viewer.canvas.getBoundingClientRect();
    return this.castRayViewport((a - e.left) / e.width * 2 - 1, 2 * -((b - e.top) / e.height) + 1, c)
};
CameraRaycaster.prototype.castRayViewport = function (a, b, c) {
    a = new THREE.Vector3(a, b, 1);
    this.projector.unprojectVector(a, this.camera);
    this.raycaster.set(this.camera.position, a.sub(this.camera.position).normalize());
    var e = this.raycaster.intersectObjects(this.viewer.modelQueue.geomScenes, !0);
    b = a = null;
    for (var d = 0; d < e.length; d++) {
        var g = e[d].object,
            f = g.visible;
        void 0 !== g.fragId && (f = 1 == (this.viewer.modelQueue.vizflags[g.fragId] & 3));
        if (f && (!c || !e[d].object.material.transparent)) {
            a = e[d].object;
            b = e[d].point;
            break
        }
    }
    c = null;
    a && (this.viewer.svf.fragments.fragToDbNode && this.viewer.svf.fragments.fragToDbNode[a.fragId] ? c = this.viewer.svf.fragments.fragToDbNode[a.fragId] : (this.viewer.svf.fragments.fragToCachedNode[a.fragId] || (this.viewer.svf.fragments.fragToCachedNode[a.fragId] = {
        dbId: 0,
        fragIds: a.fragId
    }), c = this.viewer.svf.fragments.fragToCachedNode[a.fragId]));
    return {
        node: c,
        intersectPoint: b
    }
};
var USE_SERVER_SIDE_SEARCH = !1,
    NUM_WORKER_THREADS = 3,
    NUM_PARALLEL_DOWNLOADS = 2,
    WORKER_SCRIPT = null;
LMV_WORKER_URL || (LMV_WORKER_URL = "src/workers/mainworker.js");
void 0 == ENABLE_INLINE_WORKER && (ENABLE_INLINE_WORKER = !1);
ENABLE_DEBUG && (NUM_PARALLEL_DOWNLOADS = NUM_WORKER_THREADS = 6);
var WORKER_LOAD_GEOMETRY = "LOAD_GEOMETRY",
    WORKER_LOAD_SVF = "LOAD_SVF",
    WORKER_SEARCH = "SEARCH",
    WORKER_GET_PROPERTIES = "GET_PROPERTIES",
    WORKER_SEARCH_PROPERTIES = "SEARCH_PROPERTIES",
    WORKER_GET_OBJECT_TREE = "GET_OBJECT_TREE";

function SvfLoader(a) {
    this.viewer3DImpl = a;
    this.next_pack = 0;
    this.loading = !1;
    this.tmpMatrix = new THREE.Matrix4;
    this.getObjectTreeCallbacks = []
}
SvfLoader.prototype.pathToURL = function (a) {
    if ("http://" == a.substr(0, 7) || "https://" == a.substr(0, 8) || "file:///" == a.substr(0, 8) || "urn:" == a.substr(0, 4)) return a;
    var b = window.location.pathname,
        c = b.lastIndexOf("/"),
        b = b.substr(0, c + 1);
    return window.location.protocol + "//" + window.location.host + b + a
};
SvfLoader.prototype.loadSvf = function (a, b, c, e) {
    if (this.loading) return stderr("loading of SVF already in progress."), !1;
    this.sharedDbPath = e;
    console.log("shared db path: " + this.sharedDbPath);
    if (ENABLE_INLINE_WORKER) {
        var d = new XMLHttpRequest;
        d.open("GET", RESOURCE_ROOT + LMV_WORKER_URL, !0);
        d.setRequestHeader("Access-Control-Allow-Origin", "*");
        var g = this;
        d.onload = function () {
            WORKER_SCRIPT = d.responseText;
            g.loadSvfCB(a, b, c)
        };
        d.send();
        return !0
    }
    return this.loadSvfCB(a, b, c)
};
SvfLoader.prototype.loadSvfCB = function (a, b, c) {
    this.t0 = (new Date).getTime();
    var e = ENABLE_DEBUG || !ENABLE_INLINE_WORKER ? new Worker(LMV_WORKER_URL) : createWorker(),
        d = this;
    e.addEventListener("message", function (b) {
        if (b.data && b.data.svf) {
            b = d.svf = b.data.svf;
            b.geomPolyCount = 0;
            b.instancePolyCount = 0;
            b.geomMemory = 0;
            b.fragments.numLoaded = 0;
            b.meshCount = 0;
            b.gpuNumMeshes = 0;
            b.gpuMeshMemory = 0;
            b.basePath = "";
            var g = a.lastIndexOf("/"); - 1 != g && (b.basePath = a.substr(0, g + 1));
            d.onSvfLoadDone(b);
            c && c.call(d);
            if (g = b.geompacks.length)
                for (var g =
                    Math.min(g, NUM_PARALLEL_DOWNLOADS), h = 0; h < g; h++) {
                    var l = b.geompacks[h];
                    d.loadGeometryPack(l.id, l.uri);
                    d.next_pack = h + 1
                } else d.onGeomLoadDone();
            d.loading = !1;
            e.terminate()
        } else b.data && b.data.progress || (b.data && b.data.error ? d.viewer3DImpl.raiseError(b.data.error.code, b.data.error.msg, b.data.error.args) : (stderr("SVF download failed."), d.loading = !1, e.terminate()))
    }, !1);
    var g = this.pathToURL(a);
    e.postMessage({
        operation: WORKER_LOAD_SVF,
        url: g,
        headers: {},
        objectIds: b,
        auth: auth,
        viewing_url: VIEWING_URL
    });
    return !0
};
SvfLoader.prototype.loadGeometryPack = function (a, b) {
    var c, e, d, g = this;
    if (!this.pack_workers)
        for (this.pack_workers = [], c = 0; c < NUM_WORKER_THREADS; c++) e = ENABLE_DEBUG || !ENABLE_INLINE_WORKER ? new Worker(LMV_WORKER_URL) : createWorker(), e.addEventListener("message", function (a) {
            if (a.data && a.data.mesh) {
                if (g.processReceivedMesh(a.data), 1 <= a.data.progress) {
                    g.pack_workers[a.data.workerId].queued -= 1;
                    a = !0;
                    for (d = 0; d < g.pack_workers.length; d++) 0 != g.pack_workers[d].queued && (a = !1);
                    if (a) {
                        for (d = 0; d < NUM_WORKER_THREADS; d++) g.pack_workers[d].terminate();
                        g.pack_workers = null
                    }
                    g.svf.fragments.numLoaded == g.svf.fragments.length && (g.onGeomLoadDone(), g.loadTextures())
                }
            } else a.data && a.data.progress ? (g.pack_workers[a.data.workerId].queued -= 1, g.next_pack < g.svf.geompacks.length && (a = g.svf.geompacks[g.next_pack++], g.loadGeometryPack(a.id, a.uri))) : a.data && a.data.error ? g.viewer3DImpl.raiseError(a.data.error.code, a.data.error.msg, a.data.error.args) : g.pack_workers[a.data.workerId].queued -= 2
        }, !1), e.queued = 0, this.pack_workers.push(e);
    e = 0;
    var f = this.pack_workers[0].queued;
    for (c = 1; c < NUM_WORKER_THREADS; c++) this.pack_workers[c].queued < f && (e = c);
    c = this.pack_workers[e];
    c.queued += 2;
    f = this.pathToURL(this.svf.basePath + b);
    e = {
        operation: WORKER_LOAD_GEOMETRY,
        url: f,
        packId: parseInt(a),
        headers: {},
        workerId: e,
        auth: auth,
        viewing_url: VIEWING_URL
    };
    c.postMessage(e)
};
SvfLoader.prototype.convertMaterials = function () {
    var a = this.svf;
    if (a.materials) {
        var b = a.materials.materials,
            c;
        for (c in b)
            if (b = a.simplemats[c]) {
                b.color = (new THREE.Color).copy(b.color);
                b.ambient = (new THREE.Color).copy(b.ambient);
                b.specular = (new THREE.Color).copy(b.specular);
                b.emissive = (new THREE.Color).copy(b.emissive);
                var e = new THREE.MeshPhongMaterial(b);
                e.metal = b.metal;
                !_isIE11 && (b.doubleSided || a.metadata && a.metadata.hasOwnProperty("double sided geometry") && a.metadata["double sided geometry"].value) &&
                    (e.side = THREE.DoubleSide);
                for (var d in b) 0 == d.indexOf("uri_") && (e[d] = b[d]), 0 == d.indexOf("uscale_") && (e[d] = b[d]), 0 == d.indexOf("vscale_") && (e[d] = b[d]);
                this.viewer3DImpl.addMaterial(c, e)
            } else this.viewer3DImpl.addMaterial(c, new THREE.MeshPhongMaterial({
                ambient: 197379,
                color: 7829367,
                specular: 3355443,
                shininess: 30,
                shading: THREE.SmoothShading
            }))
    }
};
SvfLoader.prototype.loadTextures = function () {
    var a = this.svf,
        b = this;
    b.textures = {};
    for (var c in b.viewer3DImpl.materials) {
        var e = b.viewer3DImpl.materials[c];
        if (e) {
            var d = function (a) {
                    for (var c = b.textures[a.name], d = 0; d < c.mats.length; d++) c.mats[d][c.slots[d]] = a;
                    b.viewer3DImpl.addTexture(c)
                },
                g = ["map", "bumpMap", "specularMap", "normalMap", "envMap"];
            e.bumpScale && 1 <= e.bumpScale && (e.bumpScale = 0.03);
            for (var f = 0; f < g.length; f++) {
                var k = e["uri_" + g[f]];
                if (k)
                    if (b.textures[k]) b.textures[k].mats.push(e), b.textures[k].slots.push(g[f]);
                    else {
                        var h = "envMap" == g[f],
                            k = k.replace(/\\/g, "/"),
                            l = b.pathToURL(a.basePath + k),
                            m = l.indexOf("urn:"); - 1 != m && (l = l.substr(0, m) + encodeURIComponent(l.substr(m)));
                        var m = e["uscale_" + g[f]],
                            n = e["vscale_" + g[f]];
                        m || (m = 1);
                        n || (n = 1);
                        auth && (auth.oauth0 ? l = l + "?oauth_token=" + encodeURIComponent(auth.access_token) : auth.oauthNone && (-1 != l.indexOf("/items/") ? THREE.ImageUtils.crossOrigin = "use-credentials" : THREE.ImageUtils.crossOrigin = ""));
                        l = h ? THREE.ImageUtils.loadTexture(l, new THREE.SphericalReflectionMapping, d) : THREE.ImageUtils.loadTexture(l,
                            new THREE.UVMapping, d);
                        l.name = k;
                        b.textures[k] = {
                            mats: [e],
                            slots: [g[f]],
                            tex: l
                        };
                        l.anisotropy = "bumpMap" == g[f] || "normalMap" == g[f] ? 0 : b.viewer3DImpl.renderer.getMaxAnisotropy();
                        l.repeat.set(m, n);
                        l.wrapS = THREE.RepeatWrapping;
                        l.wrapT = THREE.RepeatWrapping;
                        l.flipY = !h;
                        h && (a.envMap = l)
                    }
            }
        }
    }
};

function meshToGeometry(a) {
    var b = a.mesh,
        c = new THREE.BufferGeometry;
    a.byteSize = 0;
    if (b.vb) {
        c.vb = b.vb;
        c.vbstride = b.vbstride;
        for (var e in b.vblayout) {
            var d = b.vblayout[e];
            c.attributes[e] = {
                itemSize: d.itemSize,
                itemOffset: d.offset,
                isPattern: d.isPattern
            }
        }
        a.byteSize += b.vb.byteLength
    } else {
        c.attributes.position = {
            itemSize: 3,
            array: b.vertices
        };
        a.byteSize += b.vertices.byteLength;
        b.normals && (c.attributes.normal = {
            itemSize: 3,
            array: b.normals
        }, a.byteSize += b.normals.byteLength);
        b.colors && (c.attributes.color = {
            itemSize: 3,
            array: b.colors
        }, a.byteSize += b.colors.byteLength);
        if (b.uvs)
            for (e = 0; e < b.uvs.length; e++) d = "uv", e && (d += (e + 1).toString()), c.attributes[d] = {
                itemSize: 2,
                array: b.uvs[e].data,
                isPattern: b.uvs[e].isPattern
            }, a.byteSize += b.uvs[e].data.byteLength;
        a.mesh.isLines || b.normals.length || (stderr("Mesh without normals, consider computing them in loader thread"), c.computeVertexNormals())
    }
    c.attributes.index = {
        itemSize: 1,
        array: b.indices
    };
    a.byteSize += b.indices.byteLength;
    c.offsets.push({
        start: 0,
        index: 0,
        count: b.indices.length
    });
    c.freeCPUBuffers = !1;
    65535 < b.indices.length && stderr("Mesh with >65535 indices. May have to break up the draw calls.");
    c.boundingBox = (new THREE.Box3).copy(b.boundingBox);
    c.boundingSphere = (new THREE.Sphere).copy(b.boundingSphere);
    a.geometry = c;
    a.geometry.isLines = !0 === a.mesh.isLines;
    delete a.mesh
}

function getFragmentTransform(a, b, c) {
    c *= 16;
    b = b.transforms;
    for (var e = !0, d = 0; 16 > d; d++)
        if (d % 5 && 0 != b[c + d] || !(d % 5) && 1 != b[c + d]) {
            e = !1;
            break
        }
    if (e) return null;
    for (e = 0; 16 > e; e++) a.elements[e] = b[c + e];
    return a
}
SvfLoader.prototype.processReceivedMesh = function (a) {
    meshToGeometry(a);
    var b = a.packId + ":" + a.meshIndex,
        c = this.svf,
        e = c.fragments,
        d = e.mesh2frag[b];
    if (void 0 === d) stderr("Mesh " + b + " was not referenced by any fragments.");
    else {
        c.meshCount++;
        var g = MAX_FRAGS_PER_GROUP;
        if (!a.geometry.isLines)
            if (67108864 > c.gpuMeshMemory && c.gpuNumMeshes < g) a.geometry.streamingDraw = !1, a.geometry.streamingIndex = !1;
            else if (134217728 < c.gpuMeshMemory || 2E3 < c.gpuNumMeshes) a.geometry.streamingDraw = !0, a.geometry.streamingIndex = !0;
        else {
            var f;
            Array.isArray(d) ? f = d.length * a.byteSize : 300 > (0 | d) ? (a.geometry.streamingDraw = !1, a.geometry.streamingIndex = !1) : f = a.byteSize;
            1E5 > f && (a.geometry.streamingDraw = !0, a.geometry.streamingIndex = !0)
        }
        a.geometry.streamingDraw || (c.gpuMeshMemory += a.byteSize, c.gpuNumMeshes += 1);
        if (Array.isArray(d))
            for (f = 0; f < d.length; f++) {
                var k = 0 | d[f],
                    g = e.materials[k];
                this.viewer3DImpl.addMeshInstance(a.geometry, k, g, getFragmentTransform(this.tmpMatrix, e, k))
            } else f = getFragmentTransform(this.tmpMatrix, e, 0 | d), g = e.materials[d], this.viewer3DImpl.addMeshInstance(a.geometry,
                0 | d, g, f);
        delete e.mesh2frag[b];
        b = a.geometry.attributes.index.array.length / 3;
        c.geomPolyCount += b;
        c.instancePolyCount += b * (d.length || 1);
        c.geomMemory += a.byteSize;
        a = !e.numLoaded;
        e.numLoaded += d.length || 1;
        d = e.numLoaded;
        e = e.length;
        c = d / e;
        b = 0 | e / d;
        if (a || 0 == (b & b - 1) && this.lastRepaintFract != b) this.lastRepaintFract = b, this.viewer3DImpl.needsRender = !0;
        1 > c && 0 == d % 10 && this.viewer3DImpl.signalProgress(100 * c, "fragment " + d + " / " + e)
    }
};
SvfLoader.prototype.onSvfLoadDone = function (a) {
    var b = (new Date).getTime();
    stderr("SVF load: " + (b - this.t0));
    this.viewer3DImpl.signalProgress(5, "Hold on, getting the model...");
    this.t0 = b;
    this.convertMaterials();
    this.viewer3DImpl.initScene(a)
};
SvfLoader.prototype.onGeomLoadDone = function () {
    this.svf.loadDone = !0;
    delete this.svf.fragments.entityIndexes;
    delete this.svf.fragments.packIds;
    var a = "Fragments load time: " + ((new Date).getTime() - this.t0);
    this.viewer3DImpl.signalProgress(100, a);
    this.viewer3DImpl.api.fireEvent({
        type: Autodesk.Viewing.GEOMETRY_LOADED_EVENT
    });
    stderr(a);
    stderr("Total geometry size: " + this.svf.geomMemory / 1048576 + " MB");
    stderr("Number of meshes: " + this.svf.meshCount);
    stderr("Num Meshes on GPU: " + this.svf.gpuNumMeshes);
    stderr("Net GPU geom memory used: " +
        this.svf.gpuMeshMemory);
    this.viewer3DImpl.needsRender = !0
};
SvfLoader.prototype.getProperties = function (a, b) {
    this.propWorker || (this.propWorker = ENABLE_DEBUG || !ENABLE_INLINE_WORKER ? new Worker(LMV_WORKER_URL) : createWorker());
    var c = this,
        e = function (d) {
            d.data && d.data.error ? c.viewer3DImpl.raiseError(d.data.error.code, d.data.error.msg, d.data.error.args) : d.data && d.data.dbId === a && (b(d.data.result), c.propWorker.removeEventListener("message", e))
        };
    this.propWorker.addEventListener("message", e, !1);
    var d = this.pathToURL(this.svf.basePath);
    this.sharedDbPath && !this.svf.propertydb.values.length &&
        (d = this.sharedDbPath, stderr("Using shared property db: " + d));
    this.propWorker.postMessage({
        operation: WORKER_GET_PROPERTIES,
        url: d,
        propertydb: this.svf.propertydb,
        dbId: a,
        headers: {},
        auth: auth,
        viewing_url: VIEWING_URL
    })
};
SvfLoader.prototype.searchProperties = function (a, b) {
    var c = this;
    if (USE_SERVER_SIDE_SEARCH) {
        this.searchWorker || (this.searchWorker = ENABLE_DEBUG || !ENABLE_INLINE_WORKER ? new Worker(LMV_WORKER_URL) : createWorker());
        var e = function (a) {
            a.data && a.data.error ? c.viewer3DImpl.raiseError(a.data.error.code, a.data.error.msg, a.data.error.args) : (a = JSON.parse(a.data), "debug" == a.type ? stderr(a.debug) : "response" == a.type && (b(a.response), c.searchWorker.removeEventListener("message", e)))
        };
        this.searchWorker.addEventListener("message",
            e, !1);
        this.searchWorker.postMessage({
            operation: WORKER_SEARCH,
            keyword: a,
            url: this.pathToURL(this.svf.basePath),
            id: this.svf.manifest.adskID
        })
    } else {
        this.propWorker || (this.propWorker = ENABLE_DEBUG || !ENABLE_INLINE_WORKER ? new Worker(LMV_WORKER_URL) : createWorker());
        e = function (a) {
            a.data && a.data.error ? c.viewer3DImpl.raiseError(a.data.error.code, a.data.error.msg, a.data.error.args) : (b(a.data), c.propWorker.removeEventListener("message", e))
        };
        this.propWorker.addEventListener("message", e, !1);
        var d = this.pathToURL(this.svf.basePath);
        this.sharedDbPath && !this.svf.propertydb.values.length && (d = this.sharedDbPath, stderr("Using shared property db: " + d));
        this.propWorker.postMessage({
            operation: WORKER_SEARCH_PROPERTIES,
            url: d,
            propertydb: this.svf.propertydb,
            searchText: a,
            headers: {},
            auth: auth,
            viewing_url: VIEWING_URL
        })
    }
};
SvfLoader.prototype.createFragToNodeMapping = function () {
    var a = this.svf,
        b = a.fragments.fragId2dbId;
    if (a.instanceTree && b) {
        var c = a.fragments.fragToDbNode = Array(b.length);
        (function d(a) {
            var b = a.fragIds;
            if (void 0 !== b)
                if (Array.isArray(b))
                    for (var k = 0; k < b.length; k++) c[b[k]] = a;
                else c[b] = a;
            if (a.children)
                for (b = 0; b < a.children.length; b++) d(a.children[b])
        })(a.instanceTree)
    }
};
SvfLoader.prototype.getObjectTree = function (a) {
    function b() {
        for (var a = 0; a < c.getObjectTreeCallbacks.length; a++) c.getObjectTreeCallbacks[a](c.svf.instanceTree);
        c.getObjectTreeCallbacks = []
    }
    var c = this;
    this.propWorker || (this.propWorker = ENABLE_DEBUG || !ENABLE_INLINE_WORKER ? new Worker(LMV_WORKER_URL) : createWorker());
    this.getObjectTreeCallbacks.push(a);
    if (c.svf.instanceTree) b();
    else {
        var e = function (a) {
            if (!a.data || !a.data.error) {
                var g = a.data.instanceTree,
                    f = a.data.instanceBoxes;
                g && (c.svf.instanceTree || (c.svf.instanceTree =
                    g, c.svf.maxTreeDepth = a.data.maxTreeDepth, c.createFragToNodeMapping()), b());
                f && (c.svf.instanceBoxes = f, c.propWorker.removeEventListener("message", e))
            }
        };
        this.propWorker.addEventListener("message", e, !1);
        a = this.pathToURL(this.svf.basePath);
        this.sharedDbPath && !this.svf.propertydb.values.length && (a = this.sharedDbPath, stderr("Using shared property db: " + a));
        this.propWorker.postMessage({
            operation: WORKER_GET_OBJECT_TREE,
            url: a,
            propertydb: this.svf.propertydb,
            headers: {},
            fragToDbId: this.svf.fragments.fragId2dbId,
            fragBoxes: this.svf.fragments.boxes,
            auth: auth,
            viewing_url: VIEWING_URL
        })
    }
};
SvfLoader.prototype.testSearchQuery = function () {
    stderr("debug : test search query...");
    try {
        var a = this,
            b = ENABLE_DEBUG || !ENABLE_INLINE_WORKER ? new Worker(LMV_WORKER_URL) : createWorker();
        b.addEventListener("message", function (b) {
            b.data && b.data.error ? a.viewer3DImpl.raiseError(b.data.error.code, b.data.error.msg, b.data.error.args) : (b = JSON.parse(b.data), "debug" == b.type ? stderr(b.debug) : "response" == b.type && stderr(JSON.stringify(b.response)))
        }, !1);
        b.postMessage({
            operation: WORKER_SEARCH,
            keyword: "walkway",
            url: this.pathToURL(this.svf.basePath)
        })
    } catch (c) {
        stderr("exception : " +
            c.message)
    }
};

function createWorker() {
    var a;
    window.URL = window.URL || window.webkitURL;
    try {
        a = new Blob([WORKER_SCRIPT], {
            type: "application/javascript"
        })
    } catch (b) {
        a = new BlobBuilder, a.append(WORKER_SCRIPT), a = a.getBlob()
    }
    return new Worker(URL.createObjectURL(a))
};
var Stats = function () {
    var a = Date.now(),
        b = a,
        c = 0,
        e = Infinity,
        d = 0,
        g = 0,
        f = Infinity,
        k = 0,
        h = 0,
        l = 0,
        m = document.createElement("div");
    m.id = "stats";
    m.addEventListener("mousedown", function (a) {
        a.preventDefault();
        w(++l % 2)
    }, !1);
    m.style.cssText = "width:80px;opacity:0.9;cursor:pointer";
    var n = document.createElement("div");
    n.id = "fps";
    n.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#002";
    m.appendChild(n);
    var r = document.createElement("div");
    r.id = "fpsText";
    r.style.cssText = "color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";
    r.innerHTML = "FPS";
    n.appendChild(r);
    var s = document.createElement("div");
    s.id = "fpsGraph";
    s.style.cssText = "position:relative;width:74px;height:30px;background-color:#0ff";
    for (n.appendChild(s); 74 > s.children.length;) {
        var t = document.createElement("span");
        t.style.cssText = "width:1px;height:30px;float:left;background-color:#113";
        s.appendChild(t)
    }
    var p = document.createElement("div");
    p.id = "ms";
    p.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#020;display:none";
    m.appendChild(p);
    var u = document.createElement("div");
    u.id = "msText";
    u.style.cssText = "color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";
    u.innerHTML = "MS";
    p.appendChild(u);
    var v = document.createElement("div");
    v.id = "msGraph";
    v.style.cssText = "position:relative;width:74px;height:30px;background-color:#0f0";
    for (p.appendChild(v); 74 > v.children.length;) t = document.createElement("span"), t.style.cssText = "width:1px;height:30px;float:left;background-color:#131", v.appendChild(t);
    var w = function (a) {
        l = a;
        switch (l) {
        case 0:
            n.style.display =
                "block";
            p.style.display = "none";
            break;
        case 1:
            n.style.display = "none", p.style.display = "block"
        }
    };
    return {
        REVISION: 11,
        domElement: m,
        setMode: w,
        begin: function () {
            a = Date.now()
        },
        end: function () {
            var l = Date.now();
            c = l - a;
            e = Math.min(e, c);
            d = Math.max(d, c);
            u.textContent = c + " MS (" + e + "-" + d + ")";
            var m = Math.min(30, 30 - c / 200 * 30);
            v.appendChild(v.firstChild).style.height = m + "px";
            h++;
            l > b + 2E3 && (g = Math.round(1E3 * h / (l - b)), f = Math.min(f, g), k = Math.max(k, g), r.textContent = g + " FPS (" + f + "-" + k + ")", m = Math.min(30, 30 - g / 100 * 30), s.appendChild(s.firstChild).style.height =
                m + "px", b = l, h = 0, e = Infinity, d = 0);
            return l
        },
        update: function () {
            a = this.end()
        }
    }
};
var MAX_FRAGS_PER_GROUP = 333;

function RenderQueue(a, b) {
    this.currentScene = 0;
    this.vizmeshes = Array(a.length);
    this.vizflags = new Uint8Array(a.length);
    this.prototypeScene = b;
    this.drawMode = RenderQueue.NORMAL;
    var c = 0 | (a.length + MAX_FRAGS_PER_GROUP - 1) / MAX_FRAGS_PER_GROUP;
    this.geomScenes = Array(c);
    for (var e = 0; e < c; e++)(this.geomScenes[e] = new THREE.Scene(!0)).__lights = b.__lights;
    this.boundingboxes = a.boxes;
    this.transforms = a.transforms;
    this.allVisible = !0;
    this.allVisibleDirty = !1
}
RenderQueue.NORMAL = 0;
RenderQueue.HIGHLIGHTED = 1;
RenderQueue.HIDDEN = 2;
RenderQueue.MESH_VISIBLE = 1;
RenderQueue.MESH_HIGHLIGHTED = 2;
RenderQueue.prototype.addMesh = function (a, b) {
    var c = this.vizmeshes[a];
    c && (stderr("duplicate fragment."), c.parent.remove(c));
    this.vizmeshes[a] = b;
    this.vizflags[a] = 1;
    b.fragId = a;
    var c = 0 | a / MAX_FRAGS_PER_GROUP,
        e = this.geomScenes[c];
    e || (this.geomScenes[c] = e = new THREE.Scene(!0), e.__lights = this.prototypeScene.__lights);
    e.add(b)
};
RenderQueue.prototype.renderSome = function (a, b) {
    var c, e, d = this.vizflags,
        g = Date.now(),
        f = !0;
    c = this.currentScene;
    for (e = this.geomScenes.length; c < e; c++) {
        var k = this.geomScenes[c];
        if (f) {
            if (0 >= b) break;
            f = !1
        } else if (b <= 0.5 * k.avgFrameTime) break;
        var h = k.children;
        if (this.drawMode == RenderQueue.HIDDEN)
            for (var l = 0, m = h.length; l < m; l++) {
                var n = h[l];
                n.visible = !(d[n.fragId] & 1)
            } else if (this.drawMode == RenderQueue.HIGHLIGHTED)
                for (l = 0, m = h.length; l < m; l++) n = h[l], n.visible = !!(d[n.fragId] & 2);
            else
                for (l = 0, m = h.length; l < m; l++) n = h[l],
                    n.visible = 1 == d[n.fragId];
        a(k);
        h = Date.now();
        l = h - g;
        g = h;
        k.avgFrameTime = void 0 === k.avgFrameTime ? l : 0.8 * k.avgFrameTime + 0.2 * l;
        this.currentScene = c + 1;
        b -= k.avgFrameTime
    }
    return b
};
RenderQueue.prototype.isDone = function () {
    return this.currentScene == this.geomScenes.length
};
RenderQueue.prototype.reset = function (a) {
    this.camera = a;
    this.currentScene = 0
};
RenderQueue.prototype.drawNormalObjectsOnly = function () {
    this.drawMode = RenderQueue.NORMAL
};
RenderQueue.prototype.drawHighlightedObjectsOnly = function () {
    this.drawMode = RenderQueue.HIGHLIGHTED
};
RenderQueue.prototype.drawHiddenObjectsOnly = function () {
    this.drawMode = RenderQueue.HIDDEN
};
RenderQueue.prototype.setOverrideMaterial = function (a) {
    for (var b = 0, c = this.geomScenes.length; b < c; b++) this.geomScenes[b].overrideMaterial = a
};
RenderQueue.prototype.setHightlighted = function (a, b) {
    var c = this.vizflags[a];
    this.vizflags[a] = b ? c | 2 : c & -3
};
RenderQueue.prototype.setAllHighlighted = function (a) {
    var b = this.vizflags;
    if (a) {
        a = 0;
        for (var c = b.length; a < c; a++) b[a] |= 2
    } else
        for (a = 0, c = b.length; a < c; a++) b[a] &= -3
};
RenderQueue.prototype.setVisibility = function (a, b) {
    this.vizflags[a] = b ? this.vizflags[a] | 1 : this.vizflags[a] & -2;
    this.allVisibleDirty = !0
};
RenderQueue.prototype.setAllVisibility = function (a) {
    var b = this.vizflags;
    if (a)
        for (var c = 0, e = b.length; c < e; c++) b[c] |= 1;
    else
        for (c = 0, e = b.length; c < e; c++) b[c] &= -2;
    this.allVisible = a;
    this.allVisibleDirty = !1
};
RenderQueue.prototype.hideLines = function (a) {
    var b = this.vizflags;
    if (a) {
        a = 0;
        for (var c = b.length; a < c; a++) this.vizmeshes[a] instanceof THREE.Line && (b[a] |= 4)
    } else
        for (a = 0, c = b.length; a < c; a++) this.vizmeshes[a] instanceof THREE.Line && (b[a] &= -5);
    this.allVisibleDirty = !0
};
RenderQueue.prototype.isFragVisible = function (a) {
    return 0 != (this.vizflags[a] & 1)
};
RenderQueue.prototype.areAllVisible = function () {
    if (this.allVisibleDirty) {
        this.allVisible = !0;
        this.allVisibleDirty = !1;
        for (var a = this.vizflags, b = 0, c = a.length; b < c; b++)
            if (0 == (a[b] & 1)) {
                this.allVisible = !1;
                break
            }
    }
    return this.allVisible
};
RenderQueue.prototype.getVisibleBounds = function (a) {
    for (var b = new THREE.Box3, c = new THREE.Vector3, e = new THREE.Vector3, d = new THREE.Box3, g = this.boundingboxes, f = this.vizflags, k = 0, h = f.length; k < h; k++)
        if (f[k] & 1) {
            var l = 6 * k;
            c.x = g[l];
            c.y = g[l + 1];
            c.z = g[l + 2];
            e.x = g[l + 3];
            e.y = g[l + 4];
            e.z = g[l + 5];
            if (a) {
                var l = 16 * k,
                    m = this.vizmeshes[k].matrixWorld.elements;
                c.x += m[12] - this.transforms[l + 12];
                e.x += m[12] - this.transforms[l + 12];
                c.y += m[13] - this.transforms[l + 13];
                e.y += m[13] - this.transforms[l + 13];
                c.z += m[14] - this.transforms[l + 14];
                e.z += m[14] - this.transforms[l + 14]
            }
            d.set(c, e);
            b.union(d)
        }
    return b
};

function RenderContext() {
    var a, b, c, e, d, g, f, k, h, l, m, n, r = null,
        s = null,
        t = null,
        p = null,
        u = null,
        v, w, y = {
            r: 0,
            g: 0,
            b: 0
        },
        x = {
            antialias: !0,
            sao: !1,
            useHdrTarget: !1,
            haveTwoSided: !1
        };
    this.settings = x;
    this.init = function (a, c, d) {
        b = a;
        v = c;
        w = d;
        this.initPostPipeline(!1)
    };
    this.beginScene = function (b, c, g) {
        e = c;
        g && (a.setClearColor(y, 0), a.clearTarget(s, !1, !0, !1), d.render(a, s, null));
        a.render(b, c, s, !1);
        x.sao && (g && (a.setClearColor(y, 0), a.clearTarget(n, !0, !1, !1)), a.render(b, c, n, !1), f.uniforms.cameraNear.value = c.near, f.uniforms.cameraFar.value =
            c.far, h.uniforms.cameraNear.value = c.near, h.uniforms.cameraInvNearFar.value = 1 / (c.near - c.far), b = c.projectionMatrix.elements, f.uniforms.projInfo.value.set(-2 / (s.width * b[0]), -2 / (s.height * b[5]), (1 - b[8]) / b[0], (1 - b[9]) / b[5]), f.uniforms.projScale.value = 0.125 * s.height * b[5])
    };
    this.renderScenePart = function (b, d) {
        if (this.hasMRT()) x.sao ? a.render(b, e, [s, n]) : a.render(b, e, s);
        else if (a.render(b, e, s), x.sao && !d) {
            var f = b.overrideMaterial;
            b.overrideMaterial = c;
            a.render(b, e, n);
            b.overrideMaterial = f
        }
    };
    this.clearAllOverlays =
        function () {
            a.clearTarget(t, !0, !1, !1)
    };
    this.renderOverlays = function (b) {
        var c = 0,
            d;
        for (d in b)
            if (b.hasOwnProperty(d)) {
                var f = b[d],
                    g = f.scene,
                    k = f.camera ? f.camera : e;
                g.children.length && (c || (c = 1, a.setClearColor(y, 0), a.clearTarget(t, !0, !1, !1)), f.materialPre && (g.overrideMaterial = f.materialPre, a.render(g, k, t, !1)), f.materialPost && (g.overrideMaterial = f.materialPost, a.context.depthFunc(a.context.GREATER), a.render(g, k, t, !1), a.context.depthFunc(a.context.LEQUAL)), g.overrideMaterial = null)
            }
        m.uniforms.useOverlay.value =
            c
    };
    this.composeFinalFrame = function (b) {
        if (!b && x.sao) {
            if (r) {
                b = r[0];
                h.uniforms.resolution.value.set(1 / b.width, 1 / b.height);
                h.render(a, b, n);
                for (var c = 1; c < r.length; c++) {
                    var d = r[c];
                    k.uniforms.resolution.value.set(1 / d.width, 1 / d.height);
                    k.render(a, d, b);
                    b = d
                }
            }
            f.render(a, p, s);
            g.uniforms.axis.value.set(1, 0);
            g.render(a, u, p);
            g.uniforms.axis.value.set(0, 1);
            g.render(a, p, u)
        }
        l ? (m.render(a, u, s), l.render(a, null, u)) : m.render(a, null, s);
        a.endFrame()
    };
    this.setSize = function (b, c, d) {
        v = b;
        w = c;
        a.setSize(b, c);
        b = 0 | b * a.devicePixelRatio;
        c = 0 | c * a.devicePixelRatio;
        if (d || !s || s.width != b || s.height != c) s = new THREE.WebGLRenderTarget(b, c, {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBFormat,
            type: x.useHdrTarget ? THREE.FloatType : THREE.UnsignedByteType,
            stencilBuffer: !1
        }), t = new THREE.WebGLRenderTarget(b, c, {
            minFilter: THREE.NearestFilter,
            magFilter: THREE.NearestFilter,
            format: THREE.RGBAFormat,
            stencilBuffer: !1
        }), t.shareDepthFrom = s;
        if (x.sao && (d || !n || n.width != b || n.height != c)) {
            n = new THREE.WebGLRenderTarget(b, c, {
                minFilter: THREE.NearestFilter,
                magFilter: THREE.NearestFilter,
                format: THREE.RGBFormat,
                type: THREE.FloatType,
                stencilBuffer: !1
            });
            n.shareDepthFrom = s;
            r = [];
            for (d = 0; 5 > d; d++) {
                var e = new THREE.WebGLRenderTarget(0 | b / (2 << d), 0 | c / (2 << d), {
                    minFilter: THREE.NearestFilter,
                    magFilter: THREE.NearestFilter,
                    format: THREE.RGBAFormat,
                    depthBuffer: !1,
                    stencilBuffer: !1
                });
                r.push(e);
                f.uniforms["tDepth_mip" + (d + 1)].value = e
            }
            p = new THREE.WebGLRenderTarget(b, c, {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                stencilBuffer: !1,
                depthBuffer: !1
            });
            u = p.clone()
        }
        f && (f.uniforms.size.value.set(b, c), f.uniforms.tDepth.value = n, g.uniforms.size.value.set(b, c), g.uniforms.resolution.value.set(1 / b, 1 / c));
        l && l.uniforms.resolution.value.set(1 / b, 1 / c);
        m.uniforms.tOverlay.value = t;
        m.uniforms.tAO.value = p;
        m.uniforms.useAO.value = x.sao ? 1 : 0;
        m.uniforms.resolution.value.set(1 / b, 1 / c)
    };
    this.getMaxAnisotropy = function () {
        return a.getMaxAnisotropy()
    };
    this.hasMRT = function () {
        return a.supportsMRT()
    };
    this.initPostPipeline = function (e, p) {
        function r(a) {
            a.blending = THREE.NoBlending;
            a.depthWrite = !1;
            a.depthTest = !1
        }
        x.sao = e && !_isIE11;
        x.antialias = p && !_isIE11;
        if (!a) {
            var t = window.devicePixelRatio;
            t || (t = 1);
            a = new FireflyWebGLRenderer({
                canvas: b,
                antialias: !1,
                alpha: !1,
                premultipliedAlpha: !1,
                preserveDrawingBuffer: !1,
                stencil: !1,
                depth: !1,
                devicePixelRatio: t
            });
            a.autoClear = !1;
            a.sortObjects = !1
        }
        x.sao && !f && (t = NormalsShader, c = new THREE.ShaderMaterial({
                fragmentShader: t.fragmentShader,
                vertexShader: t.vertexShader,
                uniforms: THREE.UniformsUtils.clone(t.uniforms)
            }), c.blending = THREE.NoBlending, x.haveTwoSided &&
            (c.side = THREE.DoubleSide), f = new THREE.ShaderPass(SAOShader), r(f.material), g = new THREE.ShaderPass(SAOBlurShader), r(g.material), h = new THREE.ShaderPass(SAOMinifyFirstShader), r(h.material), k = new THREE.ShaderPass(SAOMinifyShader), r(k.material));
        x.antialias ? l || (l = new THREE.ShaderPass(FXAAShader), r(l.material)) : l = null;
        m || (m = new THREE.ShaderPass(BlendShader), r(m.material));
        d || (d = new THREE.ShaderPass(BackgroundShader), r(d.material));
        this.setSize(v, w);
        a.supportsMRT() && x.sao && a.verifyMRTWorks([s, n])
    };
    this.setClearColors =
        function (a, b) {
            d.uniforms.color2.value.copy(a);
            b ? d.uniforms.color1.value.copy(b) : d.uniforms.color1.value.set(0, 0, 0, 1)
    };
    this.setAOOptions = function (a, b) {
        f && (f.uniforms.radius.value = 0.1 * a, f.uniforms.intensity.value = 0.01 * b)
    };
    this.setGamma = function (a) {
        m && (m.uniforms.gamma.value = 1 / a)
    };
    this.setExposureBias = function (a) {
        m && (m.uniforms.exposureBias.value = Math.pow(2, a))
    };
    this.setWhiteScale = function (a) {
        m && (m.uniforms.whiteScale.value = a)
    };
    this.setTonemapMethod = function (b) {
        m && (0 == b ? (x.useHdrTarget && (x.useHdrTarget = !1, this.setSize(v, w, !0)), a.gammaInput = !1) : (x.useHdrTarget || (x.useHdrTarget = !0, this.setSize(v, w, !0)), a.gammaInput = !0), m.uniforms.toneMapMethod.value = b)
    };
    this.toggleTwoSided = function (a) {
        x.haveTwoSided != a && c && (c.side = a ? THREE.DoubleSide : THREE.FrontSide, c.needsUpdate = !0);
        x.haveTwoSided = a
    }
};
FXAAShader = {
    uniforms: {
        tDiffuse: {
            type: "t",
            value: null
        },
        resolution: {
            type: "v2",
            value: new THREE.Vector2(1 / 1024, 1 / 512)
        }
    },
    vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
    fragmentShader: "uniform sampler2D tDiffuse;\nuniform vec2 resolution;\nvarying vec2 vUv;\n#define FXAA_SPAN_MAX     8.0\n#define FXAA_EDGE_THRESHOLD_MIN (1.0/24.0)\n#define FXAA_EDGE_THRESHOLD (1.0/8.0)\n#define FXAA_SEARCH_THRESHOLD (1.0/4.0)\n#define FXAA_SEARCH_STEPS 24\n#define FXAA_SUBPIX_TRIM (1.0/4.0)\n#define FXAA_SUBPIX_TRIM_SCALE (1.0/(1.0 - FXAA_SUBPIX_TRIM))\n#define FXAA_SUBPIX_CAP (3.0/4.0)\nvec4 getColor(sampler2D tex, vec2 uv) {\nvec4 c = texture2D(tex, uv);\nreturn c;\n}\nfloat FxaaLuma(vec3 rgb) {\nreturn rgb.y * (0.587/0.299) + rgb.x; }\nvec4 FxaaFilterReturn(vec4 rgba) {\nreturn rgba;}\nvec3 FxaaLerp3(vec3 a, vec3 b, float amountOfA) {\nreturn (vec3(-amountOfA) * b) +\n((a * vec3(amountOfA)) + b); }\nvec4 FxaaTex(sampler2D tex, vec2 pos) {\nreturn getColor(tex, pos.xy);}\nvec4 FxaaTexOff(sampler2D tex, vec2 pos, vec2 offset, vec2 resolution) {\nvec2 uv = pos.xy + offset * resolution;\nreturn getColor(tex, uv);}\nvoid main() {\nvec3 rgbN = FxaaTexOff( tDiffuse, vUv, vec2(0.0,-1.0), resolution ).xyz;\nvec3 rgbE = FxaaTexOff( tDiffuse, vUv, vec2(1.0, 0.0), resolution ).xyz;\nvec3 rgbW = FxaaTexOff( tDiffuse, vUv, vec2(-1.0,0.0), resolution ).xyz;\nvec3 rgbS = FxaaTexOff( tDiffuse, vUv, vec2(0.0, 1.0), resolution ).xyz;\nvec4 rgbaM = FxaaTex( tDiffuse, vUv);\nvec3 rgbM  = rgbaM.xyz;\nfloat lumaN = FxaaLuma(rgbN);\nfloat lumaE = FxaaLuma(rgbE);\nfloat lumaW = FxaaLuma(rgbW);\nfloat lumaS = FxaaLuma(rgbS);\nfloat lumaM = FxaaLuma(rgbM);\nfloat rangeMin = min(lumaM, min(min(lumaN, lumaW), min(lumaS, lumaE)));\nfloat rangeMax = max(lumaM, max(max(lumaN, lumaW), max(lumaS, lumaE)));\nfloat range = rangeMax - rangeMin;\nif(range < max(FXAA_EDGE_THRESHOLD_MIN, rangeMax * FXAA_EDGE_THRESHOLD)) {\ngl_FragColor = FxaaFilterReturn(rgbaM); return;}\nvec3 rgbL = rgbN + rgbW + rgbM + rgbE + rgbS;\nfloat lumaL = (lumaN + lumaW + lumaE + lumaS) * 0.25;\nfloat rangeL = abs(lumaL - lumaM);\nfloat blendL = max(0.0, (rangeL / range) - FXAA_SUBPIX_TRIM) * FXAA_SUBPIX_TRIM_SCALE;\nblendL = min(FXAA_SUBPIX_CAP, blendL);\nvec3 rgbNW = FxaaTexOff( tDiffuse, vUv, vec2(-1.0,-1.0), resolution ).xyz;\nvec3 rgbNE = FxaaTexOff( tDiffuse, vUv, vec2(1.0,-1.0), resolution ).xyz;\nvec3 rgbSW = FxaaTexOff( tDiffuse, vUv, vec2(-1.0,1.0), resolution ).xyz;\nvec3 rgbSE = FxaaTexOff( tDiffuse, vUv, vec2(1.0,1.0), resolution ).xyz;\nfloat opacity  = rgbaM.w;\nrgbL += (rgbNW + rgbNE + rgbSW + rgbSE);\nrgbL *= vec3(1.0/9.0);\nfloat lumaNW = FxaaLuma( rgbNW);\nfloat lumaNE = FxaaLuma( rgbNE);\nfloat lumaSW = FxaaLuma( rgbSW);\nfloat lumaSE = FxaaLuma( rgbSE);\nfloat edgeVert = abs((0.25 * lumaNW) + (-0.5 * lumaN) + (0.25 * lumaNE)) +\nabs((0.50 * lumaW ) + (-1.0 * lumaM) + (0.50 * lumaE )) +\nabs((0.25 * lumaSW) + (-0.5 * lumaS) + (0.25 * lumaSE));\nfloat edgeHorz = abs((0.25 * lumaNW) + (-0.5 * lumaW) + (0.25 * lumaSW)) +\nabs((0.50 * lumaN ) + (-1.0 * lumaM) + (0.50 * lumaS )) +\nabs((0.25 * lumaNE) + (-0.5 * lumaE) + (0.25 * lumaSE));\nbool horzSpan = edgeHorz >= edgeVert;\nfloat lengthSign = horzSpan ? -resolution.y : -resolution.x;\nif(!horzSpan) lumaN = lumaW;\nif(!horzSpan) lumaS = lumaE;\nfloat gradientN = abs(lumaN - lumaM);\nfloat gradientS = abs(lumaS - lumaM);\nlumaN = (lumaN + lumaM) * 0.5;\nlumaS = (lumaS + lumaM) * 0.5;\nbool pairN = gradientN >= gradientS;\nif(!pairN) lumaN = lumaS;\nif(!pairN) gradientN = gradientS;\nif(!pairN) lengthSign *= -1.0;\nvec2 posN;\nposN.x = vUv.x + (horzSpan ? 0.0 : lengthSign * 0.5);\nposN.y = vUv.y + (horzSpan ? lengthSign * 0.5 : 0.0);\ngradientN *= FXAA_SEARCH_THRESHOLD;\nvec2 posP = posN;\nvec2 offNP = horzSpan ? vec2(resolution.x, 0.0) : vec2(0.0, resolution.y);\nfloat lumaEndN = lumaN;\nfloat lumaEndP = lumaN;\nbool doneN = false;\nbool doneP = false;\nposN += offNP * vec2(-1.0, -1.0);\nposP += offNP * vec2( 1.0,  1.0);\nfor(int i = 0; i < FXAA_SEARCH_STEPS; i++) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTex( tDiffuse, posN.xy).xyz);\nif(!doneP) lumaEndP = FxaaLuma(FxaaTex( tDiffuse, posP.xy).xyz);\ndoneN = doneN || (abs(lumaEndN - lumaN) >= gradientN);\ndoneP = doneP || (abs(lumaEndP - lumaN) >= gradientN);\nif(doneN && doneP) break;\nif(!doneN) posN -= offNP;\nif(!doneP) posP += offNP; }\nfloat dstN = horzSpan ? vUv.x - posN.x : vUv.y - posN.y;\nfloat dstP = horzSpan ? posP.x - vUv.x : posP.y - vUv.y;\nbool directionN = dstN < dstP;\nlumaEndN = directionN ? lumaEndN : lumaEndP;\nif(((lumaM - lumaN) < 0.0) == ((lumaEndN - lumaN) < 0.0))\nlengthSign = 0.0;\nfloat spanLength = (dstP + dstN);\ndstN = directionN ? dstN : dstP;\nfloat subPixelOffset = (0.5 + (dstN * (-1.0/spanLength))) * lengthSign;\nvec3 rgbF = FxaaTex(tDiffuse, vec2(\nvUv.x + (horzSpan ? 0.0 : subPixelOffset),\nvUv.y + (horzSpan ? subPixelOffset : 0.0))).xyz;\ngl_FragColor = FxaaFilterReturn(vec4(FxaaLerp3(rgbL, rgbF, blendL), opacity));\n}"
};
BlendShader = {
    uniforms: {
        tDiffuse: {
            type: "t",
            value: null
        },
        tAO: {
            type: "t",
            value: null
        },
        useAO: {
            type: "i",
            value: 0
        },
        tOverlay: {
            type: "t",
            value: null
        },
        useOverlay: {
            type: "i",
            value: 0
        },
        resolution: {
            type: "v2",
            value: new THREE.Vector2(1 / 1024, 1 / 512)
        },
        gamma: {
            type: "f",
            value: 1
        },
        whiteScale: {
            type: "f",
            value: 1
        },
        exposureBias: {
            type: "f",
            value: 1
        },
        toneMapMethod: {
            type: "i",
            value: 0
        }
    },
    vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
    fragmentShader: "uniform sampler2D tDiffuse;\nuniform sampler2D tAO;\nuniform int useAO;\nuniform sampler2D tOverlay;\nuniform int useOverlay;\nuniform vec2 resolution;\nuniform float whiteScale;\nuniform float gamma;\nuniform float exposureBias;\nuniform int toneMapMethod;\nvarying vec2 vUv;\nfloat exposure = log(1.0 - 0.6) / (whiteScale * 0.5);\nvec4 fetchOverlayTexel(vec2 uv, vec2 offset) {\nreturn texture2D(tOverlay, uv + resolution * offset);\n}\nfloat luminance_post(vec3 rgb) {\nreturn dot(rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat luminance_pre(vec3 rgb) {\nreturn dot(rgb, vec3(0.212671, 0.715160, 0.072169));\n}\nvec3 xyz2rgb(vec3 xyz) {\nvec3 R = vec3( 3.240479, -1.537150, -0.498535);\nvec3 G = vec3(-0.969256,  1.875992,  0.041556);\nvec3 B = vec3( 0.055648, -0.204043,  1.057311);\nvec3 rgb;\nrgb.b = dot(xyz, B);\nrgb.g = dot(xyz, G);\nrgb.r = dot(xyz, R);\nreturn rgb;\n}\nvec3 rgb2xyz(vec3 rgb) {\nvec3 X = vec3(0.412453, 0.35758, 0.180423);\nvec3 Y = vec3(0.212671, 0.71516, 0.0721688);\nvec3 Z = vec3(0.0193338, 0.119194, 0.950227);\nvec3 xyz;\nxyz.x = dot(rgb, X);\nxyz.y = dot(rgb, Y);\nxyz.z = dot(rgb, Z);\nreturn xyz;\n}\nvec3 xyz2xyY(vec3 xyz) {\nfloat sum = xyz.x + xyz.y + xyz.z;\nsum = 1.0 / sum;\nvec3 xyY;\nxyY.z = xyz.y;\nxyY.x = xyz.x * sum;\nxyY.y = xyz.y * sum;\nreturn xyY;\n}\nvec3 xyY2xyz(vec3 xyY) {\nfloat x = xyY.x;\nfloat y = xyY.y;\nfloat Y = xyY.z;\nvec3 xyz;\nxyz.y = Y;\nxyz.x = x * (Y / y);\nxyz.z = (1.0 - x - y) * (Y / y);\nreturn xyz;\n}\nvec3 toneMapUncharted2(vec3 x)\n{\nfloat A = 0.22;\nfloat B = 0.30;\nfloat C = 0.10;\nfloat D = 0.20;\nfloat E = 0.01;\nfloat F = 0.30;\nreturn ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\nvec3 toneMapReinhard(vec3 rgb, float scale, float Lmax) {\nfloat L = luminance_pre(rgb);\nfloat sL = L * scale;\nfloat tmL = scale * (1.0 + sL / (Lmax * Lmax))/ (1.0 + sL);\nrgb *= tmL;\nreturn rgb;\n}\nvec3 toneMapReinhardYxy(vec3 rgb, float scale, float Lmax) {\nvec3 xyY = xyz2xyY(rgb2xyz(rgb));\nfloat L = xyY.z;\nfloat sL = L * scale;\nfloat tmL = scale * (1.0 + sL / (Lmax * Lmax))/ (1.0 + sL);\nxyY.z *= tmL;\nreturn xyz2rgb(xyY2xyz(xyY));\n}\nvec3 toneMapExpRgb(vec3 rgb) {\nrgb = vec3(1.0) - vec3(exp(rgb * vec3(exposure)));\nreturn rgb;\n}\nfloat TonemapMin = -2.152529302052785809;\nfloat TonemapMax = 1.163792197947214113;\nvec3 log10(vec3 x) { return log(x) * (1.0 / log(10.0));}\nfloat toneMapCanon(float x) {\nfloat x2 = x  * x;\nfloat x3 = x  * x2;\nfloat x4 = x2 * x2;\nfloat x5 = x2 * x3;\nfloat x6 = x3 * x3;\nvec3 coeff1 = vec3( 23.921, -70.678,  71.943);\nvec4 coeff2 = vec4(-29.707,  5.9189, -0.4027, 0.0071);\nreturn dot(coeff1, vec3(x6, x5, x4)) + dot(coeff2, vec4(x3, x2, x, 1.0));\n}\nvec4 overlayEdgeDetect(vec2 vUv) {\nint has_zero = 0;\nvec4 center;\nvec4 non_zero_pixel;\nfloat max_alpha = 0.0;\nfor (int j=-1; j<=1; j++) {\nfor (int i=-1; i<=1; i++) {\nvec4 c = fetchOverlayTexel(vUv, vec2(i, j));\nmax_alpha = max(max_alpha, c.a);\nif (i==0 && j==0)\ncenter = c;\nif (c.a == 0.0)\nhas_zero++;\nelse\nnon_zero_pixel = c;\n}\n}\nif (has_zero != 0 && has_zero != 9)\n{\nif (center == vec4(0.0))\ncenter = non_zero_pixel;\nfloat maxComponent = max(center.r, max(center.g, center.b));\ncenter.rgb /= maxComponent;\ncenter.rgb = sqrt(center.rgb);\ncenter.a = 0.5 + 0.5 * max_alpha * 0.125 * float(has_zero);\n}\nif (has_zero == 0) {\ncenter.a = -center.a;\n}\nreturn center;\n}\nvoid main() {\nvec4 texel = texture2D( tDiffuse, vUv );\nfloat ao = (useAO != 0) ? texture2D(tAO, vUv).r : 1.0;\ntexel.rgb *= ao;\nif (toneMapMethod == 1) {\ntexel.rgb *= exposureBias / whiteScale;\n} else if (toneMapMethod == 2) {\ntexel.rgb = toneMapReinhard(texel.rgb, exposureBias, whiteScale);\n} else if (toneMapMethod == 3) {\ntexel.rgb = toneMapUncharted2(texel.rgb * exposureBias);\ntexel.rgb *= 1.0 / toneMapUncharted2(vec3(whiteScale));\n} else if (toneMapMethod == 4) {\ntexel.rgb = toneMapExpRgb(texel.rgb * exposureBias);\n} else if (toneMapMethod == 5) {\nvec3 indexColor = log10(max(vec3(0.000000001), texel.rgb * exposureBias));\nindexColor = min(vec3(1.0), max(vec3(0.0), (indexColor.rgb - TonemapMin) / (TonemapMax - TonemapMin)));\ntexel.rgb = vec3(toneMapCanon(indexColor.r), toneMapCanon(indexColor.g), toneMapCanon(indexColor.b));\ntexel.rgb = pow(texel.rgb, vec3(2.2));\n}\ntexel.rgb = pow(texel.rgb, vec3(gamma));\nif (useOverlay!=0) {\nvec4 overlay = overlayEdgeDetect(vUv);\nif (overlay.a < 0.0) {\noverlay.a = -overlay.a;\nif (overlay.a >= 0.99) {\noverlay.a = 0.75;\ntexel.rgb = vec3(luminance_post(texel.rgb));\n}\n}\ntexel.rgb = mix(texel.rgb, overlay.rgb, overlay.a);\n}\ngl_FragColor = texel;\n}"
};
THREE.ShaderPass = function (a, b) {
    this.textureID = void 0 !== b ? b : "tDiffuse";
    this.uniforms = THREE.UniformsUtils.clone(a.uniforms);
    this.material = new THREE.ShaderMaterial({
        uniforms: this.uniforms,
        vertexShader: a.vertexShader,
        fragmentShader: a.fragmentShader
    });
    this.renderToScreen = !1;
    this.needsSwap = this.enabled = !0;
    this.clear = !1;
    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    var c = new THREE.BufferGeometry,
        e = new Float32Array(9);
    e[0] = -1;
    e[1] = -1;
    e[2] = 0;
    e[3] = 3;
    e[4] = -1;
    e[5] = 0;
    e[6] = -1;
    e[7] = 3;
    e[8] = 0;
    var d = new Float32Array(6);
    d[0] = 0;
    d[1] = 0;
    d[2] = 2;
    d[3] = 0;
    d[4] = 0;
    d[5] = 2;
    c.attributes.position = {
        itemSize: 3,
        array: e
    };
    c.attributes.uv = {
        itemSize: 2,
        array: d
    };
    this.quad = new THREE.Mesh(c, this.material);
    this.scene = new THREE.Scene;
    this.scene.add(this.quad)
};
THREE.ShaderPass.prototype = {
    render: function (a, b, c, e) {
        this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = c);
        this.renderToScreen || !b ? a.render(this.scene, this.camera) : a.render(this.scene, this.camera, b, this.clear)
    }
};
SAOShader = {
    uniforms: {
        tDepth: {
            type: "t",
            value: null
        },
        size: {
            type: "v2",
            value: new THREE.Vector2(512, 512)
        },
        cameraNear: {
            type: "f",
            value: 1
        },
        cameraFar: {
            type: "f",
            value: 100
        },
        radius: {
            type: "f",
            value: 10
        },
        bias: {
            type: "f",
            value: 0.01
        },
        projScale: {
            type: "f",
            value: 500
        },
        projInfo: {
            type: "v4",
            value: new THREE.Vector4(0, 0, 0, 0)
        },
        intensity: {
            type: "f",
            value: 0.75
        },
        tDepth_mip1: {
            type: "t",
            value: null
        },
        tDepth_mip2: {
            type: "t",
            value: null
        },
        tDepth_mip3: {
            type: "t",
            value: null
        },
        tDepth_mip4: {
            type: "t",
            value: null
        },
        tDepth_mip5: {
            type: "t",
            value: null
        }
    },
    vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
    fragmentShader: "#extension GL_OES_standard_derivatives : enable\n#define USE_MIPMAP 1\nuniform float cameraNear;\nuniform float cameraFar;\nuniform vec2 size;\nuniform float lumInfluence;\nvarying vec2 vUv;\n#define NUM_SAMPLES (17)\n#define LOG_MAX_OFFSET (3)\n#define MAX_MIP_LEVEL (5)\n#define NUM_SPIRAL_TURNS (7)\nuniform float           projScale;\nuniform sampler2D tDepth;\n#ifdef USE_MIPMAP\nuniform sampler2D tDepth_mip1;\nuniform sampler2D tDepth_mip2;\nuniform sampler2D tDepth_mip3;\nuniform sampler2D tDepth_mip4;\nuniform sampler2D tDepth_mip5;\n#endif\nuniform float radius;\nuniform float bias;\nuniform float intensity;\nfloat intensityDivR6 = intensity / pow(radius, 6.0);\nvec2 tapLocation(int sampleNumber, float spinAngle, out float ssR){\nfloat alpha = float(float(sampleNumber) + 0.5) * (1.0 / float(NUM_SAMPLES));\nfloat angle = alpha * (float(NUM_SPIRAL_TURNS) * 6.28) + spinAngle;\nssR = alpha;\nreturn vec2(cos(angle), sin(angle));\n}\nfloat CSZToKey(float z) {\nreturn clamp(z * (1.0 / -cameraFar), 0.0, 1.0);\n}\nvoid packKey(float key, out vec2 p) {\nfloat temp = floor(key * 256.0);\np.x = temp * (1.0 / 256.0);\np.y = key * 256.0 - temp;\n}\nfloat unpackDepth( const in vec4 rgba_depth ) {\nfloat depth = dot( rgba_depth, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\nif (depth == 0.0)\nreturn -cameraFar * 1.0e10;\nreturn depth * (cameraNear - cameraFar) - cameraNear;\n}\nuniform vec4 projInfo;\nvec3 reconstructCSPosition(vec2 S, float z) {\nreturn vec3((S.xy * projInfo.xy + projInfo.zw) * z, z);\n}\nvec3 reconstructCSFaceNormal(vec3 C) {\nreturn normalize(cross(dFdy(C), dFdx(C)));\n}\nvec3 reconstructNonUnitCSFaceNormal(vec3 C) {\nreturn cross(dFdy(C), dFdx(C));\n}\nvec2 sizeM1 = vec2(1.0/(size.x), 1.0/(size.y));\nvec3 getPosition(ivec2 ssP, float depth) {\nvec3 P;\nP = reconstructCSPosition(vec2(ssP) + vec2(0.5), depth);\nreturn P;\n}\nvec3 getOffsetPosition(ivec2 ssC, vec2 unitOffset, float ssR) {\nivec2 ssP = ivec2(ssR * unitOffset) + ssC;\nvec3 P;\nvec2 screenUV = (vec2(ssP) + vec2(0.5)) * sizeM1;\n#ifdef USE_MIPMAP\nint mipLevel = int(max(0.0, min(floor(log2(ssR)) - float(LOG_MAX_OFFSET), float(MAX_MIP_LEVEL))));\nif (mipLevel == 0) {\nP.z = texture2D(tDepth, screenUV).z;\nif (P.z == 0.0) P.z = -cameraFar * 1.0e10;\n}\nelse if (mipLevel == 1)\nP.z = unpackDepth(texture2D(tDepth_mip1, screenUV));\nelse if (mipLevel == 2)\nP.z = unpackDepth(texture2D(tDepth_mip2, screenUV));\nelse if (mipLevel == 3)\nP.z = unpackDepth(texture2D(tDepth_mip3, screenUV));\nelse if (mipLevel == 4)\nP.z = unpackDepth(texture2D(tDepth_mip4, screenUV));\nelse if (mipLevel == 5)\nP.z = unpackDepth(texture2D(tDepth_mip5, screenUV));\n#else\nP.z = texture2D(tDepth, screenUV).z;\nif (P.z == 0.0) P.z = -cameraFar * 1.0e10;\n#endif\nP = reconstructCSPosition(vec2(ssP) + vec2(0.5), P.z);\nreturn P;\n}\nfloat radius2 = radius * radius;\nfloat invRadius2 = 1.0 / radius2;\nfloat sampleAO(in ivec2 ssC, in vec3 C, in vec3 n_C, in float ssDiskRadius, in int tapIndex, in float randomPatternRotationAngle) {\nfloat ssR;\nvec2 unitOffset = tapLocation(tapIndex, randomPatternRotationAngle, ssR);\nssR *= ssDiskRadius;\nvec3 Q = getOffsetPosition(ssC, unitOffset, ssR);\nvec3 v = Q - C;\nfloat vv = dot(v, v);\nfloat vn = dot(v, n_C);\nconst float epsilon = 0.01;\nfloat f = max(radius2 - vv, 0.0); return f * f * f * max((vn - bias) / (epsilon + vv), 0.0);\n}\nconst bool useNoise = true;\nvec2 rand( const vec2 coord ) {\nvec2 noise;\nif ( useNoise ) {\nfloat nx = dot ( coord, vec2( 12.9898, 78.233 ) );\nfloat ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );\nnoise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );\n} else {\nfloat ff = fract( 1.0 - coord.s * ( size.x / 2.0 ) );\nfloat gg = fract( coord.t * ( size.y / 2.0 ) );\nnoise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;\n}\nreturn ( noise * 2.0  - 1.0 );\n}\nfloat getRandomAngle(vec2 pos) {\nvec2 rnd = rand(pos);\nreturn atan(rnd.y, rnd.x);\n}\nvoid main() {\nivec2 ssC = ivec2(gl_FragCoord.xy);\nvec4 nrmz = texture2D(tDepth, vUv);\nif (nrmz.z == 0.0) {\ngl_FragColor.r = 1.0;\ngl_FragColor.a = 0.0;\npackKey(1.0, gl_FragColor.gb);\nreturn;\n}\nvec3 C = getPosition(ssC, nrmz.z);\npackKey(CSZToKey(C.z), gl_FragColor.gb);\nfloat randomPatternRotationAngle = getRandomAngle(vUv);\nvec3 n_C = vec3(nrmz.x, nrmz.y, sqrt(1.0 - dot(nrmz.xy, nrmz.xy)));\nfloat ssDiskRadius = -projScale * radius / C.z;\nfloat sum = 0.0;\nfor (int i = 0; i < NUM_SAMPLES; ++i) {\nsum += sampleAO(ssC, C, n_C, ssDiskRadius, i, randomPatternRotationAngle);\n}\nfloat A = max(0.0, 1.0 - sum * intensityDivR6 * (5.0 / float(NUM_SAMPLES)));\nif (abs(dFdx(C.z)) < 0.02) {\nA -= dFdx(A) * (mod(float(ssC.x), 2.0) - 0.5);\n}\nif (abs(dFdy(C.z)) < 0.02) {\nA -= dFdy(A) * (mod(float(ssC.y), 2.0) - 0.5);\n}\ngl_FragColor.r = A;\ngl_FragColor.a = 1.0;\n}"
};
SAOBlurShader = {
    uniforms: {
        tDiffuse: {
            type: "t",
            value: null
        },
        size: {
            type: "v2",
            value: new THREE.Vector2(512, 512)
        },
        resolution: {
            type: "v2",
            value: new THREE.Vector2(1 / 512, 1 / 512)
        },
        axis: {
            type: "v2",
            value: new THREE.Vector2(1, 0)
        }
    },
    vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
    fragmentShader: "#define EDGE_SHARPNESS     (1.0)\n#define SCALE               (2)\n#define R                   (4)\n#define VALUE_TYPE        float\n#define VALUE_COMPONENTS   r\n#define VALUE_IS_KEY       0\n#define KEY_COMPONENTS     gb\n#if __VERSION__ >= 330\nconst float gaussian[R + 1] =\nfloat[](0.153170, 0.144893, 0.122649, 0.092902, 0.062970);  // stddev = 2.0\n#endif\nuniform sampler2D   tDiffuse;\nuniform vec2 size;\nuniform vec2 resolution;\nuniform vec2       axis;\nivec2 axisi = ivec2(axis);\n#define  result         gl_FragColor.VALUE_COMPONENTS\n#define  keyPassThrough gl_FragColor.KEY_COMPONENTS\nfloat unpackKey(vec2 p) {\nreturn p.x * (256.0 / 257.0) + p.y * (1.0 / 257.0);\n}\nvarying vec2 vUv;\nvoid main() {\n#   if __VERSION__ < 330\nfloat gaussian[R + 1];\n#       if R == 3\ngaussian[0] = 0.153170; gaussian[1] = 0.144893; gaussian[2] = 0.122649; gaussian[3] = 0.092902;  // stddev = 2.0\n#       elif R == 4\ngaussian[0] = 0.153170; gaussian[1] = 0.144893; gaussian[2] = 0.122649; gaussian[3] = 0.092902; gaussian[4] = 0.062970;  // stddev = 2.0\n#       elif R == 6\ngaussian[0] = 0.111220; gaussian[1] = 0.107798; gaussian[2] = 0.098151; gaussian[3] = 0.083953; gaussian[4] = 0.067458; gaussian[5] = 0.050920; gaussian[6] = 0.036108;\n#       endif\n#   endif\nivec2 ssC = ivec2(gl_FragCoord.xy);\nvec4 temp = texture2D(tDiffuse, vUv);\ngl_FragColor.gb = temp.KEY_COMPONENTS;\ngl_FragColor.a = temp.a;\nVALUE_TYPE sum = temp.VALUE_COMPONENTS;\nif (temp.a == 0.0) {\nresult = sum;\nreturn;\n}\nfloat key = unpackKey(keyPassThrough);\nfloat BASE = gaussian[0];\nfloat totalWeight = BASE;\nsum *= totalWeight;\nfor (int r = -R; r <= R; ++r) {\nif (r != 0) {\nvec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;\ntemp = texture2D(tDiffuse, ssUV);\nfloat      tapKey = unpackKey(temp.KEY_COMPONENTS);\nVALUE_TYPE value  = temp.VALUE_COMPONENTS;\nfloat weight = 0.3 + gaussian[r<0?-r:r];\nfloat dz = tapKey - key;\nweight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));\nsum += value * weight;\ntotalWeight += weight;\n}\n}\nconst float epsilon = 0.0001;\nresult = sum / (totalWeight + epsilon);\n}"
};
SAOMinifyFirstShader = {
    uniforms: {
        tDiffuse: {
            type: "t",
            value: null
        },
        cameraNear: {
            type: "f",
            value: 1
        },
        cameraInvNearFar: {
            type: "f",
            value: 100
        },
        resolution: {
            type: "v2",
            value: new THREE.Vector2(1 / 512, 1 / 512)
        }
    },
    vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
    fragmentShader: "uniform sampler2D tDiffuse;\nuniform vec2 resolution;\nuniform float cameraNear;\nuniform float cameraInvNearFar;\nvarying vec2 vUv;\nvec4 packDepth( const in float depth ) {\nvec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\nenc = fract(enc);\nenc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\nreturn enc;\n}\nvoid main() {\nvec2 ssP = vec2(gl_FragCoord.xy);\nssP = ssP * 2.0 + mod(ssP, 2.0);\nssP = (ssP + 0.5) * resolution * 0.5;\nfloat depth = texture2D(tDiffuse, ssP).z;\nif (depth != 0.0)\ndepth = (depth + cameraNear) * cameraInvNearFar;\ngl_FragColor = packDepth(depth);\n}"
};
SAOMinifyShader = {
    uniforms: {
        tDiffuse: {
            type: "t",
            value: null
        },
        resolution: {
            type: "v2",
            value: new THREE.Vector2(1 / 512, 1 / 512)
        }
    },
    vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
    fragmentShader: "uniform sampler2D tDiffuse;\nuniform vec2 resolution;\nvarying vec2 vUv;\nvoid main() {\nvec2 ssP = vec2(gl_FragCoord.xy);\nssP = ssP * 2.0 + mod(ssP, 2.0);\nssP = (ssP + 0.5) * resolution * 0.5;\ngl_FragColor = texture2D(tDiffuse, ssP);\n}"
};
NormalsShader = {
    uniforms: {},
    vertexShader: "varying vec3 vNormal;\nvarying float depth;\nvoid main() {\nvNormal = normalize( normalMatrix * normal );\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\ndepth = mvPosition.z;\nvec4 p_Position = projectionMatrix * mvPosition;\ngl_Position = p_Position;\n}",
    fragmentShader: "varying vec3 vNormal;\nvarying float depth;\nvoid main() {\nvec3 n = vNormal;\nn = n * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\nn = normalize( n );\ngl_FragColor = vec4(n.x, n.y, depth, 1.0);\n}"
};
BackgroundShader = {
    uniforms: {
        color1: {
            type: "v4",
            value: new THREE.Vector4(1 / 255, 2 / 255, 3 / 255, 1)
        },
        color2: {
            type: "v4",
            value: new THREE.Vector4(41 / 255, 76 / 255, 120 / 255, 1)
        }
    },
    vertexShader: "uniform vec4 color1;\nuniform vec4 color2;\nvarying vec4 vcolor;\nvoid main() {\nif (uv.y == 0.0)\nvcolor = color1;\nelse\nvcolor = color2;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
    fragmentShader: "const vec4 c0 = vec4(1.0, 13.0, 4.0, 16.0);\nconst vec4 c1 = vec4(9.0, 5.0, 12.0, 8.0);\nconst vec4 c2 = vec4(3.0, 15.0, 2.0, 14.0);\nconst vec4 c3 = vec4(11.0, 7.0, 10.0, 6.0);\nvarying vec4 vcolor;\nvoid main() {\nvec4 c = vcolor;\nint i = int(mod(float(gl_FragCoord.x), 4.0));\nint j = int(mod(float(gl_FragCoord.y), 4.0));\nvec4 col;\nif (i==0) col = c0; else if (i==1) col = c1; else if (i==2) col = c2; else col = c3;\nfloat bias;\nif (j==0) bias = col.x; else if (j==1) bias = col.y; else if (j==2) bias = col.z; else bias = col.w;\nc.xyz += bias * (1.0/(17.0*256.0));\ngl_FragColor = c;\n}"
};
FireflyWebGLRenderer = function (a) {
    function b(a, b) {
        var f = b.geometry,
            g = a.faces3,
            k = 3 * g.length,
            h = 1 * g.length,
            l = 3 * g.length,
            g = c(b, a),
            m = d(g),
            n = e(g),
            p = g.vertexColors ? g.vertexColors : !1;
        a.__vertexArray = new Float32Array(3 * k);
        n && (a.__normalArray = new Float32Array(3 * k));
        f.hasTangents && (a.__tangentArray = new Float32Array(4 * k));
        p && (a.__colorArray = new Float32Array(3 * k));
        m && (0 < f.faceVertexUvs.length && (a.__uvArray = new Float32Array(2 * k)), 1 < f.faceVertexUvs.length && (a.__uv2Array = new Float32Array(2 * k)));
        b.geometry.skinWeights.length &&
            b.geometry.skinIndices.length && (a.__skinIndexArray = new Float32Array(4 * k), a.__skinWeightArray = new Float32Array(4 * k));
        a.__faceArray = new Uint16Array(3 * h);
        a.__lineArray = new Uint16Array(2 * l);
        a.__webglFaceCount = 3 * h;
        a.__webglLineCount = 2 * l;
        if (g.attributes) {
            void 0 === a.__webglCustomAttributesList && (a.__webglCustomAttributesList = []);
            for (var r in g.attributes) {
                var f = g.attributes[r],
                    h = {},
                    s;
                for (s in f) h[s] = f[s];
                if (!h.__webglInitialized || h.createUniqueBuffers) h.__webglInitialized = !0, l = 1, "v2" === h.type ? l = 2 : "v3" ===
                    h.type ? l = 3 : "v4" === h.type ? l = 4 : "c" === h.type && (l = 3), h.size = l, h.array = new Float32Array(k * l), h.buffer = q.createBuffer(), h.buffer.belongsToAttribute = r, f.needsUpdate = !0, h.__original = f;
                a.__webglCustomAttributesList.push(h)
            }
        }
        a.__inittedArrays = !0
    }

    function c(a, b) {
        return a.material instanceof THREE.MeshFaceMaterial ? a.material.materials[b.materialIndex] : a.material
    }

    function e(a) {
        return a instanceof THREE.MeshBasicMaterial && !a.envMap || a instanceof THREE.MeshDepthMaterial ? !1 : a && void 0 !== a.shading && a.shading === THREE.SmoothShading ?
            THREE.SmoothShading : THREE.FlatShading
    }

    function d(a) {
        return a.map || a.lightMap || a.bumpMap || a.normalMap || a.specularMap || a instanceof THREE.ShaderMaterial ? !0 : !1
    }

    function g(a, b, c, d) {
        var e, f, g, h, l = !1;
        if (c.vb) {
            c.streamingDraw ? (g = za.interleavedVB, g || (g = q.createBuffer(), za.interleavedVB = g), q.bindBuffer(q.ARRAY_BUFFER, g), q.bufferData(q.ARRAY_BUFFER, c.vb, q.STATIC_DRAW)) : q.bindBuffer(q.ARRAY_BUFFER, c.vbbuffer);
            var m = c.vbstride;
            for (h in b) "index" != h && (f = b[h], e = c.attributes[h], 0 <= f && e && (void 0 !== e.itemOffset ? (g =
                e.itemSize, k(f), q.vertexAttribPointer(f, g, q.FLOAT, !1, 4 * m, 4 * (e.itemOffset + d * m))) : l = !0))
        } else l = !0; if (l)
            for (h in b) "index" != h && (f = b[h], e = c.attributes[h], 0 <= f && (e ? void 0 === e.itemOffset && (c.streamingDraw ? (g = za[h], g || (g = q.createBuffer(), za[h] = g), q.bindBuffer(q.ARRAY_BUFFER, g), q.bufferData(q.ARRAY_BUFFER, e.array, q.STATIC_DRAW)) : q.bindBuffer(q.ARRAY_BUFFER, e.buffer), g = e.itemSize, k(f), q.vertexAttribPointer(f, g, q.FLOAT, !1, 0, d * g * 4)) : a.defaultAttributeValues && (2 === a.defaultAttributeValues[h].length ? q.vertexAttrib2fv(f,
                a.defaultAttributeValues[h]) : 3 === a.defaultAttributeValues[h].length && q.vertexAttrib3fv(f, a.defaultAttributeValues[h]))))
    }

    function f(a, b, c, d) {
        var e, f, g, h;
        for (f in b) g = b[f], e = c[f], 0 <= g && (e ? (h = e.itemSize, q.bindBuffer(q.ARRAY_BUFFER, e.buffer), k(g), q.vertexAttribPointer(g, h, q.FLOAT, !1, 0, d * h * 4)) : a.defaultAttributeValues && a.defaultAttributeValues[f] && (2 === a.defaultAttributeValues[f].length ? q.vertexAttrib2fv(g, a.defaultAttributeValues[f]) : 3 === a.defaultAttributeValues[f].length && q.vertexAttrib3fv(g, a.defaultAttributeValues[f])))
    }

    function k(a) {
        la[a] || (q.enableVertexAttribArray(a), la[a] = !0)
    }

    function h() {
        for (var a = 0, b = la.length; a < b; a++) la[a] && (q.disableVertexAttribArray(a), la[a] = !1)
    }

    function l(a, b) {
        return a.z !== b.z ? b.z - a.z : a.id - b.id
    }

    function m(a, b, c) {
        if (a.length)
            for (var d = 0, e = a.length; d < e; d++) pa = ca = null, aa = ga = Ja = ma = Va = Ua = Aa = -1, Pa = !0, a[d].render(b, c, sa, Ba), pa = ca = null, aa = ga = Ja = ma = Va = Ua = Aa = -1, Pa = !0
    }

    function n(a, b, c, d, e, f, g, k) {
        var h, l, m, n;
        b ? (l = a.length - 1, n = b = -1) : (l = 0, b = a.length, n = 1);
        for (var q = l; q !== b; q += n)
            if (h = a[q], h.render) {
                l =
                    h.object;
                m = h.buffer;
                if (k) h = k;
                else {
                    h = h[c];
                    if (!h) continue;
                    g && S.setBlending(h.blending, h.blendEquation, h.blendSrc, h.blendDst);
                    S.setDepthTest(h.depthTest);
                    S.setDepthWrite(h.depthWrite);
                    N(h.polygonOffset, h.polygonOffsetFactor, h.polygonOffsetUnits)
                }
                S.setMaterialFaces(h);
                m instanceof THREE.BufferGeometry ? S.renderBufferDirect(d, e, f, h, m, l) : S.renderBuffer(d, e, f, h, m, l)
            }
    }

    function r(a, c) {
        var d, e, f, g;
        if (void 0 === a.__webglInit && (a.__webglInit = !0, a._modelViewMatrix = new THREE.Matrix4, a._normalMatrix = new THREE.Matrix3,
            void 0 !== a.geometry && void 0 === a.geometry.__webglInit && (a.geometry.__webglInit = !0, a.geometry.addEventListener("dispose", tb)), e = a.geometry, void 0 !== e))
            if (e instanceof THREE.BufferGeometry)
                if (e.streamingDraw)!e.streamingIndex && (e = e.attributes.index) && (e.buffer = q.createBuffer(), q.bindBuffer(q.ELEMENT_ARRAY_BUFFER, e.buffer), q.bufferData(q.ELEMENT_ARRAY_BUFFER, e.array, q.STATIC_DRAW));
        else {
            e.vb && (e.vbbuffer = q.createBuffer(), q.bindBuffer(q.ARRAY_BUFFER, e.vbbuffer), q.bufferData(q.ARRAY_BUFFER, e.vb, q.STATIC_DRAW));
            var k, h;
            for (k in e.attributes) g = e.attributes[k], g.array && (h = "index" === k ? q.ELEMENT_ARRAY_BUFFER : q.ARRAY_BUFFER, g.buffer = q.createBuffer(), q.bindBuffer(h, g.buffer), q.bufferData(h, g.array, q.STATIC_DRAW))
        } else if (a instanceof THREE.Mesh) {
            f = a.material;
            if (void 0 === e.geometryGroups) {
                h = e;
                var l, m, n;
                k = {};
                var r = h.morphTargets.length,
                    p = h.morphNormals.length,
                    t = f instanceof THREE.MeshFaceMaterial;
                h.geometryGroups = {};
                f = 0;
                for (l = h.faces.length; f < l; f++) m = h.faces[f], m = t ? m.materialIndex : 0, void 0 === k[m] && (k[m] = {
                    hash: m,
                    counter: 0
                }), n = k[m].hash + "_" + k[m].counter, void 0 === h.geometryGroups[n] && (h.geometryGroups[n] = {
                    faces3: [],
                    materialIndex: m,
                    vertices: 0,
                    numMorphTargets: r,
                    numMorphNormals: p
                }), 65535 < h.geometryGroups[n].vertices + 3 && (k[m].counter += 1, n = k[m].hash + "_" + k[m].counter, void 0 === h.geometryGroups[n] && (h.geometryGroups[n] = {
                    faces3: [],
                    materialIndex: m,
                    vertices: 0,
                    numMorphTargets: r,
                    numMorphNormals: p
                })), h.geometryGroups[n].faces3.push(f), h.geometryGroups[n].vertices += 3;
                h.geometryGroupsList = [];
                for (g in h.geometryGroups) h.geometryGroups[g].id =
                    ea++, h.geometryGroupsList.push(h.geometryGroups[g])
            }
            for (d in e.geometryGroups) g = e.geometryGroups[d], g.__webglVertexBuffer || (h = g, h.__webglVertexBuffer = q.createBuffer(), h.__webglNormalBuffer = q.createBuffer(), h.__webglTangentBuffer = q.createBuffer(), h.__webglColorBuffer = q.createBuffer(), h.__webglUVBuffer = q.createBuffer(), h.__webglUV2Buffer = q.createBuffer(), h.__webglSkinIndicesBuffer = q.createBuffer(), h.__webglSkinWeightsBuffer = q.createBuffer(), h.__webglFaceBuffer = q.createBuffer(), h.__webglLineBuffer = q.createBuffer(),
                S.info.memory.geometries++, b(g, a), e.verticesNeedUpdate = !0, e.morphTargetsNeedUpdate = !0, e.elementsNeedUpdate = !0, e.uvsNeedUpdate = !0, e.normalsNeedUpdate = !0, e.tangentsNeedUpdate = !0, e.colorsNeedUpdate = !0)
        } else if (a instanceof THREE.Line && !e.__webglVertexBuffer) {
            g = e;
            g.__webglVertexBuffer = q.createBuffer();
            g.__webglColorBuffer = q.createBuffer();
            g.__webglLineDistanceBuffer = q.createBuffer();
            S.info.memory.geometries++;
            g = e;
            k = g.vertices.length;
            g.__vertexArray = new Float32Array(3 * k);
            g.__colorArray = new Float32Array(3 *
                k);
            g.__lineDistanceArray = new Float32Array(1 * k);
            g.__webglLineCount = k;
            k = g.vertices.length;
            r = a.material;
            if (r.attributes)
                for (h in void 0 === g.__webglCustomAttributesList && (g.__webglCustomAttributesList = []), r.attributes) {
                    p = r.attributes[h];
                    if (!p.__webglInitialized || p.createUniqueBuffers) p.__webglInitialized = !0, f = 1, "v2" === p.type ? f = 2 : "v3" === p.type ? f = 3 : "v4" === p.type ? f = 4 : "c" === p.type && (f = 3), p.size = f, p.array = new Float32Array(k * f), p.buffer = q.createBuffer(), p.buffer.belongsToAttribute = h, p.needsUpdate = !0;
                    g.__webglCustomAttributesList.push(p)
                }
            e.verticesNeedUpdate = !0;
            e.colorsNeedUpdate = !0;
            e.lineDistancesNeedUpdate = !0
        }
        if (void 0 === a.__webglActive) {
            if (a instanceof THREE.Mesh)
                if (e = a.geometry, e instanceof THREE.BufferGeometry) s(c.__webglObjects, e, a);
                else {
                    if (e instanceof THREE.Geometry)
                        for (d in e.geometryGroups) g = e.geometryGroups[d], s(c.__webglObjects, g, a)
                } else a instanceof THREE.Line && (e = a.geometry, s(c.__webglObjects, e, a));
            a.__webglActive = !0
        }
    }

    function s(a, b, c) {
        a.push({
            id: null,
            buffer: b,
            object: c,
            opaque: null,
            transparent: null,
            z: 0
        })
    }

    function t(a) {
        for (var b in a.attributes)
            if (a.attributes[b].needsUpdate) return !0;
        return !1
    }

    function p(a) {
        for (var b in a.attributes) a.attributes[b].needsUpdate = !1
    }

    function u(a, b) {
        if (a instanceof THREE.Mesh || a instanceof THREE.Line)
            for (var c = b.__webglObjects, d = c.length - 1; 0 <= d; d--) c[d].object === a && c.splice(d, 1);
        delete a.__webglActive
    }

    function v(a, b, c, d, e) {
        R = 0;
        d.needsUpdate && (d.program && ub(d), S.initMaterial(d, b, c, e), d.needsUpdate = !1);
        var f = !1,
            g = d.program,
            k = g.uniforms,
            h = d.uniforms;
        g !== ca && (q.useProgram(g), ca = g, f = !0);
        d.id !== aa && (aa = d.id, f = !0);
        if (f || a !== pa) q.uniformMatrix4fv(k.projectionMatrix, !1, a.projectionMatrix.elements), a !== pa && (pa = a);
        if (f) {
            c && d.fog && (h.fogColor.value = c.color, c instanceof THREE.Fog ? (h.fogNear.value = c.near, h.fogFar.value = c.far) : c instanceof THREE.FogExp2 && (h.fogDensity.value = c.density));
            if (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d.lights) {
                if (Pa) {
                    var l, m = 0,
                        n = 0,
                        p = 0,
                        r, s, t, u = cb,
                        v = u.directional.colors,
                        A = u.directional.positions,
                        B = u.point.colors,
                        z = u.point.positions,
                        G = u.point.distances,
                        N = u.spot.colors,
                        F = u.spot.positions,
                        K = u.spot.distances,
                        J = u.spot.directions,
                        O = u.spot.anglesCos,
                        Ab = u.spot.exponents,
                        T = u.hemi.skyColors,
                        D = u.hemi.groundColors,
                        I = u.hemi.positions,
                        M = 0,
                        U = 0,
                        X = 0,
                        Y = 0,
                        ba = 0,
                        ea = 0,
                        ga = 0,
                        Z = 0,
                        W = l = 0;
                    c = t = W = 0;
                    for (f = b.length; c < f; c++)
                        if (l = b[c], !l.onlyShadow)
                            if (r = l.color, s = l.intensity, t = l.distance, l instanceof THREE.AmbientLight) l.visible && (S.gammaInput ? (m += r.r * r.r, n += r.g * r.g, p += r.b * r.b) : (m += r.r, n += r.g, p += r.b));
                            else if (l instanceof THREE.DirectionalLight) {
                        if (ba += 1, l.visible && (ia.setFromMatrixPosition(l.matrixWorld), da.setFromMatrixPosition(l.target.matrixWorld),
                            ia.sub(da), ia.normalize(), 0 !== ia.x || 0 !== ia.y || 0 !== ia.z)) l = 3 * M, A[l] = ia.x, A[l + 1] = ia.y, A[l + 2] = ia.z, S.gammaInput ? y(v, l, r, s * s) : x(v, l, r, s), M += 1
                    } else l instanceof THREE.PointLight ? (ea += 1, l.visible && (W = 3 * U, S.gammaInput ? y(B, W, r, s * s) : x(B, W, r, s), da.setFromMatrixPosition(l.matrixWorld), z[W] = da.x, z[W + 1] = da.y, z[W + 2] = da.z, G[U] = t, U += 1)) : l instanceof THREE.SpotLight ? (ga += 1, l.visible && (W = 3 * X, S.gammaInput ? y(N, W, r, s * s) : x(N, W, r, s), da.setFromMatrixPosition(l.matrixWorld), F[W] = da.x, F[W + 1] = da.y, F[W + 2] = da.z, K[X] = t, ia.copy(da),
                        da.setFromMatrixPosition(l.target.matrixWorld), ia.sub(da), ia.normalize(), J[W] = ia.x, J[W + 1] = ia.y, J[W + 2] = ia.z, O[X] = Math.cos(l.angle), Ab[X] = l.exponent, X += 1)) : l instanceof THREE.HemisphereLight && (Z += 1, l.visible && (ia.setFromMatrixPosition(l.matrixWorld), ia.normalize(), 0 !== ia.x || 0 !== ia.y || 0 !== ia.z)) && (t = 3 * Y, I[t] = ia.x, I[t + 1] = ia.y, I[t + 2] = ia.z, r = l.color, l = l.groundColor, S.gammaInput ? (s *= s, y(T, t, r, s), y(D, t, l, s)) : (x(T, t, r, s), x(D, t, l, s)), Y += 1);
                    c = 3 * M;
                    for (f = Math.max(v.length, 3 * ba); c < f; c++) v[c] = 0;
                    c = 3 * U;
                    for (f = Math.max(B.length,
                        3 * ea); c < f; c++) B[c] = 0;
                    c = 3 * X;
                    for (f = Math.max(N.length, 3 * ga); c < f; c++) N[c] = 0;
                    c = 3 * Y;
                    for (f = Math.max(T.length, 3 * Z); c < f; c++) T[c] = 0;
                    c = 3 * Y;
                    for (f = Math.max(D.length, 3 * Z); c < f; c++) D[c] = 0;
                    u.directional.length = M;
                    u.point.length = U;
                    u.spot.length = X;
                    u.hemi.length = Y;
                    u.ambient[0] = m;
                    u.ambient[1] = n;
                    u.ambient[2] = p;
                    Pa = !1
                }
                c = cb;
                h.ambientLightColor.value = c.ambient;
                h.directionalLightColor.value = c.directional.colors;
                h.directionalLightDirection.value = c.directional.positions;
                h.pointLightColor.value = c.point.colors;
                h.pointLightPosition.value =
                    c.point.positions;
                h.pointLightDistance.value = c.point.distances;
                h.spotLightColor.value = c.spot.colors;
                h.spotLightPosition.value = c.spot.positions;
                h.spotLightDistance.value = c.spot.distances;
                h.spotLightDirection.value = c.spot.directions;
                h.spotLightAngleCos.value = c.spot.anglesCos;
                h.spotLightExponent.value = c.spot.exponents;
                h.hemisphereLightSkyColor.value = c.hemi.skyColors;
                h.hemisphereLightGroundColor.value = c.hemi.groundColors;
                h.hemisphereLightDirection.value = c.hemi.positions
            }
            if (d instanceof THREE.MeshBasicMaterial ||
                d instanceof THREE.MeshLambertMaterial || d instanceof THREE.MeshPhongMaterial) {
                h.opacity.value = d.opacity;
                S.gammaInput ? h.diffuse.value.copyGammaToLinear(d.color) : h.diffuse.value.copy(d.color);
                h.map.value = d.map;
                h.lightMap.value = d.lightMap;
                h.specularMap.value = d.specularMap;
                d.bumpMap && (h.bumpMap.value = d.bumpMap, h.bumpScale.value = d.bumpScale);
                d.normalMap && (h.normalMap.value = d.normalMap, h.normalScale.value.copy(d.normalScale));
                var V;
                d.map ? V = d.map : d.specularMap ? V = d.specularMap : d.normalMap ? V = d.normalMap : d.bumpMap &&
                    (V = d.bumpMap);
                void 0 !== V && (c = V.offset, V = V.repeat, h.offsetRepeat.value.set(c.x, c.y, V.x, V.y));
                h.envMap.value = d.envMap;
                h.reflectivity.value = S.gammaInput ? d.reflectivity * d.reflectivity : d.reflectivity;
                h.refractionRatio.value = d.refractionRatio;
                h.combine.value = d.combine;
                h.useRefract.value = d.envMap && d.envMap.mapping instanceof THREE.CubeRefractionMapping
            }
            d instanceof THREE.LineBasicMaterial ? (h.diffuse.value = d.color, h.opacity.value = d.opacity) : d instanceof THREE.LineDashedMaterial ? (h.diffuse.value = d.color, h.opacity.value =
                d.opacity, h.dashSize.value = d.dashSize, h.totalSize.value = d.dashSize + d.gapSize, h.scale.value = d.scale) : d instanceof THREE.MeshPhongMaterial ? (h.shininess.value = d.shininess, S.gammaInput ? (h.ambient.value.copyGammaToLinear(d.ambient), h.emissive.value.copyGammaToLinear(d.emissive), h.specular.value.copyGammaToLinear(d.specular)) : (h.ambient.value.copy(d.ambient), h.emissive.value.copy(d.emissive), h.specular.value.copy(d.specular)), d.wrapAround && h.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshLambertMaterial ?
                (S.gammaInput ? (h.ambient.value.copyGammaToLinear(d.ambient), h.emissive.value.copyGammaToLinear(d.emissive)) : (h.ambient.value.copy(d.ambient), h.emissive.value.copy(d.emissive)), d.wrapAround && h.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshDepthMaterial ? (h.mNear.value = a.near, h.mFar.value = a.far, h.opacity.value = d.opacity) : d instanceof THREE.MeshNormalMaterial && (h.opacity.value = d.opacity);
            if (e.receiveShadow && !d._shadowPass && h.shadowMatrix)
                for (c = V = 0, f = b.length; c < f; c++) m = b[c], m.castShadow && (m instanceof THREE.SpotLight || m instanceof THREE.DirectionalLight && !m.shadowCascade) && (h.shadowMap.value[V] = m.shadowMap, h.shadowMapSize.value[V] = m.shadowMapSize, h.shadowMatrix.value[V] = m.shadowMatrix, h.shadowDarkness.value[V] = m.shadowDarkness, h.shadowBias.value[V] = m.shadowBias, V++);
            b = d.uniformsList;
            h = 0;
            for (V = b.length; h < V; h++)
                if (f = g.uniforms[b[h][1]])
                    if (c = b[h][0], m = c.type, p = c.value, "i" === m) q.uniform1i(f, p);
                    else if ("f" === m) q.uniform1f(f, p);
            else if ("v2" === m) q.uniform2f(f, p.x, p.y);
            else if ("v3" === m) q.uniform3f(f, p.x,
                p.y, p.z);
            else if ("v4" === m) q.uniform4f(f, p.x, p.y, p.z, p.w);
            else if ("c" === m) q.uniform3f(f, p.r, p.g, p.b);
            else if ("iv1" === m) q.uniform1iv(f, p);
            else if ("iv" === m) q.uniform3iv(f, p);
            else if ("fv1" === m) q.uniform1fv(f, p);
            else if ("fv" === m) q.uniform3fv(f, p);
            else if ("v2v" === m) {
                void 0 === c._array && (c._array = new Float32Array(2 * p.length));
                m = 0;
                for (n = p.length; m < n; m++) u = 2 * m, c._array[u] = p[m].x, c._array[u + 1] = p[m].y;
                q.uniform2fv(f, c._array)
            } else if ("v3v" === m) {
                void 0 === c._array && (c._array = new Float32Array(3 * p.length));
                m = 0;
                for (n =
                    p.length; m < n; m++) u = 3 * m, c._array[u] = p[m].x, c._array[u + 1] = p[m].y, c._array[u + 2] = p[m].z;
                q.uniform3fv(f, c._array)
            } else if ("v4v" === m) {
                void 0 === c._array && (c._array = new Float32Array(4 * p.length));
                m = 0;
                for (n = p.length; m < n; m++) u = 4 * m, c._array[u] = p[m].x, c._array[u + 1] = p[m].y, c._array[u + 2] = p[m].z, c._array[u + 3] = p[m].w;
                q.uniform4fv(f, c._array)
            } else if ("m4" === m) void 0 === c._array && (c._array = new Float32Array(16)), p.flattenToArray(c._array), q.uniformMatrix4fv(f, !1, c._array);
            else if ("m4v" === m) {
                void 0 === c._array && (c._array =
                    new Float32Array(16 * p.length));
                m = 0;
                for (n = p.length; m < n; m++) p[m].flattenToArrayOffset(c._array, 16 * m);
                q.uniformMatrix4fv(f, !1, c._array)
            } else if ("t" === m) {
                if (u = p, p = w(), q.uniform1i(f, p), u)
                    if (u.image instanceof Array && 6 === u.image.length) {
                        if (c = u, f = p, 6 === c.image.length)
                            if (c.needsUpdate) {
                                c.image.__webglTextureCube || (c.addEventListener("dispose", eb), c.image.__webglTextureCube = q.createTexture(), S.info.memory.textures++);
                                q.activeTexture(q.TEXTURE0 + f);
                                q.bindTexture(q.TEXTURE_CUBE_MAP, c.image.__webglTextureCube);
                                q.pixelStorei(q.UNPACK_FLIP_Y_WEBGL, c.flipY);
                                f = c instanceof THREE.CompressedTexture;
                                m = [];
                                for (n = 0; 6 > n; n++) S.autoScaleCubemaps && !f ? (p = m, u = n, v = c.image[n], B = xb, v.width <= B && v.height <= B || (z = Math.max(v.width, v.height), A = Math.floor(v.width * B / z), B = Math.floor(v.height * B / z), z = document.createElement("canvas"), z.width = A, z.height = B, z.getContext("2d").drawImage(v, 0, 0, v.width, v.height, 0, 0, A, B), v = z), p[u] = v) : m[n] = c.image[n];
                                n = m[0];
                                p = C(n.width) && C(n.height);
                                u = Q(c.format);
                                v = Q(c.type);
                                P(q.TEXTURE_CUBE_MAP, c, p);
                                for (n =
                                    0; 6 > n; n++)
                                    if (f)
                                        for (B = m[n].mipmaps, z = 0, G = B.length; z < G; z++) A = B[z], c.format !== THREE.RGBAFormat ? q.compressedTexImage2D(q.TEXTURE_CUBE_MAP_POSITIVE_X + n, z, u, A.width, A.height, 0, A.data) : q.texImage2D(q.TEXTURE_CUBE_MAP_POSITIVE_X + n, z, u, A.width, A.height, 0, u, v, A.data);
                                    else m[n].data ? q.texImage2D(q.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0, u, m[n].width, m[n].height, 0, u, v, m[n].data) : q.texImage2D(q.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0, u, u, v, m[n]);
                                c.generateMipmaps && p && q.generateMipmap(q.TEXTURE_CUBE_MAP);
                                c.needsUpdate = !1;
                                if (c.onUpdate) c.onUpdate()
                            } else q.activeTexture(q.TEXTURE0 +
                                f), q.bindTexture(q.TEXTURE_CUBE_MAP, c.image.__webglTextureCube)
                    } else S.setTexture(u, p)
            } else if ("tv" === m) {
                void 0 === c._array && (c._array = []);
                m = 0;
                for (n = c.value.length; m < n; m++) c._array[m] = w();
                q.uniform1iv(f, c._array);
                m = 0;
                for (n = c.value.length; m < n; m++) u = c.value[m], p = c._array[m], u && S.setTexture(u, p)
            } else console.warn("THREE.WebGLRenderer: Unknown uniform type: " + m);
            (d instanceof THREE.ShaderMaterial || d instanceof THREE.MeshPhongMaterial || d.envMap) && null !== k.cameraPosition && (da.setFromMatrixPosition(a.matrixWorld),
                q.uniform3f(k.cameraPosition, da.x, da.y, da.z));
            (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.ShaderMaterial || d.skinning) && null !== k.viewMatrix && q.uniformMatrix4fv(k.viewMatrix, !1, a.matrixWorldInverse.elements)
        }
        q.uniformMatrix4fv(k.modelViewMatrix, !1, e._modelViewMatrix.elements);
        k.normalMatrix && q.uniformMatrix3fv(k.normalMatrix, !1, e._normalMatrix.elements);
        null !== k.modelMatrix && q.uniformMatrix4fv(k.modelMatrix, !1, e.matrixWorld.elements);
        return g
    }

    function w() {
        var a =
            R;
        a >= kb && console.warn("WebGLRenderer: trying to use " + a + " texture units while this GPU supports only " + kb);
        R += 1;
        return a
    }

    function y(a, b, c, d) {
        a[b] = c.r * c.r * d;
        a[b + 1] = c.g * c.g * d;
        a[b + 2] = c.b * c.b * d
    }

    function x(a, b, c, d) {
        a[b] = c.r * d;
        a[b + 1] = c.g * d;
        a[b + 2] = c.b * d
    }

    function A(a) {
        a !== oa && (q.lineWidth(a), oa = a)
    }

    function N(a, b, c) {
        jb !== a && (a ? q.enable(q.POLYGON_OFFSET_FILL) : q.disable(q.POLYGON_OFFSET_FILL), jb = a);
        !a || na === b && Fa === c || (q.polygonOffset(b, c), na = b, Fa = c)
    }

    function B(a) {
        a = a.split("\n");
        for (var b = 0, c = a.length; b < c; b++) a[b] =
            b + 1 + ": " + a[b];
        return a.join("\n")
    }

    function G(a, b) {
        var c;
        "fragment" === a ? c = q.createShader(q.FRAGMENT_SHADER) : "vertex" === a && (c = q.createShader(q.VERTEX_SHADER));
        q.shaderSource(c, b);
        q.compileShader(c);
        return q.getShaderParameter(c, q.COMPILE_STATUS) ? c : (console.error(q.getShaderInfoLog(c)), console.error(B(b)), null)
    }

    function C(a) {
        return 0 === (a & a - 1)
    }

    function P(a, b, c) {
        c ? (q.texParameteri(a, q.TEXTURE_WRAP_S, Q(b.wrapS)), q.texParameteri(a, q.TEXTURE_WRAP_T, Q(b.wrapT)), q.texParameteri(a, q.TEXTURE_MAG_FILTER, Q(b.magFilter)),
            q.texParameteri(a, q.TEXTURE_MIN_FILTER, Q(b.minFilter))) : (q.texParameteri(a, q.TEXTURE_WRAP_S, q.CLAMP_TO_EDGE), q.texParameteri(a, q.TEXTURE_WRAP_T, q.CLAMP_TO_EDGE), q.texParameteri(a, q.TEXTURE_MAG_FILTER, z(b.magFilter)), q.texParameteri(a, q.TEXTURE_MIN_FILTER, z(b.minFilter)));
        Sa && b.type !== THREE.FloatType && (1 < b.anisotropy || b.__oldAnisotropy) && (q.texParameterf(a, Sa.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(b.anisotropy, lb)), b.__oldAnisotropy = b.anisotropy)
    }

    function z(a) {
        return a === THREE.NearestFilter || a === THREE.NearestMipMapNearestFilter ||
            a === THREE.NearestMipMapLinearFilter ? q.NEAREST : q.LINEAR
    }

    function Q(a) {
        if (a === THREE.RepeatWrapping) return q.REPEAT;
        if (a === THREE.ClampToEdgeWrapping) return q.CLAMP_TO_EDGE;
        if (a === THREE.MirroredRepeatWrapping) return q.MIRRORED_REPEAT;
        if (a === THREE.NearestFilter) return q.NEAREST;
        if (a === THREE.NearestMipMapNearestFilter) return q.NEAREST_MIPMAP_NEAREST;
        if (a === THREE.NearestMipMapLinearFilter) return q.NEAREST_MIPMAP_LINEAR;
        if (a === THREE.LinearFilter) return q.LINEAR;
        if (a === THREE.LinearMipMapNearestFilter) return q.LINEAR_MIPMAP_NEAREST;
        if (a === THREE.LinearMipMapLinearFilter) return q.LINEAR_MIPMAP_LINEAR;
        if (a === THREE.UnsignedByteType) return q.UNSIGNED_BYTE;
        if (a === THREE.UnsignedShort4444Type) return q.UNSIGNED_SHORT_4_4_4_4;
        if (a === THREE.UnsignedShort5551Type) return q.UNSIGNED_SHORT_5_5_5_1;
        if (a === THREE.UnsignedShort565Type) return q.UNSIGNED_SHORT_5_6_5;
        if (a === THREE.ByteType) return q.BYTE;
        if (a === THREE.ShortType) return q.SHORT;
        if (a === THREE.UnsignedShortType) return q.UNSIGNED_SHORT;
        if (a === THREE.IntType) return q.INT;
        if (a === THREE.UnsignedIntType) return q.UNSIGNED_INT;
        if (a === THREE.FloatType) return q.FLOAT;
        if (a === THREE.HalfFloatType) return 36193;
        if (a === THREE.AlphaFormat) return q.ALPHA;
        if (a === THREE.RGBFormat) return q.RGB;
        if (a === THREE.RGBAFormat) return q.RGBA;
        if (a === THREE.LuminanceFormat) return q.LUMINANCE;
        if (a === THREE.LuminanceAlphaFormat) return q.LUMINANCE_ALPHA;
        if (a === THREE.AddEquation) return q.FUNC_ADD;
        if (a === THREE.SubtractEquation) return q.FUNC_SUBTRACT;
        if (a === THREE.ReverseSubtractEquation) return q.FUNC_REVERSE_SUBTRACT;
        if (a === THREE.ZeroFactor) return q.ZERO;
        if (a === THREE.OneFactor) return q.ONE;
        if (a === THREE.SrcColorFactor) return q.SRC_COLOR;
        if (a === THREE.OneMinusSrcColorFactor) return q.ONE_MINUS_SRC_COLOR;
        if (a === THREE.SrcAlphaFactor) return q.SRC_ALPHA;
        if (a === THREE.OneMinusSrcAlphaFactor) return q.ONE_MINUS_SRC_ALPHA;
        if (a === THREE.DstAlphaFactor) return q.DST_ALPHA;
        if (a === THREE.OneMinusDstAlphaFactor) return q.ONE_MINUS_DST_ALPHA;
        if (a === THREE.DstColorFactor) return q.DST_COLOR;
        if (a === THREE.OneMinusDstColorFactor) return q.ONE_MINUS_DST_COLOR;
        if (a === THREE.SrcAlphaSaturateFactor) return q.SRC_ALPHA_SATURATE;
        if (void 0 !== Ga) {
            if (a === THREE.RGB_S3TC_DXT1_Format) return Ga.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (a === THREE.RGBA_S3TC_DXT1_Format) return Ga.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (a === THREE.RGBA_S3TC_DXT3_Format) return Ga.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (a === THREE.RGBA_S3TC_DXT5_Format) return Ga.COMPRESSED_RGBA_S3TC_DXT5_EXT
        }
        return 0
    }
    console.log("THREE.WebGLRenderer", THREE.REVISION);
    a = a || {};
    var F = void 0 !== a.canvas ? a.canvas : document.createElement("canvas"),
        O = void 0 !== a.precision ? a.precision : "highp",
        T = void 0 !==
        a.alpha ? a.alpha : !1,
        D = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0,
        J = void 0 !== a.antialias ? a.antialias : !1,
        I = void 0 !== a.stencil ? a.stencil : !0,
        U = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1,
        M = new THREE.Color(0),
        Y = 0;
    this.domElement = F;
    this.context = null;
    this.devicePixelRatio = void 0 !== a.devicePixelRatio ? a.devicePixelRatio : void 0 !== self.devicePixelRatio ? self.devicePixelRatio : 1;
    this.autoUpdateObjects = this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
    this.shadowMapEnabled = this.gammaOutput = this.gammaInput = !1;
    this.shadowMapAutoUpdate = !0;
    this.shadowMapType = THREE.PCFShadowMap;
    this.shadowMapCullFace = THREE.CullFaceFront;
    this.shadowMapCascade = this.shadowMapDebug = !1;
    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;
    this.autoScaleCubemaps = !0;
    this.renderPluginsPre = [];
    this.renderPluginsPost = [];
    this.info = {
        memory: {
            programs: 0,
            geometries: 0,
            textures: 0
        },
        render: {
            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0
        }
    };
    var S = this,
        X = [],
        K = 0,
        ca = null,
        ba = null,
        aa = -1,
        ga = null,
        pa = null,
        ea = 0,
        R = 0,
        ma = -1,
        Ja = -1,
        Aa = -1,
        Ka = -1,
        Ra = -1,
        Za = -1,
        Ua = -1,
        Va = -1,
        jb = null,
        na = null,
        Fa = null,
        oa = null,
        va = 0,
        wa = 0,
        xa = F.width,
        ya = F.height,
        sa = 0,
        Ba = 0,
        la = [],
        za = {},
        Wa = new THREE.Frustum,
        ta = new THREE.Matrix4;
    new THREE.Matrix4;
    var da = new THREE.Vector3,
        ia = new THREE.Vector3,
        Pa = !0,
        cb = {
            ambient: [0, 0, 0],
            directional: {
                length: 0,
                colors: [],
                positions: []
            },
            point: {
                length: 0,
                colors: [],
                positions: [],
                distances: []
            },
            spot: {
                length: 0,
                colors: [],
                positions: [],
                distances: [],
                directions: [],
                anglesCos: [],
                exponents: []
            },
            hemi: {
                length: 0,
                skyColors: [],
                groundColors: [],
                positions: []
            }
        },
        q, Xa, db, Qa, Sa, Ga, qa;
    (function () {
        try {
            var a = {
                alpha: T,
                premultipliedAlpha: D,
                antialias: J,
                stencil: I,
                preserveDrawingBuffer: U
            };
            q = F.getContext("webgl", a) || F.getContext("experimental-webgl", a);
            if (null === q) throw "Error creating WebGL context.";
        } catch (b) {
            console.error(b)
        }
        Xa = q.getExtension("OES_texture_float");
        db = q.getExtension("OES_texture_half_float");
        q.getExtension("OES_texture_float_linear");
        Qa = q.getExtension("OES_standard_derivatives");
        qa = q.getExtension("WEBGL_draw_buffers");
        Sa = q.getExtension("EXT_texture_filter_anisotropic") ||
            q.getExtension("MOZ_EXT_texture_filter_anisotropic") || q.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        Ga = q.getExtension("WEBGL_compressed_texture_s3tc") || q.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || q.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        Xa || console.log("THREE.WebGLRenderer: Float textures not supported.");
        db || console.log("THREE.WebGLRenderer: Half float textures not supported.");
        Qa || console.log("THREE.WebGLRenderer: Standard derivatives not supported.");
        Sa || console.log("THREE.WebGLRenderer: Anisotropic texture filtering not supported.");
        Ga || console.log("THREE.WebGLRenderer: S3TC compressed textures not supported.");
        qa || console.log("THREE.WebGLRenderer: Multiple render targets not supported.");
        void 0 === q.getShaderPrecisionFormat && (q.getShaderPrecisionFormat = function () {
            return {
                rangeMin: 1,
                rangeMax: 1,
                precision: 1
            }
        })
    })();
    q.clearColor(0, 0, 0, 1);
    q.clearDepth(1);
    q.clearStencil(0);
    q.enable(q.DEPTH_TEST);
    q.depthFunc(q.LEQUAL);
    q.frontFace(q.CCW);
    q.cullFace(q.BACK);
    q.enable(q.CULL_FACE);
    q.enable(q.BLEND);
    q.blendEquation(q.FUNC_ADD);
    q.blendFunc(q.SRC_ALPHA,
        q.ONE_MINUS_SRC_ALPHA);
    q.viewport(va, wa, xa, ya);
    q.clearColor(M.r, M.g, M.b, Y);
    this.context = q;
    var kb = q.getParameter(q.MAX_TEXTURE_IMAGE_UNITS);
    a = q.getParameter(q.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    q.getParameter(q.MAX_TEXTURE_SIZE);
    var xb = q.getParameter(q.MAX_CUBE_MAP_TEXTURE_SIZE),
        lb = Sa ? q.getParameter(Sa.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0,
        $a = 0 < a,
        yb = $a && Xa;
    Ga && q.getParameter(q.COMPRESSED_TEXTURE_FORMATS);
    var ab = q.getShaderPrecisionFormat(q.VERTEX_SHADER, q.HIGH_FLOAT);
    a = q.getShaderPrecisionFormat(q.VERTEX_SHADER,
        q.MEDIUM_FLOAT);
    q.getShaderPrecisionFormat(q.VERTEX_SHADER, q.LOW_FLOAT);
    var zb = q.getShaderPrecisionFormat(q.FRAGMENT_SHADER, q.HIGH_FLOAT),
        Bb = q.getShaderPrecisionFormat(q.FRAGMENT_SHADER, q.MEDIUM_FLOAT);
    q.getShaderPrecisionFormat(q.FRAGMENT_SHADER, q.LOW_FLOAT);
    q.getShaderPrecisionFormat(q.VERTEX_SHADER, q.HIGH_INT);
    q.getShaderPrecisionFormat(q.VERTEX_SHADER, q.MEDIUM_INT);
    q.getShaderPrecisionFormat(q.VERTEX_SHADER, q.LOW_INT);
    q.getShaderPrecisionFormat(q.FRAGMENT_SHADER, q.HIGH_INT);
    q.getShaderPrecisionFormat(q.FRAGMENT_SHADER,
        q.MEDIUM_INT);
    q.getShaderPrecisionFormat(q.FRAGMENT_SHADER, q.LOW_INT);
    ab = 0 < ab.precision && 0 < zb.precision;
    a = 0 < a.precision && 0 < Bb.precision;
    "highp" !== O || ab || (a ? (O = "mediump", console.warn("WebGLRenderer: highp not supported, using mediump")) : (O = "lowp", console.warn("WebGLRenderer: highp and mediump not supported, using lowp")));
    "mediump" !== O || a || (O = "lowp", console.warn("WebGLRenderer: mediump not supported, using lowp"));
    this.getContext = function () {
        return q
    };
    this.supportsVertexTextures = function () {
        return $a
    };
    this.supportsFloatTextures = function () {
        return Xa
    };
    this.supportsStandardDerivatives = function () {
        return Qa
    };
    this.supportsCompressedTextureS3TC = function () {
        return Ga
    };
    this.supportsMRT = function () {
        return qa
    };
    this.getMaxAnisotropy = function () {
        return lb
    };
    this.getPrecision = function () {
        return O
    };
    this.setSize = function (a, b, c) {
        F.width = a * this.devicePixelRatio;
        F.height = b * this.devicePixelRatio;
        1 !== this.devicePixelRatio && !1 !== c && (F.style.width = a + "px", F.style.height = b + "px");
        this.setViewport(0, 0, a, b)
    };
    this.setViewport =
        function (a, b, c, d) {
            va = a * this.devicePixelRatio;
            wa = b * this.devicePixelRatio;
            xa = c * this.devicePixelRatio;
            ya = d * this.devicePixelRatio;
            q.viewport(va, wa, xa, ya)
    };
    this.setScissor = function (a, b, c, d) {
        q.scissor(a, b, c, d)
    };
    this.enableScissorTest = function (a) {
        a ? q.enable(q.SCISSOR_TEST) : q.disable(q.SCISSOR_TEST)
    };
    this.setClearColor = function (a, b) {
        M.set(a);
        Y = void 0 !== b ? b : 1;
        q.clearColor(M.r, M.g, M.b, Y)
    };
    this.setClearColorHex = function (a, b) {
        console.warn("DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.");
        this.setClearColor(a, b)
    };
    this.getClearColor = function () {
        return M
    };
    this.getClearAlpha = function () {
        return Y
    };
    this.clear = function (a, b, c) {
        var d = 0;
        if (void 0 === a || a) d |= q.COLOR_BUFFER_BIT;
        if (void 0 === b || b) d |= q.DEPTH_BUFFER_BIT;
        if (void 0 === c || c) d |= q.STENCIL_BUFFER_BIT;
        q.clear(d)
    };
    this.clearColor = function () {
        q.clear(q.COLOR_BUFFER_BIT)
    };
    this.clearDepth = function () {
        q.clear(q.DEPTH_BUFFER_BIT)
    };
    this.clearStencil = function () {
        q.clear(q.STENCIL_BUFFER_BIT)
    };
    this.clearTarget = function (a, b, c, d) {
        this.setRenderTarget(a);
        this.clear(b, c, d)
    };
    this.addPostPlugin = function (a) {
        a.init(this);
        this.renderPluginsPost.push(a)
    };
    this.addPrePlugin = function (a) {
        a.init(this);
        this.renderPluginsPre.push(a)
    };
    this.updateShadowMap = function (a, b) {
        ca = null;
        aa = ga = Va = Ua = Aa = -1;
        Pa = !0;
        Ja = ma = -1;
        this.shadowMapPlugin.update(a, b)
    };
    var tb = function (a) {
            a = a.target;
            a.removeEventListener("dispose", tb);
            a.__webglInit = void 0;
            if (a instanceof THREE.BufferGeometry) {
                void 0 !== a.vbbuffer && q.deleteBuffer(a.vbbuffer);
                var b = a.attributes,
                    c;
                for (c in b) void 0 !== b[c].buffer &&
                    q.deleteBuffer(b[c].buffer);
                S.info.memory.geometries--
            } else if (void 0 !== a.geometryGroups)
                for (b in a.geometryGroups) vb(a.geometryGroups[b]);
            else vb(a)
        },
        eb = function (a) {
            a = a.target;
            a.removeEventListener("dispose", eb);
            a.image && a.image.__webglTextureCube ? q.deleteTexture(a.image.__webglTextureCube) : a.__webglInit && (a.__webglInit = !1, q.deleteTexture(a.__webglTexture));
            S.info.memory.textures--
        },
        fb = function (a) {
            a = a.target;
            a.removeEventListener("dispose", fb);
            a && a.__webglTexture && (q.deleteTexture(a.__webglTexture),
                q.deleteFramebuffer(a.__webglFramebuffer), q.deleteRenderbuffer(a.__webglRenderbuffer));
            S.info.memory.textures--
        },
        wb = function (a) {
            a = a.target;
            a.removeEventListener("dispose", wb);
            ub(a)
        },
        vb = function (a) {
            void 0 !== a.__webglVertexBuffer && q.deleteBuffer(a.__webglVertexBuffer);
            void 0 !== a.__webglNormalBuffer && q.deleteBuffer(a.__webglNormalBuffer);
            void 0 !== a.__webglTangentBuffer && q.deleteBuffer(a.__webglTangentBuffer);
            void 0 !== a.__webglColorBuffer && q.deleteBuffer(a.__webglColorBuffer);
            void 0 !== a.__webglUVBuffer &&
                q.deleteBuffer(a.__webglUVBuffer);
            void 0 !== a.__webglUV2Buffer && q.deleteBuffer(a.__webglUV2Buffer);
            void 0 !== a.__webglSkinIndicesBuffer && q.deleteBuffer(a.__webglSkinIndicesBuffer);
            void 0 !== a.__webglSkinWeightsBuffer && q.deleteBuffer(a.__webglSkinWeightsBuffer);
            void 0 !== a.__webglFaceBuffer && q.deleteBuffer(a.__webglFaceBuffer);
            void 0 !== a.__webglLineBuffer && q.deleteBuffer(a.__webglLineBuffer);
            void 0 !== a.__webglLineDistanceBuffer && q.deleteBuffer(a.__webglLineDistanceBuffer);
            if (void 0 !== a.__webglCustomAttributesList)
                for (var b in a.__webglCustomAttributesList) q.deleteBuffer(a.__webglCustomAttributesList[b].buffer);
            S.info.memory.geometries--
        },
        ub = function (a) {
            var b = a.program;
            if (void 0 !== b) {
                a.program = void 0;
                var c, d, e = !1;
                a = 0;
                for (c = X.length; a < c; a++)
                    if (d = X[a], d.program === b) {
                        d.usedTimes--;
                        0 === d.usedTimes && (e = !0);
                        break
                    }
                if (!0 === e) {
                    e = [];
                    a = 0;
                    for (c = X.length; a < c; a++) d = X[a], d.program !== b && e.push(d);
                    X = e;
                    q.deleteProgram(b);
                    S.info.memory.programs--
                }
            }
        };
    this.renderBufferDirect = function (a, b, c, d, e, k) {
        if (!1 !== d.visible) {
            var l = v(a, b, c, d, k);
            a = l.attributes;
            c = e.attributes;
            b = !1;
            l = 16777215 * e.id + 2 * l.id + (d.wireframe ? 1 : 0);
            l !== ga && (ga = l, b = !0);
            b && h();
            if (k instanceof THREE.Mesh)
                if (k = c.index) {
                    l = e.offsets;
                    1 < l.length && (b = !0);
                    for (var m = 0, n = l.length; m < n; m++) {
                        var p = l[m].index;
                        b && (g(d, a, e, p), !k.buffer && e.streamingDraw ? (p = za.index, p || (p = q.createBuffer(), za.index = p), q.bindBuffer(q.ELEMENT_ARRAY_BUFFER, p), q.bufferData(q.ELEMENT_ARRAY_BUFFER, k.array, q.STATIC_DRAW)) : q.bindBuffer(q.ELEMENT_ARRAY_BUFFER, k.buffer));
                        q.drawElements(q.TRIANGLES, l[m].count, q.UNSIGNED_SHORT, 2 * l[m].start)
                    }
                } else b && g(d, a, e, p), d = e.attributes.position, q.drawArrays(q.TRIANGLES,
                    0, d.array.length / 3);
            else if (k instanceof THREE.Line)
                if (p = k.type === THREE.LineStrip ? q.LINE_STRIP : q.LINES, A(d.linewidth), k = c.index)
                    for (l = e.offsets, 1 < l.length && (b = !0), m = 0, n = l.length; m < n; m++) p = l[m].index, b && (f(d, a, c, p), q.bindBuffer(q.ELEMENT_ARRAY_BUFFER, k.buffer)), q.drawElements(q.LINES, l[m].count, q.UNSIGNED_SHORT, 2 * l[m].start);
                else b && f(d, a, c, 0), d = c.position, q.drawArrays(p, 0, d.array.length / 3)
        }
    };
    this.renderBuffer = function (a, b, c, d, e, f) {
        if (!1 !== d.visible) {
            var g, l;
            c = v(a, b, c, d, f);
            a = c.attributes;
            b = !1;
            c = 16777215 *
                e.id + 2 * c.id + (d.wireframe ? 1 : 0);
            c !== ga && (ga = c, b = !0);
            b && h();
            !d.morphTargets && 0 <= a.position && b && (q.bindBuffer(q.ARRAY_BUFFER, e.__webglVertexBuffer), k(a.position), q.vertexAttribPointer(a.position, 3, q.FLOAT, !1, 0, 0));
            if (b) {
                if (e.__webglCustomAttributesList)
                    for (g = 0, l = e.__webglCustomAttributesList.length; g < l; g++) c = e.__webglCustomAttributesList[g], 0 <= a[c.buffer.belongsToAttribute] && (q.bindBuffer(q.ARRAY_BUFFER, c.buffer), k(a[c.buffer.belongsToAttribute]), q.vertexAttribPointer(a[c.buffer.belongsToAttribute], c.size,
                        q.FLOAT, !1, 0, 0));
                0 <= a.color && (0 < f.geometry.colors.length || 0 < f.geometry.faces.length ? (q.bindBuffer(q.ARRAY_BUFFER, e.__webglColorBuffer), k(a.color), q.vertexAttribPointer(a.color, 3, q.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && q.vertexAttrib3fv(a.color, d.defaultAttributeValues.color));
                0 <= a.normal && (q.bindBuffer(q.ARRAY_BUFFER, e.__webglNormalBuffer), k(a.normal), q.vertexAttribPointer(a.normal, 3, q.FLOAT, !1, 0, 0));
                0 <= a.tangent && (q.bindBuffer(q.ARRAY_BUFFER, e.__webglTangentBuffer), k(a.tangent), q.vertexAttribPointer(a.tangent,
                    4, q.FLOAT, !1, 0, 0));
                0 <= a.uv && (f.geometry.faceVertexUvs[0] ? (q.bindBuffer(q.ARRAY_BUFFER, e.__webglUVBuffer), k(a.uv), q.vertexAttribPointer(a.uv, 2, q.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && q.vertexAttrib2fv(a.uv, d.defaultAttributeValues.uv));
                0 <= a.uv2 && (f.geometry.faceVertexUvs[1] ? (q.bindBuffer(q.ARRAY_BUFFER, e.__webglUV2Buffer), k(a.uv2), q.vertexAttribPointer(a.uv2, 2, q.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && q.vertexAttrib2fv(a.uv2, d.defaultAttributeValues.uv2));
                0 <= a.lineDistance && (q.bindBuffer(q.ARRAY_BUFFER,
                    e.__webglLineDistanceBuffer), k(a.lineDistance), q.vertexAttribPointer(a.lineDistance, 1, q.FLOAT, !1, 0, 0))
            }
            f instanceof THREE.Mesh ? d.wireframe ? (A(d.wireframeLinewidth), b && q.bindBuffer(q.ELEMENT_ARRAY_BUFFER, e.__webglLineBuffer), q.drawElements(q.LINES, e.__webglLineCount, q.UNSIGNED_SHORT, 0)) : (b && q.bindBuffer(q.ELEMENT_ARRAY_BUFFER, e.__webglFaceBuffer), q.drawElements(q.TRIANGLES, e.__webglFaceCount, q.UNSIGNED_SHORT, 0)) : f instanceof THREE.Line && (f = f.type === THREE.LineStrip ? q.LINE_STRIP : q.LINES, A(d.linewidth),
                q.drawArrays(f, 0, e.__webglLineCount))
        }
    };
    this.render = function (a, b, c, d) {
        if (!1 === b instanceof THREE.Camera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        else {
            var e, f, g, h, k = a.__lights,
                p = a.fog;
            aa = -1;
            Pa = !0;
            !0 === a.autoUpdate && a.updateMatrixWorld();
            void 0 === b.parent && b.updateMatrixWorld();
            b.matrixWorldInverse.getInverse(b.matrixWorld);
            ta.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
            Wa.setFromMatrix(ta);
            this.autoUpdateObjects && this.initWebGLObjects(a);
            m(this.renderPluginsPre, a, b);
            this.setRenderTarget(c);
            (this.autoClear || d) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
            h = a.__webglObjects;
            d = 0;
            for (e = h.length; d < e; d++)
                if (f = h[d], g = f.object, f.id = d, f.render = !1, g.visible && (!(g instanceof THREE.Mesh && g.frustumCulled) || Wa.intersectsObject(g))) {
                    var r = g;
                    r._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse, r.matrixWorld);
                    r._normalMatrix.getNormalMatrix(r._modelViewMatrix);
                    var r = f,
                        s = r.object,
                        t = r.buffer,
                        u = s.geometry,
                        s = s.material;
                    s instanceof THREE.MeshFaceMaterial ? (s = s.materials[u instanceof THREE.BufferGeometry ? 0 : t.materialIndex], s.transparent ? (r.transparent = s, r.opaque = null) : (r.opaque = s, r.transparent = null)) : s && (s.transparent ? (r.transparent = s, r.opaque = null) : (r.opaque = s, r.transparent = null));
                    f.render = !0;
                    !0 === this.sortObjects && (null !== g.renderDepth ? f.z = g.renderDepth : (da.setFromMatrixPosition(g.matrixWorld), da.applyProjection(ta), f.z = da.z))
                }
            this.sortObjects && h.sort(l);
            a.overrideMaterial ? (d = a.overrideMaterial, this.setBlending(d.blending,
                d.blendEquation, d.blendSrc, d.blendDst), this.setDepthTest(d.depthTest), this.setDepthWrite(d.depthWrite), N(d.polygonOffset, d.polygonOffsetFactor, d.polygonOffsetUnits), n(a.__webglObjects, !1, "", b, k, p, !0, d)) : (d = null, this.setBlending(THREE.NoBlending), n(a.__webglObjects, !0, "opaque", b, k, p, !1, d), n(a.__webglObjects, !1, "transparent", b, k, p, !0, d));
            m(this.renderPluginsPost, a, b);
            c && c.generateMipmaps && c.minFilter !== THREE.NearestFilter && c.minFilter !== THREE.LinearFilter && (q.bindTexture(q.TEXTURE_2D, c.__webglTexture),
                q.generateMipmap(q.TEXTURE_2D), q.bindTexture(q.TEXTURE_2D, null));
            this.setDepthTest(!0);
            this.setDepthWrite(!0)
        }
    };
    this.endFrame = function () {};
    this.initWebGLObjects = function (a) {
        a.__webglObjects || (a.__webglObjects = []);
        for (; a.__objectsAdded.length;) r(a.__objectsAdded[0], a), a.__objectsAdded.splice(0, 1);
        for (; a.__objectsRemoved.length;) u(a.__objectsRemoved[0], a), a.__objectsRemoved.splice(0, 1);
        for (var f = 0, g = a.__webglObjects.length; f < g; f++) {
            var h = a.__webglObjects[f].object;
            void 0 === h.__webglInit && (void 0 !==
                h.__webglActive && u(h, a), r(h, a));
            var k = h,
                l = k.geometry,
                m = void 0,
                n = void 0,
                s = void 0;
            if (l instanceof THREE.BufferGeometry) {
                var x = l,
                    v = q.DYNAMIC_DRAW,
                    w = l.freeCPUBuffers;
                if (!x.streamingDraw) {
                    var A = x.attributes,
                        y = !1,
                        B = void 0,
                        z = void 0;
                    for (B in A) z = A[B], z.needsUpdate && ("index" === B ? (q.bindBuffer(q.ELEMENT_ARRAY_BUFFER, z.buffer), q.bufferData(q.ELEMENT_ARRAY_BUFFER, z.array, v)) : z.array ? (q.bindBuffer(q.ARRAY_BUFFER, z.buffer), q.bufferData(q.ARRAY_BUFFER, z.array, v)) : y = !0, z.needsUpdate = !1), w && z.freeCPUBuffers && (z.array =
                        null);
                    y && (q.bindBuffer(q.ARRAY_BUFFER, x.vbbuffer), q.bufferData(q.ARRAY_BUFFER, x.vb, v), w && x.freeCPUBuffers && (x.vb = null))
                }
            } else if (k instanceof THREE.Mesh) {
                for (var G = 0, N = l.geometryGroupsList.length; G < N; G++)
                    if (m = l.geometryGroupsList[G], s = c(k, m), l.buffersNeedUpdate && b(m, k), n = s.attributes && t(s), l.verticesNeedUpdate || l.morphTargetsNeedUpdate || l.elementsNeedUpdate || l.uvsNeedUpdate || l.normalsNeedUpdate || l.colorsNeedUpdate || l.tangentsNeedUpdate || n) {
                        var C = m,
                            F = k,
                            J = q.DYNAMIC_DRAW,
                            K = l.freeCPUBuffers,
                            O = s;
                        if (C.__inittedArrays) {
                            var P =
                                e(O),
                                Q = O.vertexColors ? O.vertexColors : !1,
                                T = d(O),
                                R = P === THREE.SmoothShading,
                                D = void 0,
                                I = void 0,
                                S = void 0,
                                M = void 0,
                                U = void 0,
                                X = void 0,
                                Y = void 0,
                                aa = void 0,
                                ba = void 0,
                                ca = void 0,
                                da = void 0,
                                Z = void 0,
                                W = void 0,
                                V = void 0,
                                ea = void 0,
                                ga = void 0,
                                ia = void 0,
                                na = void 0,
                                oa = void 0,
                                pa = void 0,
                                ua = void 0,
                                sa = void 0,
                                ta = void 0,
                                wa = void 0,
                                ya = void 0,
                                la = 0,
                                ma = 0,
                                xa = 0,
                                za = 0,
                                Ba = 0,
                                qa = 0,
                                Ea = 0,
                                va = 0,
                                La = 0,
                                H = 0,
                                Da = void 0,
                                Na = C.__vertexArray,
                                Ga = C.__uvArray,
                                Ja = C.__uv2Array,
                                Aa = C.__normalArray,
                                Ha = C.__tangentArray,
                                Oa = C.__colorArray,
                                Ka = C.__webglCustomAttributesList,
                                E = void 0,
                                Fa = C.__faceArray,
                                Ya = C.__lineArray,
                                Ma = F.geometry,
                                Ra = Ma.elementsNeedUpdate,
                                Pa = Ma.uvsNeedUpdate,
                                Sa = Ma.normalsNeedUpdate,
                                Ua = Ma.tangentsNeedUpdate,
                                Va = Ma.colorsNeedUpdate,
                                Qa = Ma.vertices,
                                fa = C.faces3,
                                Ta = Ma.faces,
                                Wa = Ma.faceVertexUvs[0],
                                Xa = Ma.faceVertexUvs[1];
                            if (Ma.verticesNeedUpdate) {
                                D = 0;
                                for (I = fa.length; D < I; D++) M = Ta[fa[D]], Z = Qa[M.a], W = Qa[M.b], V = Qa[M.c], Na[ma] = Z.x, Na[ma + 1] = Z.y, Na[ma + 2] = Z.z, Na[ma + 3] = W.x, Na[ma + 4] = W.y, Na[ma + 5] = W.z, Na[ma + 6] = V.x, Na[ma + 7] = V.y, Na[ma + 8] = V.z, ma += 9;
                                q.bindBuffer(q.ARRAY_BUFFER,
                                    C.__webglVertexBuffer);
                                q.bufferData(q.ARRAY_BUFFER, Na, J)
                            }
                            if (Va && Q) {
                                D = 0;
                                for (I = fa.length; D < I; D++) M = Ta[fa[D]], Y = M.vertexColors, aa = M.color, 3 === Y.length && Q === THREE.VertexColors ? (na = Y[0], oa = Y[1], pa = Y[2]) : pa = oa = na = aa, Oa[La] = na.r, Oa[La + 1] = na.g, Oa[La + 2] = na.b, Oa[La + 3] = oa.r, Oa[La + 4] = oa.g, Oa[La + 5] = oa.b, Oa[La + 6] = pa.r, Oa[La + 7] = pa.g, Oa[La + 8] = pa.b, La += 9;
                                0 < La && (q.bindBuffer(q.ARRAY_BUFFER, C.__webglColorBuffer), q.bufferData(q.ARRAY_BUFFER, Oa, J))
                            }
                            if (Ua && Ma.hasTangents) {
                                D = 0;
                                for (I = fa.length; D < I; D++) M = Ta[fa[D]], ba = M.vertexTangents,
                                    ea = ba[0], ga = ba[1], ia = ba[2], Ha[Ea] = ea.x, Ha[Ea + 1] = ea.y, Ha[Ea + 2] = ea.z, Ha[Ea + 3] = ea.w, Ha[Ea + 4] = ga.x, Ha[Ea + 5] = ga.y, Ha[Ea + 6] = ga.z, Ha[Ea + 7] = ga.w, Ha[Ea + 8] = ia.x, Ha[Ea + 9] = ia.y, Ha[Ea + 10] = ia.z, Ha[Ea + 11] = ia.w, Ea += 12;
                                q.bindBuffer(q.ARRAY_BUFFER, C.__webglTangentBuffer);
                                q.bufferData(q.ARRAY_BUFFER, Ha, J)
                            }
                            if (Sa && P) {
                                D = 0;
                                for (I = fa.length; D < I; D++)
                                    if (M = Ta[fa[D]], U = M.vertexNormals, X = M.normal, 3 === U.length && R)
                                        for (ua = 0; 3 > ua; ua++) ta = U[ua], Aa[qa] = ta.x, Aa[qa + 1] = ta.y, Aa[qa + 2] = ta.z, qa += 3;
                                    else
                                        for (ua = 0; 3 > ua; ua++) Aa[qa] = X.x, Aa[qa +
                                            1] = X.y, Aa[qa + 2] = X.z, qa += 3;
                                q.bindBuffer(q.ARRAY_BUFFER, C.__webglNormalBuffer);
                                q.bufferData(q.ARRAY_BUFFER, Aa, J)
                            }
                            if (Pa && Wa && T) {
                                D = 0;
                                for (I = fa.length; D < I; D++)
                                    if (S = fa[D], ca = Wa[S], void 0 !== ca)
                                        for (ua = 0; 3 > ua; ua++) wa = ca[ua], Ga[xa] = wa.x, Ga[xa + 1] = wa.y, xa += 2;
                                0 < xa && (q.bindBuffer(q.ARRAY_BUFFER, C.__webglUVBuffer), q.bufferData(q.ARRAY_BUFFER, Ga, J))
                            }
                            if (Pa && Xa && T) {
                                D = 0;
                                for (I = fa.length; D < I; D++)
                                    if (S = fa[D], da = Xa[S], void 0 !== da)
                                        for (ua = 0; 3 > ua; ua++) ya = da[ua], Ja[za] = ya.x, Ja[za + 1] = ya.y, za += 2;
                                0 < za && (q.bindBuffer(q.ARRAY_BUFFER,
                                    C.__webglUV2Buffer), q.bufferData(q.ARRAY_BUFFER, Ja, J))
                            }
                            if (Ra) {
                                D = 0;
                                for (I = fa.length; D < I; D++) Fa[Ba] = la, Fa[Ba + 1] = la + 1, Fa[Ba + 2] = la + 2, Ba += 3, Ya[va] = la, Ya[va + 1] = la + 1, Ya[va + 2] = la, Ya[va + 3] = la + 2, Ya[va + 4] = la + 1, Ya[va + 5] = la + 2, va += 6, la += 3;
                                q.bindBuffer(q.ELEMENT_ARRAY_BUFFER, C.__webglFaceBuffer);
                                q.bufferData(q.ELEMENT_ARRAY_BUFFER, Fa, J);
                                q.bindBuffer(q.ELEMENT_ARRAY_BUFFER, C.__webglLineBuffer);
                                q.bufferData(q.ELEMENT_ARRAY_BUFFER, Ya, J)
                            }
                            if (Ka)
                                for (ua = 0, sa = Ka.length; ua < sa; ua++)
                                    if (E = Ka[ua], E.__original.needsUpdate) {
                                        H =
                                            0;
                                        if (1 === E.size)
                                            if (void 0 === E.boundTo || "vertices" === E.boundTo)
                                                for (D = 0, I = fa.length; D < I; D++) M = Ta[fa[D]], E.array[H] = E.value[M.a], E.array[H + 1] = E.value[M.b], E.array[H + 2] = E.value[M.c], H += 3;
                                            else {
                                                if ("faces" === E.boundTo)
                                                    for (D = 0, I = fa.length; D < I; D++) Da = E.value[fa[D]], E.array[H] = Da, E.array[H + 1] = Da, E.array[H + 2] = Da, H += 3
                                            } else if (2 === E.size)
                                            if (void 0 === E.boundTo || "vertices" === E.boundTo)
                                                for (D = 0, I = fa.length; D < I; D++) M = Ta[fa[D]], Z = E.value[M.a], W = E.value[M.b], V = E.value[M.c], E.array[H] = Z.x, E.array[H + 1] = Z.y, E.array[H + 2] =
                                                    W.x, E.array[H + 3] = W.y, E.array[H + 4] = V.x, E.array[H + 5] = V.y, H += 6;
                                            else {
                                                if ("faces" === E.boundTo)
                                                    for (D = 0, I = fa.length; D < I; D++) V = W = Z = Da = E.value[fa[D]], E.array[H] = Z.x, E.array[H + 1] = Z.y, E.array[H + 2] = W.x, E.array[H + 3] = W.y, E.array[H + 4] = V.x, E.array[H + 5] = V.y, H += 6
                                            } else if (3 === E.size) {
                                            var ka;
                                            ka = "c" === E.type ? ["r", "g", "b"] : ["x", "y", "z"];
                                            if (void 0 === E.boundTo || "vertices" === E.boundTo)
                                                for (D = 0, I = fa.length; D < I; D++) M = Ta[fa[D]], Z = E.value[M.a], W = E.value[M.b], V = E.value[M.c], E.array[H] = Z[ka[0]], E.array[H + 1] = Z[ka[1]], E.array[H + 2] =
                                                    Z[ka[2]], E.array[H + 3] = W[ka[0]], E.array[H + 4] = W[ka[1]], E.array[H + 5] = W[ka[2]], E.array[H + 6] = V[ka[0]], E.array[H + 7] = V[ka[1]], E.array[H + 8] = V[ka[2]], H += 9;
                                            else if ("faces" === E.boundTo)
                                                for (D = 0, I = fa.length; D < I; D++) V = W = Z = Da = E.value[fa[D]], E.array[H] = Z[ka[0]], E.array[H + 1] = Z[ka[1]], E.array[H + 2] = Z[ka[2]], E.array[H + 3] = W[ka[0]], E.array[H + 4] = W[ka[1]], E.array[H + 5] = W[ka[2]], E.array[H + 6] = V[ka[0]], E.array[H + 7] = V[ka[1]], E.array[H + 8] = V[ka[2]], H += 9;
                                            else if ("faceVertices" === E.boundTo)
                                                for (D = 0, I = fa.length; D < I; D++) Da = E.value[fa[D]],
                                                    Z = Da[0], W = Da[1], V = Da[2], E.array[H] = Z[ka[0]], E.array[H + 1] = Z[ka[1]], E.array[H + 2] = Z[ka[2]], E.array[H + 3] = W[ka[0]], E.array[H + 4] = W[ka[1]], E.array[H + 5] = W[ka[2]], E.array[H + 6] = V[ka[0]], E.array[H + 7] = V[ka[1]], E.array[H + 8] = V[ka[2]], H += 9
                                        } else if (4 === E.size)
                                            if (void 0 === E.boundTo || "vertices" === E.boundTo)
                                                for (D = 0, I = fa.length; D < I; D++) M = Ta[fa[D]], Z = E.value[M.a], W = E.value[M.b], V = E.value[M.c], E.array[H] = Z.x, E.array[H + 1] = Z.y, E.array[H + 2] = Z.z, E.array[H + 3] = Z.w, E.array[H + 4] = W.x, E.array[H + 5] = W.y, E.array[H + 6] = W.z, E.array[H +
                                                    7] = W.w, E.array[H + 8] = V.x, E.array[H + 9] = V.y, E.array[H + 10] = V.z, E.array[H + 11] = V.w, H += 12;
                                            else if ("faces" === E.boundTo)
                                            for (D = 0, I = fa.length; D < I; D++) V = W = Z = Da = E.value[fa[D]], E.array[H] = Z.x, E.array[H + 1] = Z.y, E.array[H + 2] = Z.z, E.array[H + 3] = Z.w, E.array[H + 4] = W.x, E.array[H + 5] = W.y, E.array[H + 6] = W.z, E.array[H + 7] = W.w, E.array[H + 8] = V.x, E.array[H + 9] = V.y, E.array[H + 10] = V.z, E.array[H + 11] = V.w, H += 12;
                                        else if ("faceVertices" === E.boundTo)
                                            for (D = 0, I = fa.length; D < I; D++) Da = E.value[fa[D]], Z = Da[0], W = Da[1], V = Da[2], E.array[H] = Z.x, E.array[H +
                                                1] = Z.y, E.array[H + 2] = Z.z, E.array[H + 3] = Z.w, E.array[H + 4] = W.x, E.array[H + 5] = W.y, E.array[H + 6] = W.z, E.array[H + 7] = W.w, E.array[H + 8] = V.x, E.array[H + 9] = V.y, E.array[H + 10] = V.z, E.array[H + 11] = V.w, H += 12;
                                        q.bindBuffer(q.ARRAY_BUFFER, E.buffer);
                                        q.bufferData(q.ARRAY_BUFFER, E.array, J)
                                    }
                            K && (delete C.__inittedArrays, delete C.__colorArray, delete C.__normalArray, delete C.__tangentArray, delete C.__uvArray, delete C.__uv2Array, delete C.__faceArray, delete C.__vertexArray, delete C.__lineArray, delete C.__skinIndexArray, delete C.__skinWeightArray)
                        }
                    }
                l.verticesNeedUpdate = !1;
                l.morphTargetsNeedUpdate = !1;
                l.elementsNeedUpdate = !1;
                l.uvsNeedUpdate = !1;
                l.normalsNeedUpdate = !1;
                l.colorsNeedUpdate = !1;
                l.tangentsNeedUpdate = !1;
                l.buffersNeedUpdate = !1;
                s.attributes && p(s)
            } else if (k instanceof THREE.Line) {
                s = c(k, l);
                n = s.attributes && t(s);
                if (l.verticesNeedUpdate || l.colorsNeedUpdate || l.lineDistancesNeedUpdate || n) {
                    var Ia = l,
                        mb = q.DYNAMIC_DRAW,
                        gb = void 0,
                        hb = void 0,
                        ib = void 0,
                        nb = void 0,
                        ja = void 0,
                        ob = void 0,
                        Za = Ia.vertices,
                        $a = Ia.colors,
                        ab = Ia.lineDistances,
                        eb = Za.length,
                        fb = $a.length,
                        jb = ab.length,
                        pb = Ia.__vertexArray,
                        qb = Ia.__colorArray,
                        cb = Ia.__lineDistanceArray,
                        kb = Ia.colorsNeedUpdate,
                        lb = Ia.lineDistancesNeedUpdate,
                        sb = Ia.__webglCustomAttributesList,
                        rb = void 0,
                        db = void 0,
                        ra = void 0,
                        bb = void 0,
                        Ca = void 0,
                        ha = void 0;
                    if (Ia.verticesNeedUpdate) {
                        for (gb = 0; gb < eb; gb++) nb = Za[gb], ja = 3 * gb, pb[ja] = nb.x, pb[ja + 1] = nb.y, pb[ja + 2] = nb.z;
                        q.bindBuffer(q.ARRAY_BUFFER, Ia.__webglVertexBuffer);
                        q.bufferData(q.ARRAY_BUFFER, pb, mb)
                    }
                    if (kb) {
                        for (hb = 0; hb < fb; hb++) ob = $a[hb], ja = 3 * hb, qb[ja] = ob.r, qb[ja + 1] = ob.g, qb[ja + 2] = ob.b;
                        q.bindBuffer(q.ARRAY_BUFFER, Ia.__webglColorBuffer);
                        q.bufferData(q.ARRAY_BUFFER, qb, mb)
                    }
                    if (lb) {
                        for (ib = 0; ib < jb; ib++) cb[ib] = ab[ib];
                        q.bindBuffer(q.ARRAY_BUFFER, Ia.__webglLineDistanceBuffer);
                        q.bufferData(q.ARRAY_BUFFER, cb, mb)
                    }
                    if (sb)
                        for (rb = 0, db = sb.length; rb < db; rb++)
                            if (ha = sb[rb], ha.needsUpdate && (void 0 === ha.boundTo || "vertices" === ha.boundTo)) {
                                ja = 0;
                                bb = ha.value.length;
                                if (1 === ha.size)
                                    for (ra = 0; ra < bb; ra++) ha.array[ra] = ha.value[ra];
                                else if (2 === ha.size)
                                    for (ra = 0; ra < bb; ra++) Ca = ha.value[ra], ha.array[ja] = Ca.x, ha.array[ja + 1] = Ca.y, ja += 2;
                                else if (3 === ha.size)
                                    if ("c" === ha.type)
                                        for (ra =
                                            0; ra < bb; ra++) Ca = ha.value[ra], ha.array[ja] = Ca.r, ha.array[ja + 1] = Ca.g, ha.array[ja + 2] = Ca.b, ja += 3;
                                    else
                                        for (ra = 0; ra < bb; ra++) Ca = ha.value[ra], ha.array[ja] = Ca.x, ha.array[ja + 1] = Ca.y, ha.array[ja + 2] = Ca.z, ja += 3;
                                else if (4 === ha.size)
                                    for (ra = 0; ra < bb; ra++) Ca = ha.value[ra], ha.array[ja] = Ca.x, ha.array[ja + 1] = Ca.y, ha.array[ja + 2] = Ca.z, ha.array[ja + 3] = Ca.w, ja += 4;
                                q.bindBuffer(q.ARRAY_BUFFER, ha.buffer);
                                q.bufferData(q.ARRAY_BUFFER, ha.array, mb)
                            }
                }
                l.verticesNeedUpdate = !1;
                l.colorsNeedUpdate = !1;
                l.lineDistancesNeedUpdate = !1;
                s.attributes &&
                    p(s)
            }
        }
    };
    this.initMaterial = function (a, b, c, d) {
        a.addEventListener("dispose", wb);
        var e, f;
        a instanceof THREE.MeshDepthMaterial ? f = "depth" : a instanceof THREE.MeshNormalMaterial ? f = "normal" : a instanceof THREE.MeshBasicMaterial ? f = "basic" : a instanceof THREE.MeshLambertMaterial ? f = "lambert" : a instanceof THREE.MeshPhongMaterial ? f = "phong" : a instanceof THREE.LineBasicMaterial ? f = "basic" : a instanceof THREE.LineDashedMaterial && (f = "dashed");
        if (f) {
            var g = THREE.ShaderLib[f];
            a.uniforms = THREE.UniformsUtils.clone(g.uniforms);
            a.vertexShader = g.vertexShader;
            a.fragmentShader = g.fragmentShader
        }
        for (var h = 0, k = 0, l = 0, m = 0, g = 0, n = b.length; g < n; g++) {
            var p = b[g];
            p.onlyShadow || (p instanceof THREE.DirectionalLight && h++, p instanceof THREE.PointLight && k++, p instanceof THREE.SpotLight && l++, p instanceof THREE.HemisphereLight && m++)
        }
        for (var r = 0, g = 0, n = b.length; g < n; g++) p = b[g], p.castShadow && (p instanceof THREE.SpotLight && r++, p instanceof THREE.DirectionalLight && !p.shadowCascade && r++);
        var s;
        a: {
            n = a.fragmentShader;
            p = a.vertexShader;
            g = a.uniforms;
            b = a.attributes;
            var t = a.defines;
            d = {
                map: !!a.map,
                envMap: !!a.envMap,
                envIsSpherical: a.envMap && a.envMap.mapping instanceof THREE.SphericalReflectionMapping,
                lightMap: !!a.lightMap,
                bumpMap: Qa && !!a.bumpMap,
                normalMap: Qa && !!a.normalMap,
                specularMap: !!a.specularMap,
                vertexColors: a.vertexColors,
                fog: c,
                useFog: a.fog,
                fogExp: c instanceof THREE.FogExp2,
                sizeAttenuation: a.sizeAttenuation,
                skinning: a.skinning,
                maxBones: 0,
                useVertexTexture: yb && d && d.useVertexTexture,
                morphTargets: a.morphTargets,
                morphNormals: a.morphNormals,
                maxMorphTargets: this.maxMorphTargets,
                maxMorphNormals: this.maxMorphNormals,
                maxDirLights: h,
                maxPointLights: k,
                maxSpotLights: l,
                maxHemiLights: m,
                maxShadows: r,
                shadowMapEnabled: this.shadowMapEnabled && d.receiveShadow,
                shadowMapType: this.shadowMapType,
                shadowMapDebug: this.shadowMapDebug,
                shadowMapCascade: this.shadowMapCascade,
                alphaTest: a.alphaTest,
                metal: a.metal,
                wrapAround: a.wrapAround,
                doubleSided: a.side === THREE.DoubleSide,
                flipSided: a.side === THREE.BackSide,
                mrtNormals: qa && a.mrtNormals
            };
            c = a.index0AttributeName;
            var u, x, v, h = [];
            f ? h.push(f) : (h.push(n), h.push(p));
            for (x in t) h.push(x), h.push(t[x]);
            for (u in d) h.push(u), h.push(d[u]);
            f = h.join();
            u = 0;
            for (x = X.length; u < x; u++)
                if (h = X[u], h.code === f) {
                    h.usedTimes++;
                    s = h.program;
                    break a
                }
            u = "SHADOWMAP_TYPE_BASIC";
            d.shadowMapType === THREE.PCFShadowMap ? u = "SHADOWMAP_TYPE_PCF" : d.shadowMapType === THREE.PCFSoftShadowMap && (u = "SHADOWMAP_TYPE_PCF_SOFT");
            x = [];
            for (v in t) h = t[v], !1 !== h && (h = "#define " + v + " " + h, x.push(h));
            t = x.join("\n");
            v = q.createProgram();
            x = ["precision " + O + " float;", "precision " + O + " int;", t, $a ? "#define VERTEX_TEXTURES" : "",
                S.gammaInput ? "#define GAMMA_INPUT" : "", S.gammaOutput ? "#define GAMMA_OUTPUT" : "", d.mrtNormals ? "#define MRT_NORMALS" : "", "#define MAX_DIR_LIGHTS " + d.maxDirLights, "#define MAX_POINT_LIGHTS " + d.maxPointLights, "#define MAX_SPOT_LIGHTS " + d.maxSpotLights, "#define MAX_HEMI_LIGHTS " + d.maxHemiLights, "#define MAX_SHADOWS " + d.maxShadows, "#define MAX_BONES " + d.maxBones, d.map ? "#define USE_MAP" : "", d.envMap ? "#define USE_ENVMAP" : "", d.envIsSpherical ? "#define SPHERICAL_ENV" : "", d.lightMap ? "#define USE_LIGHTMAP" : "", d.bumpMap ?
                "#define USE_BUMPMAP" : "", d.normalMap ? "#define USE_NORMALMAP" : "", d.specularMap ? "#define USE_SPECULARMAP" : "", d.vertexColors ? "#define USE_COLOR" : "", d.skinning ? "#define USE_SKINNING" : "", d.useVertexTexture ? "#define BONE_TEXTURE" : "", d.morphTargets ? "#define USE_MORPHTARGETS" : "", d.morphNormals ? "#define USE_MORPHNORMALS" : "", d.wrapAround ? "#define WRAP_AROUND" : "", d.doubleSided ? "#define DOUBLE_SIDED" : "", d.flipSided ? "#define FLIP_SIDED" : "", d.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", d.shadowMapEnabled ? "#define " +
                u : "", d.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", d.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", d.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", "uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#ifdef USE_COLOR\nattribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\nattribute vec3 morphTarget0;\nattribute vec3 morphTarget1;\nattribute vec3 morphTarget2;\nattribute vec3 morphTarget3;\n#ifdef USE_MORPHNORMALS\nattribute vec3 morphNormal0;\nattribute vec3 morphNormal1;\nattribute vec3 morphNormal2;\nattribute vec3 morphNormal3;\n#else\nattribute vec3 morphTarget4;\nattribute vec3 morphTarget5;\nattribute vec3 morphTarget6;\nattribute vec3 morphTarget7;\n#endif\n#endif\n#ifdef USE_SKINNING\nattribute vec4 skinIndex;\nattribute vec4 skinWeight;\n#endif\n"
            ].join("\n");
            u = ["precision " + O + " float;", "precision " + O + " int;", d.bumpMap || d.normalMap ? "#extension GL_OES_standard_derivatives : enable" : "", t, "#define MAX_DIR_LIGHTS " + d.maxDirLights, "#define MAX_POINT_LIGHTS " + d.maxPointLights, "#define MAX_SPOT_LIGHTS " + d.maxSpotLights, "#define MAX_HEMI_LIGHTS " + d.maxHemiLights, "#define MAX_SHADOWS " + d.maxShadows, d.alphaTest ? "#define ALPHATEST " + d.alphaTest : "", d.mrtNormals ? "#define MRT_NORMALS" : "", S.gammaInput ? "#define GAMMA_INPUT" : "", S.gammaOutput ? "#define GAMMA_OUTPUT" : "",
                d.useFog && d.fog ? "#define USE_FOG" : "", d.useFog && d.fogExp ? "#define FOG_EXP2" : "", d.map ? "#define USE_MAP" : "", d.envMap ? "#define USE_ENVMAP" : "", d.envIsSpherical ? "#define SPHERICAL_ENV" : "", d.lightMap ? "#define USE_LIGHTMAP" : "", d.bumpMap ? "#define USE_BUMPMAP" : "", d.normalMap ? "#define USE_NORMALMAP" : "", d.specularMap ? "#define USE_SPECULARMAP" : "", d.vertexColors ? "#define USE_COLOR" : "", d.metal ? "#define METAL" : "", d.wrapAround ? "#define WRAP_AROUND" : "", d.doubleSided ? "#define DOUBLE_SIDED" : "", d.flipSided ? "#define FLIP_SIDED" :
                "", d.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", d.shadowMapEnabled ? "#define " + u : "", d.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", d.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", "uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n"
            ].join("\n");
            p = G("vertex", x + p);
            n = G("fragment", u + n);
            q.attachShader(v, p);
            q.attachShader(v, n);
            c && q.bindAttribLocation(v, 0, c);
            q.linkProgram(v);
            q.getProgramParameter(v, q.LINK_STATUS) || (console.error("Could not initialise shader\nVALIDATE_STATUS: " + q.getProgramParameter(v,
                q.VALIDATE_STATUS) + ", gl error [" + q.getError() + "]"), console.error("Program Info Log: " + q.getProgramInfoLog(v)));
            q.deleteShader(n);
            q.deleteShader(p);
            v.uniforms = {};
            v.attributes = {};
            var w, n = "viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition".split(" ");
            for (w in g) n.push(w);
            w = n;
            g = 0;
            for (n = w.length; g < n; g++) p = w[g], v.uniforms[p] = q.getUniformLocation(v, p);
            n = "position normal uv uv2 color lineDistance".split(" ");
            for (s in b) n.push(s);
            s = n;
            w = 0;
            for (b = s.length; w < b; w++) g = s[w], v.attributes[g] =
                q.getAttribLocation(v, g);
            v.id = K++;
            X.push({
                program: v,
                code: f,
                usedTimes: 1
            });
            S.info.memory.programs = X.length;
            s = v
        }
        a.program = s;
        a.uniformsList = [];
        for (e in a.uniforms) a.uniformsList.push([a.uniforms[e], e])
    };
    this.setFaceCulling = function (a, b) {
        a === THREE.CullFaceNone ? q.disable(q.CULL_FACE) : (b === THREE.FrontFaceDirectionCW ? q.frontFace(q.CW) : q.frontFace(q.CCW), a === THREE.CullFaceBack ? q.cullFace(q.BACK) : a === THREE.CullFaceFront ? q.cullFace(q.FRONT) : q.cullFace(q.FRONT_AND_BACK), q.enable(q.CULL_FACE))
    };
    this.setMaterialFaces =
        function (a) {
            var b = a.side === THREE.DoubleSide;
            a = a.side === THREE.BackSide;
            ma !== b && (b ? q.disable(q.CULL_FACE) : q.enable(q.CULL_FACE), ma = b);
            Ja !== a && (a ? q.frontFace(q.CW) : q.frontFace(q.CCW), Ja = a)
    };
    this.setDepthTest = function (a) {
        Ua !== a && (a ? q.enable(q.DEPTH_TEST) : q.disable(q.DEPTH_TEST), Ua = a)
    };
    this.setDepthWrite = function (a) {
        Va !== a && (q.depthMask(a), Va = a)
    };
    this.setBlending = function (a, b, c, d) {
        a !== Aa && (a === THREE.NoBlending ? q.disable(q.BLEND) : a === THREE.AdditiveBlending ? (q.enable(q.BLEND), q.blendEquation(q.FUNC_ADD),
            q.blendFunc(q.SRC_ALPHA, q.ONE)) : a === THREE.SubtractiveBlending ? (q.enable(q.BLEND), q.blendEquation(q.FUNC_ADD), q.blendFunc(q.ZERO, q.ONE_MINUS_SRC_COLOR)) : a === THREE.MultiplyBlending ? (q.enable(q.BLEND), q.blendEquation(q.FUNC_ADD), q.blendFunc(q.ZERO, q.SRC_COLOR)) : a === THREE.CustomBlending ? q.enable(q.BLEND) : (q.enable(q.BLEND), q.blendEquationSeparate(q.FUNC_ADD, q.FUNC_ADD), q.blendFuncSeparate(q.SRC_ALPHA, q.ONE_MINUS_SRC_ALPHA, q.ONE, q.ONE_MINUS_SRC_ALPHA)), Aa = a);
        if (a === THREE.CustomBlending) {
            if (b !== Ka && (q.blendEquation(Q(b)),
                Ka = b), c !== Ra || d !== Za) q.blendFunc(Q(c), Q(d)), Ra = c, Za = d
        } else Za = Ra = Ka = null
    };
    this.setTexture = function (a, b) {
        if (a.needsUpdate) {
            a.__webglInit || (a.__webglInit = !0, a.addEventListener("dispose", eb), a.__webglTexture = q.createTexture(), S.info.memory.textures++);
            q.activeTexture(q.TEXTURE0 + b);
            q.bindTexture(q.TEXTURE_2D, a.__webglTexture);
            q.pixelStorei(q.UNPACK_FLIP_Y_WEBGL, a.flipY);
            q.pixelStorei(q.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha);
            q.pixelStorei(q.UNPACK_ALIGNMENT, a.unpackAlignment);
            var c = a.image,
                d = C(c.width) && C(c.height),
                e = Q(a.format),
                f = Q(a.type);
            P(q.TEXTURE_2D, a, d);
            var g = a.mipmaps;
            if (a instanceof THREE.DataTexture)
                if (0 < g.length && d) {
                    for (var h = 0, k = g.length; h < k; h++) c = g[h], q.texImage2D(q.TEXTURE_2D, h, e, c.width, c.height, 0, e, f, c.data);
                    a.generateMipmaps = !1
                } else q.texImage2D(q.TEXTURE_2D, 0, e, c.width, c.height, 0, e, f, c.data);
            else if (a instanceof THREE.CompressedTexture)
                for (h = 0, k = g.length; h < k; h++) c = g[h], a.format !== THREE.RGBAFormat ? q.compressedTexImage2D(q.TEXTURE_2D, h, e, c.width, c.height, 0, c.data) : q.texImage2D(q.TEXTURE_2D,
                    h, e, c.width, c.height, 0, e, f, c.data);
            else if (0 < g.length && d) {
                h = 0;
                for (k = g.length; h < k; h++) c = g[h], q.texImage2D(q.TEXTURE_2D, h, e, e, f, c);
                a.generateMipmaps = !1
            } else q.texImage2D(q.TEXTURE_2D, 0, e, e, f, a.image);
            a.generateMipmaps && d && q.generateMipmap(q.TEXTURE_2D);
            a.needsUpdate = !1;
            if (a.onUpdate) a.onUpdate()
        } else q.activeTexture(q.TEXTURE0 + b), q.bindTexture(q.TEXTURE_2D, a.__webglTexture)
    };
    this.initFrameBuffer = function (a) {
        if (a && !a.__webglFramebuffer) {
            void 0 === a.depthBuffer && (a.depthBuffer = !0);
            void 0 === a.stencilBuffer &&
                (a.stencilBuffer = !0);
            a.addEventListener("dispose", fb);
            a.__webglTexture = q.createTexture();
            S.info.memory.textures++;
            var b = C(a.width) && C(a.height),
                c = Q(a.format),
                d = Q(a.type);
            a.__webglFramebuffer = q.createFramebuffer();
            a.__webglRenderbuffer = a.shareDepthFrom ? a.shareDepthFrom.__webglRenderbuffer : q.createRenderbuffer();
            q.bindTexture(q.TEXTURE_2D, a.__webglTexture);
            P(q.TEXTURE_2D, a, b);
            q.texImage2D(q.TEXTURE_2D, 0, c, a.width, a.height, 0, c, d, null);
            c = q.TEXTURE_2D;
            q.bindFramebuffer(q.FRAMEBUFFER, a.__webglFramebuffer);
            q.framebufferTexture2D(q.FRAMEBUFFER, q.COLOR_ATTACHMENT0, c, a.__webglTexture, 0);
            a.shareDepthFrom ? a.depthBuffer && !a.stencilBuffer ? q.framebufferRenderbuffer(q.FRAMEBUFFER, q.DEPTH_ATTACHMENT, q.RENDERBUFFER, a.__webglRenderbuffer) : a.depthBuffer && a.stencilBuffer && q.framebufferRenderbuffer(q.FRAMEBUFFER, q.DEPTH_STENCIL_ATTACHMENT, q.RENDERBUFFER, a.__webglRenderbuffer) : (c = a.__webglRenderbuffer, q.bindRenderbuffer(q.RENDERBUFFER, c), a.depthBuffer && !a.stencilBuffer ? (q.renderbufferStorage(q.RENDERBUFFER, q.DEPTH_COMPONENT16,
                a.width, a.height), q.framebufferRenderbuffer(q.FRAMEBUFFER, q.DEPTH_ATTACHMENT, q.RENDERBUFFER, c)) : a.depthBuffer && a.stencilBuffer ? (q.renderbufferStorage(q.RENDERBUFFER, q.DEPTH_STENCIL, a.width, a.height), q.framebufferRenderbuffer(q.FRAMEBUFFER, q.DEPTH_STENCIL_ATTACHMENT, q.RENDERBUFFER, c)) : q.renderbufferStorage(q.RENDERBUFFER, q.RGBA4, a.width, a.height));
            b && q.generateMipmap(q.TEXTURE_2D);
            q.bindTexture(q.TEXTURE_2D, null);
            q.bindRenderbuffer(q.RENDERBUFFER, null);
            q.bindFramebuffer(q.FRAMEBUFFER, null)
        }
    };
    this.initFrameBufferMRT =
        function (a, b) {
            var c = a[0],
                d = !1;
            if (c && !c.__webglFramebuffer) {
                void 0 === c.depthBuffer && (c.depthBuffer = !0);
                void 0 === c.stencilBuffer && (c.stencilBuffer = !0);
                c.__webglFramebuffer = q.createFramebuffer();
                q.bindFramebuffer(q.FRAMEBUFFER, c.__webglFramebuffer);
                var e;
                c.shareDepthFrom ? e = c.__webglRenderbuffer = c.shareDepthFrom.__webglRenderbuffer : c.depthBuffer && !c.stencilBuffer ? (e = c.__webglRenderbuffer = q.createRenderbuffer(), q.bindRenderbuffer(q.RENDERBUFFER, e), q.renderbufferStorage(q.RENDERBUFFER, q.DEPTH_COMPONENT16,
                    c.width, c.height)) : c.depthBuffer && c.stencilBuffer && (e = c.__webglRenderbuffer = q.createRenderbuffer(), q.bindRenderbuffer(q.RENDERBUFFER, e), q.renderbufferStorage(q.RENDERBUFFER, q.DEPTH_STENCIL, c.width, c.height));
                c.depthBuffer && !c.stencilBuffer ? q.framebufferRenderbuffer(q.FRAMEBUFFER, q.DEPTH_ATTACHMENT, q.RENDERBUFFER, e) : c.depthBuffer && c.stencilBuffer && q.framebufferRenderbuffer(q.FRAMEBUFFER, q.DEPTH_STENCIL_ATTACHMENT, q.RENDERBUFFER, e);
                d = !0
            }
            e = ba;
            q.bindFramebuffer(q.FRAMEBUFFER, c.__webglFramebuffer);
            for (var f =
                0; f < a.length; f++) {
                var g = a[f];
                if (!g.__webglTexture) {
                    var h = C(g.width) && C(g.height),
                        k = Q(g.format),
                        l = Q(g.type);
                    g.addEventListener("dispose", fb);
                    g.__webglTexture = q.createTexture();
                    S.info.memory.textures++;
                    q.bindTexture(q.TEXTURE_2D, g.__webglTexture);
                    P(q.TEXTURE_2D, g, h);
                    q.texImage2D(q.TEXTURE_2D, 0, k, g.width, g.height, 0, k, l, null);
                    h && q.generateMipmap(q.TEXTURE_2D)
                }
                q.framebufferTexture2D(q.FRAMEBUFFER, q.COLOR_ATTACHMENT0 + f, q.TEXTURE_2D, g.__webglTexture, 0)
            }
            qa && 1 < a.length && qa.drawBuffersWEBGL([qa.COLOR_ATTACHMENT0_WEBGL,
                qa.COLOR_ATTACHMENT1_WEBGL
            ]);
            b && (f = q.checkFramebufferStatus(q.FRAMEBUFFER), f !== q.FRAMEBUFFER_COMPLETE && (console.log("Can't use multiple render targets. Falling back to two passes. " + f), delete c.__webglFramebuffer, b = !1));
            q.bindFramebuffer(q.FRAMEBUFFER, e);
            d && (q.bindTexture(q.TEXTURE_2D, null), q.bindRenderbuffer(q.RENDERBUFFER, null), q.bindFramebuffer(q.FRAMEBUFFER, null));
            return b
    };
    this.setRenderTarget = function (a) {
        var b;
        Array.isArray(a) ? (this.initFrameBufferMRT(a), b = a[0]) : a && (b = a, this.initFrameBuffer(b));
        var c, d, e;
        b ? (a = b.__webglFramebuffer, c = b.width, b = b.height, e = d = 0) : (a = null, c = xa, b = ya, d = va, e = wa);
        a !== ba && (q.bindFramebuffer(q.FRAMEBUFFER, a), q.viewport(d, e, c, b), ba = a);
        sa = c;
        Ba = b
    };
    this.verifyMRTWorks = function (a) {
        qa && !this.initFrameBufferMRT(a, !0) && (qa = null)
    };
    this.shadowMapPlugin = new THREE.ShadowMapPlugin;
    this.addPrePlugin(this.shadowMapPlugin)
};
void 0 === ENABLE_DEBUG && (ENABLE_DEBUG = !0);
void 0 === ENABLE_TRACE && (ENABLE_TRACE = !0);
var ENABLE_AUTOCAM = !0,
    MAX_FRAME_TIME = 50,
    MIN_FRAME_TIME = 1E3 / 30;

function Viewer3DImpl(a, b) {
    this.canvas = a;
    this.api = b;
    this.svfloader = new SvfLoader(this);
    var c = a.clientWidth,
        e = a.clientHeight;
    this.postProcess = !1;
    this.renderer = new RenderContext;
    this.renderer.init(a, c, e);
    this.RENDER_NORMAL = 0;
    this.RENDER_HIGHLIGHTED = 1;
    this.RENDER_HIDDEN = 2;
    this.RENDER_FINISHED = 3;
    this.phase = this.RENDER_NORMAL;
    this.camera = new THREE.PerspectiveCamera(45, c / e, 0.1, 1E4);
    this.cameraChangedEvent = {
        type: "cameraChanged",
        camera: this.camera
    };
    this.scene = new THREE.Scene;
    this.scene.add(this.camera);
    this.overlayScenes = {};
    this.selectionMaterialBase = new THREE.MeshPhongMaterial({
        color: 6724095,
        specular: 526344,
        emissive: 3361911,
        ambient: 0,
        opacity: 1,
        transparent: !1
    });
    this.selectionMaterialTop = new THREE.MeshPhongMaterial({
        color: 6724095,
        specular: 526344,
        emissive: 3361911,
        ambient: 0,
        opacity: 0.15,
        transparent: !0
    });
    this.createOverlayScene("selection", this.selectionMaterialBase, this.selectionMaterialTop);
    this.materials = {};
    this.texturesToUpdate = [];
    this.modelQueue = null;
    this.fadeMaterial = new THREE.MeshLambertMaterial({
        color: 16777215,
        opacity: 0.1,
        transparent: !0
    });
    this.highlightMaterial = new THREE.MeshPhongMaterial({
        color: 6724095,
        specular: 526344,
        emissive: 3361911,
        ambient: 0,
        opacity: 1,
        transparent: !1
    });
    this.needsResize = this.needsClear = this.needsRender = !1;
    this.progressiveRender = !0;
    this.maxFrameTime = MAX_FRAME_TIME;
    this.minFrameTime = MIN_FRAME_TIME;
    this.targetFrameRate = 2E3 / (MIN_FRAME_TIME + MAX_FRAME_TIME);
    ENABLE_AUTOCAM ? this.controls = new ViewController(this) : (this.controls = new THREE.TrackballControls(this.camera, this.canvas), this.controls.rotateSpeed =
        1, this.controls.zoomSpeed = 1, this.controls.panSpeed = 0.5, this.controls.dynamicDampingFactor = 0.5, this.controls.owner = this);
    this.selector = new Autodesk.Selector(this);
    this.controls.setSelector(this.selector);
    this.visibilityManager = new VisibilityManager(this);
    var d = this;
    this.initContextMenu();
    this.useEnvMap = !1;
    this.explodeScale = 0;
    this.showOverlaysWhileMoving = this.showGhosting = !0;
    this.lastTickMoved = !1;
    this.setClearColors(230, 230, 230, 150, 150, 150);
    this.renderer.beginScene(this.scene, this.camera, !0);
    this.renderer.composeFinalFrame();
    this.reqid = 0;
    (function f(a) {
        d.reqid = window.requestAnimationFrame(f);
        d.tick(a)
    })()
}

function isMultiSelect(a) {
    var b = -1 !== navigator.userAgent.search("Mac OS");
    return b && a.metaKey || !b && a.ctrlKey
}

function isRightClick(a) {
    return -1 !== navigator.userAgent.search("Mac OS") && a.ctrlKey || 2 === a.button
}
Viewer3DImpl.prototype.initContextMenu = function () {
    var a = this;
    this.objectContextMenu = new ObjectContextMenu(this);
    this.canvas.addEventListener("mousedown", function (b) {
        isRightClick(b) && (a.startX = b.clientX, a.startY = b.clientY)
    });
    this.canvas.addEventListener("mouseup", function (b) {
        if (isRightClick(b) && b.clientX === a.startX && b.clientY === a.startY) {
            var c = (new CameraRaycaster(a, a.camera)).castRay(b.clientX, b.clientY);
            c.node && (a.selector.isSelectedOrParentIsSelected(c.node) || isMultiSelect(b) || a.selector.setSelection([c.node]));
            return a.objectContextMenu.show(b)
        }
        return !0
    }, !1)
};
Viewer3DImpl.prototype.toggleProgressive = function (a) {
    this.progressiveRender = a;
    this.needsClear = !0
};
Viewer3DImpl.prototype.toggleGhosting = function (a) {
    this.showGhosting = a;
    this.needsClear = !0
};
Viewer3DImpl.prototype.toggleOverlaysWhileMoving = function (a) {
    this.showOverlaysWhileMoving = a
};
Viewer3DImpl.prototype.togglePostProcess = function (a, b) {
    for (var c in this.materials) {
        var e = this.materials[c];
        e.mrtNormals !== a && (e.mrtNormals = a, e.needsUpdate = !0)
    }
    this.renderer.initPostPipeline(a, b);
    this.needsClear = !0
};
Viewer3DImpl.prototype.tick = function (a) {
    (a = this.stats) && a.begin();
    this.needsResize && (this.camera.aspect = this.newWidth / this.newHeight, this.renderer.setSize(this.newWidth, this.newHeight), this.overlayDirty = this.needsClear = this.needsRender = !0, this.needsResize = !1);
    var b = this.controls.update(),
        c = b || this.needsClear;
    for (this.overlayDirty = this.overlayDirty || b; this.texturesToUpdate.length;)
        for (var e = this.texturesToUpdate.pop(), d = 0; d < e.mats.length; d++) e.mats[d][e.slot] = e.tex, this.needsRender = e.mats[d].needsUpdate = !0;
    var e = this.svf && this.svf.loadDone,
        d = c || this.needsRender,
        g = this.modelQueue,
        f = this.progressiveRender ? 0.5 * (this.maxFrameTime + this.minFrameTime) : 1E10,
        k = f;
    d && (e && 0 < this.svf.fragments.length && this.signalProgress(0, null), this.fixNearFar(), this.renderer.beginScene(this.scene, this.camera, c), (b || this.cameraUpdated) && this.api.fireEvent(this.cameraChangedEvent), this.needGhostedPass && g.setOverrideMaterial(null), g && (0 < this.selector.getSelectionLength() ? (this.phase = this.RENDER_HIGHLIGHTED, g.reset(this.camera),
        g.drawHighlightedObjectsOnly(), g.setOverrideMaterial(this.highlightMaterial)) : (this.phase = this.RENDER_NORMAL, g.reset(this.camera), g.drawNormalObjectsOnly(), g.setOverrideMaterial(null))));
    if (g && !g.isDone()) {
        var h = this,
            c = function (a) {
                h.renderer.renderScenePart(a, h.phase !== h.RENDER_NORMAL)
            },
            k = g.renderSome(c, k);
        g.isDone() && this.phase === this.RENDER_HIGHLIGHTED && (this.phase = this.RENDER_NORMAL, g.reset(this.camera), g.drawNormalObjectsOnly(), g.setOverrideMaterial(null), k = g.renderSome(c, k));
        b || this.overlayDirty ||
            this.renderer.composeFinalFrame();
        g.isDone() ? (this.phase === this.RENDER_NORMAL && !g.areAllVisible() && this.showGhosting ? (this.phase = this.RENDER_HIDDEN, g.reset(this.camera), g.drawHiddenObjectsOnly(), g.setOverrideMaterial(this.fadeMaterial)) : (this.phase = this.RENDER_FINISHED, this.renderer.composeFinalFrame()), e && this.signalProgress(100, null)) : e && this.signalProgress(100 * g.currentScene / g.geomScenes.length, null)
    }
    this.overlayDirty && (g && g.isDone() || this.showOverlaysWhileMoving ? (this.renderer.renderOverlays(this.overlayScenes),
        this.overlayDirty = !1) : this.renderer.clearAllOverlays(), this.renderer.composeFinalFrame(!b && !d));
    k < f && a && a.end();
    this.lastTickMoved = b;
    this.needsClear = this.needsRender = !1
};
Viewer3DImpl.prototype.fixNearFar = function () {
    var a = this.camera;
    if (this.svf) {
        var b = this.svf.boundingSphere,
            c = (1.5 * this.explodeScale + 1) * b.radius,
            e = 1E3 < c ? 1 : 1E-4 * c,
            d = a.position.distanceTo(b.center),
            b = d - c,
            c = d + c;
        a.isPerspective ? b < e ? a.near = e : (d = THREE.Math.degToRad(a.fov / 2), d = 1 > a.aspect ? d : Math.atan(a.aspect * Math.tan(d)), a.near = Math.max(e, Math.cos(d) * b)) : a.near = b;
        a.far = c;
        a.updateProjectionMatrix()
    }
};
Viewer3DImpl.prototype.initLights = function (a) {
    this.lightNode = new THREE.Object3D;
    this.dir_light1 = new THREE.DirectionalLight((new THREE.Color).setRGB(1, 0.84, 0.67), 1);
    this.dir_light1.position.set(-1, 0, 1);
    this.dir_light1.position.multiplyScalar(1E3 * a);
    this.lightNode.add(this.dir_light1);
    this.amb_light = new THREE.AmbientLight((new THREE.Color).setRGB(0.8, 0.9, 1));
    this.scene.add(this.amb_light);
    this.camera.add(this.lightNode)
};
Viewer3DImpl.prototype.initCamera = function (a) {
    var b = a.metadata ? (new THREE.Vector3).fromArray(a.metadata["world up vector"].XYZ) : null,
        c = !1,
        e = this.getDefaultCamera();
    null !== e ? (a = e.fov, e.isPerspective || (a = 10, c = !0), this.camera.isPerspective = !0, this.camera.fov = a, this.camera.position.copy(e.position), this.camera.up.copy(e.up), this.camera.target = (new THREE.Vector3).copy(e.target), e.inst && e.inst.transform && (e = (new THREE.Matrix4).copy(e.inst.transform), this.camera.position.applyMatrix4(e), this.camera.target.applyMatrix4(e),
        this.camera.up.transformDirection(e)), b ? this.camera.up.copy(b) : this.camera.up = this.getNearestAxis(this.camera.up)) : (this.camera.target = a.bbox.center(), e = a.bbox.size(), this.camera.position.copy(this.camera.target), this.camera.position.z += Math.max(e.x, Math.max(e.y, e.z)), this.camera.isPerspective = !0, b && this.camera.up.copy(b));
    this.camera.lookAt(this.camera.target);
    this.syncCamera();
    c && this.controls.fitToView(!0);
    this.controls.recordHomeView();
    this.cameraChangedEvent = {
        type: "cameraChanged",
        camera: this.camera
    }
};
Viewer3DImpl.prototype.syncCamera = function () {
    this.camera.updateProjectionMatrix();
    this.controls.setWorldUp(this.camera.up);
    this.controls.setSceneBounds(this.svf.bbox);
    this.controls.setViewpoint(this.camera.position, this.camera.target);
    this.cameraUpdated = !0
};
Viewer3DImpl.prototype.getNearestAxis = function (a) {
    a = a.clone();
    0 > a.x && (a.x = -a.x);
    0 > a.y && (a.y = -a.y);
    0 > a.z && (a.z = -a.z);
    a.x > a.y && a.x > a.z ? a.set(0 < a.x ? 1 : -1, 0, 0) : a.y > a.x && a.y > a.z ? a.set(0, 0 < a.y ? 1 : -1, 0) : a.set(0, 0, 0 < a.z ? 1 : -1);
    return a
};
Viewer3DImpl.prototype.getDefaultCamera = function () {
    var a = null,
        b = this.svf,
        c = b.cameras.length;
    if (0 < c) {
        var e = b.metadata && b.metadata["default camera"] ? b.metadata["default camera"].index : null;
        if (null !== e && b.cameras[e]) a = b.cameras[e];
        else {
            for (e = 0; e < c; e++) {
                var d = b.cameras[e];
                if (d.isPerspective) {
                    a = d;
                    break
                }
            }
            a || (a = b.cameras[0])
        }
    }
    return a
};
Viewer3DImpl.prototype.setViewFromFile = function () {
    var a = {},
        b = !0,
        c = this.svf,
        e = c.metadata,
        e = e ? (new THREE.Vector3).fromArray(e["world up vector"].XYZ) : null,
        d = this.getDefaultCamera();
    d ? (b = d.isPerspective, a.isPerspective = !0, a.fov = b ? d.fov : 10, a.position = (new THREE.Vector3).copy(d.position), a.target = (new THREE.Vector3).copy(d.target), a.up = (new THREE.Vector3).copy(d.up), d.inst && d.inst.transform && (c = (new THREE.Matrix4).copy(d.inst.transform), a.position.applyMatrix4(c), a.target.applyMatrix4(c), a.up.transformDirection(c)),
        a.up = e ? e : this.getNearestAxis(a.up)) : (a.isPerspective = !0, a.fov = this.camera.fov, a.target = c.bbox.center(), a.up = e ? e : this.camera.up.clone(), a.position = a.target.clone(), c = c.bbox.size(), a.position.z += Math.max(c.x, c.y, c.z));
    this.applyCamera(a, !b)
};
Viewer3DImpl.prototype.setViewFromArray = function (a) {
    a = {
        position: new THREE.Vector3(a[0], a[1], a[2]),
        target: new THREE.Vector3(a[3], a[4], a[5]),
        up: new THREE.Vector3(a[6], a[7], a[8]),
        aspect: a[9],
        fov: THREE.Math.radToDeg(a[10]),
        orthoHeight: a[11],
        isPerspective: !a[12]
    };
    var b = a.isPerspective;
    b || (a.fov = 10);
    var c = this.svf.metadata,
        c = c ? (new THREE.Vector3).fromArray(c["world up vector"].XYZ) : null;
    a.up = c ? c : this.getNearestAxis(a.up);
    this.applyCamera(a, !b)
};
Viewer3DImpl.prototype.applyCamera = function (a, b) {
    if (b) {
        var c = this.camera.position.clone(),
            e = this.camera.target.clone(),
            d = this.camera.up.clone(),
            g = this.camera.fov;
        this.camera.position.copy(a.position);
        this.camera.target.copy(a.target);
        this.camera.up.copy(a.up);
        this.camera.fov = a.fov;
        this.camera.lookAt(a.target);
        this.syncCamera();
        var f = this.controls.fitToView(!0, this.svf.bbox);
        this.camera.position.copy(c);
        this.camera.target.copy(e);
        this.camera.up.copy(d);
        this.camera.fov = g;
        this.camera.lookAt(e);
        this.syncCamera();
        this.controls.setWorldUp(a.up);
        this.controls.transitionView(f.position, f.target, a.fov, 10)
    } else this.controls.setWorldUp(a.up), this.controls.transitionView(a.position, a.target, a.fov, 10);
    this.cameraUpdated = !0;
    this.cameraChangedEvent = {
        type: "cameraChanged",
        camera: this.camera
    }
};
Viewer3DImpl.prototype.initScene = function (a) {
    this.svf = a;
    a.bbox = new THREE.Box3(a.bbox.min, a.bbox.max);
    var b = a.bbox.size(),
        c = a.bbox.center(),
        b = 0.5 * Math.sqrt(b.x * b.x + b.y * b.y + b.z * b.z);
    a.boundingSphere = new THREE.Sphere(c, b);
    stderr("scene bounds: " + JSON.stringify(a.bbox));
    this.initCamera(a);
    this.initLights(b);
    this.modelQueue = new RenderQueue(a.fragments, this.scene);
    this.needsRender = this.needsClear = !0
};
Viewer3DImpl.prototype.getNodesByIds = function (a) {
    function b(a, e, d) {
        if (0 === a.length) return d;
        var g = a.indexOf(e.dbId); - 1 !== g && (d.push(e), a.splice(g, 1));
        if (e.children)
            for (g = 0; g < e.children.length; g++) b(a, e.children[g], d);
        return d
    }
    a = a.slice(0);
    return b(a, this.svf.instanceTree, [])
};
Viewer3DImpl.prototype.addMaterial = function (a, b) {
    function c(a) {
        return 0.299 * a.r + 0.587 * a.g + 0.114 * a.b
    }
    b.metal ? (b.reflectivity || (b.reflectivity = c(b.specular)), this.svfloader.svf.proteinMaterials && (1 === b.reflectivity && (b.reflectivity = c(b.specular)), 0 === b.color.r && 0 === b.color.g && 0 === b.color.b ? (b.color.r = 0.1 * b.specular.r, b.color.g = 0.1 * b.specular.g, b.color.b = 0.1 * b.specular.b) : (b.color.r *= 0.1, b.color.g *= 0.1, b.color.b *= 0.1))) : !this.svfloader.svf.proteinMaterials && b.reflectivity ? (b.metal = !0, b.specular.r = b.color.r *
        b.reflectivity, b.specular.g = b.color.g * b.reflectivity, b.specular.b = b.color.b * b.reflectivity, b.color.r *= 0.1, b.color.g *= 0.1, b.color.b *= 0.1) : 1 !== b.color.r || 1 !== b.color.g || 1 !== b.color.b || 1 !== b.specular.r || 1 !== b.specular.g || 1 !== b.specular.b || b.uri_map || b.uri_specularMap ? (b.reflectivity || (b.reflectivity = 0.01 + 0.06 * c(b.specular)), b.specular.r *= b.reflectivity, b.specular.g *= b.reflectivity, b.specular.b *= b.reflectivity) : (b.metal = !0, b.reflectivity = 0.7, b.specular.r = b.specular.g = b.specular.b = b.reflectivity, b.color.r *=
        0.1, b.color.g *= 0.1, b.color.b *= 0.1);
    b.ambient.copy(b.color);
    b.ambient.r *= 0.3;
    b.ambient.g *= 0.3;
    b.ambient.b *= 0.3;
    b.combine = THREE.AddOperation;
    if (b.uri_normalMap) {
        var e = b.bumpScale;
        if (void 0 === e || 1 <= e) e = 1;
        b.normalScale = new THREE.Vector2(e, e)
    } else void 0 === b.bumpScale && (b.uri_map || b.uri_bumpMap) ? b.bumpScale = 0.03 : 1 < b.bumpScale && (b.bumpScale = 0.03);
    this.reflectionCube && (b.envMap = this.reflectionCube);
    this.irradianceMap && (b.irradianceMap = this.irradianceMap);
    b.mrtNormals = this.renderer.hasMRT() && this.renderer.settings.sao;
    b.side == THREE.DoubleSide && this.renderer.toggleTwoSided(!0);
    this.materials[a] = b
};
Viewer3DImpl.prototype.addTexture = function (a) {
    this.texturesToUpdate.push(a)
};
Viewer3DImpl.prototype.addMeshInstance = function (a, b, c, e) {
    if (0 !== b || -1 == this.svfloader.svf.basePath.indexOf("SaRang")) {
        if (a.isLines) {
            var d = !!a.attributes.color,
                g = new THREE.LineBasicMaterial({
                    vertexColors: d,
                    polygonOffset: !0,
                    polygonOffsetFactor: 1,
                    polygonOffsetUnits: 1
                });
            d || (g.color = this.materials[c].color);
            a = new THREE.Line(a, g)
        } else {
            g = this.materials[c];
            if (!g)
                for (d in stderr("Unknown material " + c), this.materials) {
                    g = this.materials[d];
                    break
                }
            a.attributes.color && (g.vertexColors = THREE.VertexColors, g.needsUpdate = !0);
            a.attributes.uv && a.attributes.uv.isPattern && (g.map && !g.bumpMap && (g.bumpMap = g.map, g.needsUpdate = !0), g.uri_map && !g.uri_bumpMap && (g.uri_bumpMap = g.uri_map, g.needsUpdate = !0));
            a = new THREE.Mesh(a, g, !0)
        }
        e && (a.matrix ? a.matrix.copy(e) : a.matrixWorld.copy(e));
        a.matrixAutoUpdate = !1;
        this.modelQueue.addMesh(b, a)
    }
};
Viewer3DImpl.prototype.signalProgress = function (a, b) {
    this.api.fireEvent({
        type: Autodesk.Viewing.PROGRESS_UPDATE_EVENT,
        percent: a,
        message: b
    })
};
Viewer3DImpl.prototype.resize = function (a, b) {
    this.needsResize = !0;
    this.newWidth = a;
    this.newHeight = b
};
Viewer3DImpl.prototype.loadSvf = function (a, b, c, e) {
    return this.svfloader.loadSvf(a, b, c, e)
};
Viewer3DImpl.prototype.createOverlayScene = function (a, b, c, e) {
    b && (b.depthWrite = !1, b.depthTest = !0);
    c && (c.depthWrite = !1, c.depthTest = !1);
    var d = new THREE.Scene(!0);
    d.__lights = this.scene.__lights;
    this.overlayScenes[a] = {
        scene: d,
        camera: e,
        materialPre: b,
        materialPost: c
    }
};
Viewer3DImpl.prototype.addOverlay = function (a, b) {
    this.overlayScenes[a].scene.add(b);
    this.overlayDirty = !0
};
Viewer3DImpl.prototype.removeOverlay = function (a, b) {
    this.overlayScenes[a].scene.remove(b);
    this.overlayDirty = !0
};
Viewer3DImpl.prototype.clearOverlay = function (a) {
    this.overlayScenes[a].scene.clear();
    this.overlayDirty = !0
};
Viewer3DImpl.prototype.setClearColors = function (a, b, c, e, d, g) {
    this.clearColorTop = new THREE.Vector4(a / 255, b / 255, c / 255, 1);
    this.clearColorBottom = new THREE.Vector4(e / 255, d / 255, g / 255, 1);
    this.setCubeMapFromColors(this.clearColorTop, this.clearColorBottom);
    this.renderer.setClearColors(this.clearColorTop, this.clearColorBottom);
    this.needsClear = !0
};
Viewer3DImpl.prototype.explode = function (a) {
    var b = this.svf,
        c = new THREE.Box3,
        e = new THREE.Vector3,
        d = new THREE.Vector3,
        g = new THREE.Box3,
        f = b.fragments,
        k = f.transforms,
        h = this.modelQueue.vizmeshes,
        l = b.bbox.center(),
        m = a * (b.maxTreeDepth - 1) + 1,
        n = 0 | m,
        r = m - n;
    this.explodeScale = a *= 2;
    if (b.instanceTree && b.instanceBoxes && 0 != a) {
        var s = b.instanceBoxes;
        (function N(b, f, l, m, p, t, u, x) {
            var v = 2 * a;
            f == n && (v *= r);
            var w = 6 * b.dbId,
                y = 0.5 * (s[w] + s[w + 3]),
                I = 0.5 * (s[w + 1] + s[w + 4]),
                U = 0.5 * (s[w + 2] + s[w + 5]);
            0 < f && f <= n && (t += (y - l) * v, u += (I - m) * v, x += (U -
                p) * v);
            e.x = s[w] + t;
            e.y = s[w + 1] + u;
            e.z = s[w + 2] + x;
            d.x = s[w + 3] + t;
            d.y = s[w + 4] + u;
            d.z = s[w + 5] + x;
            g.set(e, d);
            c.union(g);
            if (l = b.children)
                for (m = 0, p = l.length; m < p; m++) N(l[m], f + 1, y, I, U, t, u, x);
            b = b.fragIds;
            if (void 0 !== b)
                if (Array.isArray(b))
                    for (f = 0; f < b.length; f++) y = 0 | b[f], U = 16 * y, I = h[y].matrixWorld.elements, I[12] = k[U + 12] + t, I[13] = k[U + 13] + u, I[14] = k[U + 14] + x;
                else y = b | 0, I = h[y].matrixWorld.elements, U = 16 * y, I[12] = k[U + 12] + t, I[13] = k[U + 13] + u, I[14] = k[U + 14] + x
        })(b.instanceTree, 0, l.x, l.y, l.x, 0, 0, 0)
    } else
        for (var f = f.boxes, m = 0, t = h.length; m <
            t; m++) {
            var p = 6 * m,
                u = 16 * m,
                v = 0.5 * (f[p] + f[p + 3]),
                w = 0.5 * (f[p + 1] + f[p + 4]),
                y = 0.5 * (f[p + 2] + f[p + 5]),
                v = a * (v - l.x),
                w = a * (w - l.y),
                y = a * (y - l.z),
                x = h[m].matrixWorld.elements;
            x[12] = k[u + 12] + v;
            x[13] = k[u + 13] + w;
            x[14] = k[u + 14] + y;
            0 < a ? (e.x = f[p] + v, e.y = f[p + 1] + w, e.z = f[p + 2] + y, d.x = f[p + 3] + v, d.y = f[p + 4] + w, d.z = f[p + 5] + y, g.set(e, d), c.union(g)) : c = b.bbox
        }
    this.controls.setSceneBounds(c);
    this.overlayDirty = this.needsClear = !0
};
Viewer3DImpl.prototype.setCubeMapFromColors = function (a, b) {
    for (var c = 255 * a.x, e = 255 * a.y, d = 255 * a.z, g = 255 * b.x, f = 255 * b.y, k = 255 * b.z, h = new Uint8Array(16), l = new Uint8Array(16), m = new Uint8Array(16), n = 0; 4 > n; n++) h[4 * n] = c, h[4 * n + 1] = e, h[4 * n + 2] = d, h[4 * n + 3] = 255, l[4 * n] = g, l[4 * n + 1] = f, l[4 * n + 2] = k, l[4 * n + 3] = 255, 0 | n / 2 ? (m[4 * n] = c, m[4 * n + 1] = e, m[4 * n + 2] = d) : (m[4 * n] = g, m[4 * n + 1] = f, m[4 * n + 2] = k), m[4 * n + 3] = 255;
    c = new THREE.DataTexture(m, 2, 2, THREE.RGBAFormat);
    e = new THREE.DataTexture(m, 2, 2, THREE.RGBAFormat);
    l = new THREE.DataTexture(l, 2, 2, THREE.RGBAFormat);
    h = new THREE.DataTexture(h, 2, 2, THREE.RGBAFormat);
    d = new THREE.DataTexture(m, 2, 2, THREE.RGBAFormat);
    g = new THREE.DataTexture(m, 2, 2, THREE.RGBAFormat);
    m = new THREE.Texture(null, new THREE.CubeReflectionMapping, THREE.RepeatWrapping, THREE.RepeatWrapping, THREE.LinearFilter, THREE.LinearFilter, THREE.RGBAFormat);
    m.image = [e.image, c.image, h.image, l.image, g.image, d.image];
    m.needsUpdate = !0;
    this.reflectionCube = m;
    for (var r in this.materials) h = this.materials[r], h.envMap = m, h.needsUpdate = !0;
    this.needsClear = !0
};
Viewer3DImpl.prototype.resetCubeMap = function (a) {
    this.reflectionCube = void 0 === a && this.svf ? this.svf.envMap : a;
    for (var b in this.materials) a = this.materials[b], a.envMap = this.reflectionCube, a.needsUpdate = !0;
    this.reflectionCube || this.setCubeMapFromColors(this.clearColorTop, this.clearColorBottom);
    this.needsClear = !0
};
Viewer3DImpl.prototype.setCubeMap = function (a) {
    var b = this,
        c = function (a) {
            b.resetCubeMap(a)
        };
    THREE.ImageUtils.crossOrigin = "";
    Array.isArray(a) ? (this.reflectionCube = THREE.ImageUtils.loadTextureCube(a, new THREE.CubeReflectionMapping, c), this.reflectionCube.format = THREE.RGBFormat) : a && a.length ? (this.reflectionCube = THREE.ImageUtils.loadTexture(a, new THREE.SphericalReflectionMapping, c), this.reflectionCube.format = THREE.RGBFormat) : this.reflectionCube && b.resetCubeMap(null)
};
Viewer3DImpl.prototype.uninitialize = function () {
    window.cancelAnimationFrame(this.reqid);
    this.controls.uninitialize()
};
Viewer3DImpl.prototype.raiseError = function (a, b, c) {
    a = {
        type: "error",
        code: a,
        message: b
    };
    if (c)
        for (var e in c) c.hasOwnProperty(e) && (a[e] = c[e]);
    this.api.fireEvent(a);
    console.error(b)
};
Viewer3DImpl.prototype.search = function (a, b) {
    this.svfloader.searchProperties(a, b)
};
Viewer3DImpl.prototype.hideLines = function (a) {
    this.modelQueue.hideLines(a);
    this.needsClear = !0
};

function PropertyPanel(a) {
    var b = this;
    this.viewer = a;
    this.dockPanel = new DockingPanel(a, "PropertyPanel", "Object Properties Loading...", !0);
    this.table = document.createElement("table");
    this.table.id = "propertygrid";
    this.table.className = "tftable";
    this.tbody = document.createElement("tbody");
    this.table.appendChild(this.tbody);
    this.scrollpanel = document.createElement("div");
    this.scrollpanel.className = "scrollcontainer-right";
    this.scrollpanel.style.height = "auto";
    this.scrollpanel.style.width = "auto";
    this.scrollpanel.style.position =
        "absolute";
    this.scrollpanel.style.top = "38px";
    this.scrollpanel.style.bottom = "0px";
    this.scrollpanel.style.left = "0px";
    this.scrollpanel.style.right = "0px";
    this.scrollpanel.style.padding = "0px 5px 0px 5px";
    this.scrollpanel.style.marginBottom = "10px";
    this.dockPanel.container.appendChild(this.scrollpanel);
    this.scrollpanel.appendChild(this.table);
    this.dockPanel.container.style.width = "300px";
    this.dockPanel.container.style.height = "200px";
    this.dockPanel.container.style.top = "180px";
    this.dockPanel.container.style.left =
        "220px";
    this.dockPanel.container.dock = !0;
    this.setOpenOnSelect = function (a) {
        this.openOnSelect = a
    };
    this.lastSelected = [];
    a.addEventListener(Autodesk.Viewing.SELECTION_CHANGED_EVENT, function (a) {
        b.lastSelected = a.dbIdArray;
        b.pullCorrectProperties();
        b.openOnSelect && b.setVisible(0 < a.dbIdArray.length)
    });
    a.addEventListener(Autodesk.Viewing.ISOLATE_EVENT, function (a) {
        for (var e = [], d = 0; d < a.nodeIdArray.length; d++) {
            var g = a.nodeIdArray[d].dbId;
            g && e.push(g)
        }
        b.lastSelected = e;
        b.pullCorrectProperties();
        b.openOnSelect &&
            b.setVisible(0 < a.nodeIdArray.length)
    });
    a.addEventListener(Autodesk.Viewing.HIDE_EVENT, function (a) {
        b.pullCorrectProperties()
    });
    a.addEventListener(Autodesk.Viewing.SHOW_EVENT, function (a) {
        b.pullCorrectProperties();
        b.openOnSelect && b.setVisible(0 < a.nodeIdArray.length)
    });
    this.pullCorrectProperties = function () {
        if (0 < this.lastSelected.length) this.setNodeId(this.lastSelected[this.lastSelected.length - 1]);
        else {
            if (!a.areAllVisible())
                for (var b = [a.impl.svf.instanceTree]; 0 < b.length;) {
                    var e = b.shift();
                    if (e) {
                        if (VisibilityManager.isVisible(e)) {
                            this.setNodeId(e.dbId);
                            return
                        }
                        if (e.children)
                            for (var d = 0; d < e.children.length; d++) b.push(e.children[d])
                    }
                }
            this.setNodeId(a.impl.svf.instanceTree ? a.impl.svf.instanceTree.dbId : null)
        }
    };
    this.getNodeId = function () {
        return this.currentID
    };
    this.setVisible = function (a) {
        this.dockPanel.setVisible(a)
    };
    this.isVisible = function () {
        return this.dockPanel.isVisible()
    };
    this.setDefaultProperties = function () {
        a.impl.svf.instanceTree ? this.setNodeId(a.impl.svf.instanceTree.dbId) : this.setNodeId(null)
    };
    this.setNodeId = function (c) {
        b.tbody.innerHTML = "";
        c ||
            (c = a.impl.svf.instanceTree ? a.impl.svf.instanceTree.dbId : null);
        c ? (this.currentID = c, a.getProperties(c, function (c) {
            b.tbody.innerHTML = "";
            if (c.properties)
                for (var d = 0; d < c.properties.length; d++) {
                    var g = c.properties[d],
                        f = g.displayValue,
                        k = b.tbody.insertRow(-1),
                        h = k.insertCell(0);
                    h.textContent = g.displayName;
                    h.style.fontStyle = "italic";
                    h = k.insertCell(1);
                    h.textContent = f;
                    g = h;
                    f = a.searchText;
                    "" !== f && (f = new RegExp("(\\b" + f + "\\b)", "gim"), k = g.innerHTML.replace(/(<highlight>|<\/highlight>)/igm, ""), g.innerHTML = k, f = k.replace(f,
                        "<highlight>$1</highlight>"), g.innerHTML = f)
                }
            b.dockPanel.title.textContent = c.name ? c.name : "Object Properties";
            b.scrollpanel.scrollTop = 0;
            c = b.viewer.canvas.clientHeight;
            d = b.table.offsetHeight + b.dockPanel.title.offsetHeight + parseInt(b.scrollpanel.style.marginBottom);
            b.dockPanel.container.style.height = (d > c - 180 ? c - 180 : d) + "px"
        })) : (this.currentID = null, b.dockPanel.title.textContent = "Object Properties")
    }
};

function ProgressBar(a) {
    this.bg = document.createElement("div");
    this.bg.className = "progressbg";
    this.fg = document.createElement("div");
    this.fg.className = "progressfg";
    this.bg.appendChild(this.fg);
    a.appendChild(this.bg);
    this.widthScale = this.fg.clientWidth
}
ProgressBar.prototype.setPercent = function (a) {
    99 <= a ? this.bg.style.visibility = "hidden" : (this.bg.style.visibility = "visible", this.fg.style.width = this.widthScale * a * 0.01 + "px")
};

function DockingPanel(a, b, c, e) {
    e = "undefined" === typeof e ? !1 : e;
    this.visibilityCallbacks = [];
    this.viewer = a;
    this.container = document.createElement("div");
    this.container.id = b;
    this.container.lastWidth = "";
    this.container.dock = !1;
    this.container.className = e ? "dockpanel" : "dockpanel-clear";
    this.title = document.createElement("div");
    this.title.className = "paneltitle";
    this.title.textContent = c || b;
    this.closer = document.createElement("div");
    this.closer.className = "panelclose";
    this.closer.innerHTML = "&times;";
    this.container.appendChild(this.title);
    this.container.appendChild(this.closer);
    this.initializeMoveHandlers(this.title);
    this.initializeCloseHandler(this.closer);
    a.container.appendChild(this.container)
}
DockingPanel.prototype.addVisibilityListener = function (a) {
    this.visibilityCallbacks.push(a)
};
DockingPanel.prototype.callVisibilityCallbacks = function (a) {
    for (var b = 0; b < this.visibilityCallbacks.length; b++) this.visibilityCallbacks[b](a)
};
DockingPanel.initialize = function (a) {
    a.dockingPanels = [];
    window.addEventListener("resize", function (b) {
        DockingPanel.resizePanels(a)
    }, !1)
};
DockingPanel.resizePanels = function (a) {
    var b = a.dockingPanels;
    if (b) {
        a = a.getDimensions();
        for (var c = 0; c < b.length; c++) {
            var e = b[c].container,
                d = parseInt(e.style.top),
                g = parseInt(e.style.left),
                f = "" === e.style.minWidth ? 100 : parseInt(e.style.minWidth),
                k = "" === e.style.minHeight ? 100 : parseInt(e.style.minHeight),
                h = parseInt(e.style.width),
                l = parseInt(e.style.height);
            isNaN(h) && (h = e.getBoundingClientRect().width);
            isNaN(l) && (l = e.getBoundingClientRect().height);
            h = f > h ? f : h;
            l = k > l ? k : l;
            if (h && l) {
                g += h;
                d + l > a.height && (k > a.height -
                    d ? e.style.top = a.height - l + "px" : e.style.height = a.height - d + "px");
                if (g > a.width - 5 || e.dock) d = a.width - h, e.style.left = (0 > d ? 0 : d) + "px";
                e.style.maxWidth = a.width - parseInt(e.style.left) + "px";
                e.style.maxHeight = a.height - parseInt(e.style.top) + "px"
            }
        }
    }
};
DockingPanel.prototype.isVisible = function () {
    return "none" !== this.container.style.display && "" !== this.container.style.display
};
DockingPanel.prototype.setVisible = function (a) {
    this.setDisplay(a ? "block" : "none")
};
DockingPanel.prototype.setDisplay = function (a) {
    this.container.style.display = a;
    "none" === a && (this.container.lastWidth = this.viewer.container.style.width, this.callVisibilityCallbacks(!1));
    var b = this.viewer.getDimensions().width;
    "block" === a && (this.viewer.dockingPanels.splice(this.viewer.dockingPanels.indexOf(this), 1), this.viewer.dockingPanels.splice(0, 0, this), this.container.dock && (a = "" == this.container.style.width ? this.container.lastWidth : this.container.style.width, a = "" === a ? 300 : parseInt(a), this.container.style.left =
        b - a + "px"), this.callVisibilityCallbacks(!0))
};
DockingPanel.prototype.initializeMoveHandlers = function (a) {
    function b(a) {
        var b = m.viewer.getDimensions();
        l.style.maxWidth && parseInt(l.style.width) > parseInt(l.style.maxWidth) && (l.style.width = l.style.maxWidth);
        l.style.maxHeight && parseInt(l.style.height) > parseInt(l.style.maxHeight) && (l.style.height = l.style.maxHeight);
        100 > parseInt(l.style.width) && (l.style.width = "100px");
        100 > parseInt(l.style.height) && (l.style.height = "100px");
        k += a.screenX - e;
        h += a.screenY - d;
        var c = g + k,
            t = f + h;
        parseInt(l.style.top);
        parseInt(l.style.left);
        var p = parseInt(l.style.width),
            u = parseInt(l.style.height);
        isNaN(p) && (p = m.container.getBoundingClientRect().width);
        isNaN(u) && (u = m.container.getBoundingClientRect().height);
        5 > c && (c = 0);
        5 > t && (t = 0);
        l.dock = !1;
        b.width - 5 < c + p && (c = b.width - p, l.dock = !0);
        b.height - 5 < t + u && (t = b.height - u, l.dock = !0);
        l.style.left = c + "px";
        l.style.top = t + "px";
        l.style.maxWidth = b.width - c + "px";
        l.style.maxHeight = b.height - t + "px";
        e = a.screenX;
        d = a.screenY
    }

    function c(a) {
        window.removeEventListener("mousemove", b);
        window.removeEventListener("mouseup",
            c)
    }
    var e, d, g, f, k, h, l = this.container,
        m = this;
    this.viewer.dockingPanels.push(this);
    a.addEventListener("mousedown", function (a) {
        e = a.screenX;
        d = a.screenY;
        h = k = 0;
        a = l.style;
        g = parseInt(a.left.substr(0, a.left.length - 2));
        f = parseInt(a.top.substr(0, a.top.length - 2));
        window.addEventListener("mousemove", b, !1);
        window.addEventListener("mouseup", c, !1)
    }, !1)
};
DockingPanel.prototype.initializeCloseHandler = function (a) {
    var b = this;
    a.addEventListener("click", function (a) {
        b.setVisible(!1)
    }, !1)
};

function DocumentStructurePanel(a) {
    DockingPanel.call(this, a, "", "");
    var b = this;
    this.viewer = a;
    this.container = document.createElement("div");
    this.container.id = "documentstructure";
    this.container.className = "dockpanel-clear";
    this.title = document.createElement("div");
    this.title.className = "paneltitle";
    this.title.textContent = "Document Structure Loading ...";
    this.container.appendChild(this.title);
    this.baselist = document.createElement("ul");
    this.closer = document.createElement("div");
    this.closer.className = "panelclose";
    this.closer.innerHTML = "&times;";
    this.container.appendChild(this.closer);
    this.initializeMoveHandlers(this.title);
    this.initializeCloseHandler(this.closer);
    this.scrollpanel = document.createElement("div");
    this.scrollpanel.className = "scrollcontainer-left";
    this.scrollpanel.style.height = "auto";
    this.scrollpanel.style.width = "auto";
    this.scrollpanel.style.position = "absolute";
    this.scrollpanel.style.top = "38px";
    this.scrollpanel.style.bottom = "0px";
    this.scrollpanel.style.left = "0px";
    this.scrollpanel.style.right = "6px";
    this.innercontainer = document.createElement("div");
    this.innercontainer.className = "documentStructure";
    this.container.appendChild(this.scrollpanel);
    this.scrollpanel.appendChild(this.innercontainer);
    this.innercontainer.appendChild(this.baselist);
    this.container.style.left = "0px";
    this.container.style.top = "4em";
    var c = this.viewer.getDimensions().height;
    this.container.style.height = (800 < c - 100 ? 800 : c - 100) + "px";
    this.container.style.minHeight = "100px";
    this.container.backgroundColor = "rgba(0,0,0,0)";
    this.items = {};
    a.getObjectTree(function (a) {
        b.rootNode = a;
        b.treeLoaded(b.baselist, a, "item")
    });
    this.container.style.display = "none";
    a.container.appendChild(this.container);
    this.lastKnownSelectionList = [];
    a.addEventListener(Autodesk.Viewing.SELECTION_CHANGED_EVENT, function (a) {
        b.setSelectedNodes(a.nodeArray)
    });
    a.addEventListener(Autodesk.Viewing.HIGHLIGHT_EVENT, function (a) {
        b.setHighlightNode(a.dbNode)
    });
    a.addEventListener(Autodesk.Viewing.ISOLATE_EVENT, function (a) {
        b.setIsolatedNodes(a.nodeIdArray)
    });
    a.addEventListener(Autodesk.Viewing.HIDE_EVENT,
        function (a) {
            b.hideNodes(a.nodeIdArray)
        });
    a.addEventListener(Autodesk.Viewing.SHOW_EVENT, function (a) {
        b.showNodes(a.nodeIdArray)
    })
}
DocumentStructurePanel.prototype = Object.create(DockingPanel.prototype);
DocumentStructurePanel.prototype.setClickBehavior = function (a) {
    this.clickConfig = a
};

function ctrlDown(a) {
    var b = -1 !== navigator.userAgent.search("Mac OS");
    return b && a.metaKey || !b && a.ctrlKey
}
DocumentStructurePanel.prototype.clickItem = function (a, b) {
    var c = "click";
    ctrlDown(a) && (c += "Ctrl");
    a.shiftKey && (c += "Shift");
    a.altKey && (c += "Alt");
    onObjectKey = "onObject";
    this.clickConfig && this.clickConfig[c] && this.handleAction(this.clickConfig[c][onObjectKey], b.data)
};
DocumentStructurePanel.prototype.doubleClickItem = function (a, b) {
    this.handleAction(["focus"], b.data)
};
DocumentStructurePanel.prototype.handleAction = function (a, b) {
    for (var c in a) switch (a[c]) {
    case "selectOnly":
        this.viewer.select([b.dbId]);
        break;
    case "deselectAll":
        this.viewer.select([]);
        break;
    case "selectToggle":
        this.viewer.toggleSelect(b.dbId);
        break;
    case "isolate":
        this.viewer.isolate(b);
        break;
    case "showAll":
        this.viewer.isolate(null);
        break;
    case "focus":
        this.viewer.impl.controls.fitToView();
        break;
    case "hide":
        this.viewer.hide(b);
        break;
    case "show":
        this.viewer.show(b);
        break;
    case "toggleVisibility":
        this.viewer.toggleVisibility(b)
    }
};
DocumentStructurePanel.prototype.showContextMenu = function (a, b, c) {
    a = a.viewer.impl;
    this.viewer.show(c.data); - 1 === a.selector.findSelection(c.data) && (ctrlDown(b) || this.viewer.select(c.data.dbId));
    return a.objectContextMenu.show(b)
};
DocumentStructurePanel.prototype.setHighlightNode = function (a) {
    if (this.lastHighlightNode) {
        var b = this.lastKnownSelectionList.indexOf(this.lastHighlightNode),
            c = this.items[this.lastHighlightNode.dbId];
        setHighlighted(c, !1);
        setSelected(c, 0 <= b)
    }
    if (this.lastHighlightNode = a) b = this.lastKnownSelectionList.indexOf(a), c = this.items[a.dbId], setHighlighted(c, !0), setSelected(c, 0 <= b)
};
DocumentStructurePanel.prototype.setSelectedNodes = function (a) {
    this.clearExtraState();
    this.lastKnownSelectionList = a;
    this.appendExtraState(a)
};
DocumentStructurePanel.prototype.setIsolatedNodes = function (a) {
    0 < a.length ? (this.setVisibleStateOnAll(!1), this.setVisibleStateOnNodes(a, !0)) : this.setVisibleStateOnAll(!0)
};
DocumentStructurePanel.prototype.hideNodes = function (a) {
    this.setVisibleStateOnNodes(a, !1)
};
DocumentStructurePanel.prototype.showNodes = function (a) {
    this.setVisibleStateOnNodes(a, !0)
};

function addClass(a, b) {
    a && (a.className = a.className.replace(" " + b, ""), a.className += " " + b)
}

function removeClass(a, b) {
    a && (a.className = a.className.replace(" " + b, ""))
}

function setHighlighted(a, b) {
    b ? addClass(a.header, "highlighted") : removeClass(a.header, "highlighted")
}

function setSelected(a, b) {
    b ? (addClass(a.header, "selected"), addClass(a.childContainer, "selected")) : (removeClass(a.header, "selected"), removeClass(a.childContainer, "selected"))
}

function setVisible(a, b) {
    b ? removeClass(a.header, "hidden") : addClass(a.header, "hidden")
}
DocumentStructurePanel.prototype.clearExtraState = function () {
    for (var a = 0; a < this.lastKnownSelectionList.length; a++) {
        var b = this.lastKnownSelectionList[a],
            c = this.items[b.dbId];
        c && (setSelected(c, !1), setHighlighted(c, b === this.lastHighlightNode));
        for (b = b.parent; b;) this.items[b.dbId] && removeClass(this.items[b.dbId].marker, "mselected"), b = b.parent
    }
};
DocumentStructurePanel.prototype.setVisibleStateOnAll = function (a) {
    for (var b in this.items) {
        var c = this.items[b];
        c && setVisible(c, a)
    }
};
DocumentStructurePanel.prototype.setVisibleStateOnNodes = function (a, b) {
    for (var c = 0; c < a.length; c++) {
        var e = a[c],
            d = this.items[e.dbId];
        d && (setVisible(d, b), e.children && this.setVisibleStateOnNodes(e.children, b))
    }
};
DocumentStructurePanel.prototype.appendExtraState = function (a) {
    for (var b = 0; b < a.length; b++) {
        var c = a[b],
            e = this.items[c.dbId];
        e && (setSelected(e, !0), setHighlighted(e, c === this.lastHighlightNode));
        for (c = c.parent; c;) this.items[c.dbId] && addClass(this.items[c.dbId].marker, "mselected"), c = c.parent
    }
};
DocumentStructurePanel.prototype.createItem = function (a, b) {
    var c = this,
        e = b.children && 0 < b.children.length,
        d = document.createElement("li");
    d.className = "item";
    d.data = b;
    a.appendChild(d);
    var g = document.createElement("div");
    g.className = "header";
    g.data = b;
    d.appendChild(g);
    d.header = g;
    d.marker = document.createElement("div");
    d.marker.className = "marker";
    g.appendChild(d.marker);
    if (e) {
        var f = document.createElement("input");
        f.type = "button";
        f.className = "toggleButtonMax";
        g.appendChild(f);
        d.toggleButton = f;
        f.addEventListener("click",
            function (a) {
                c.toggleExpand(d);
                a.stopPropagation();
                return !1
            }, !0)
    }
    f = document.createElement("label");
    f.textContent = b.name;
    e || (f.style.paddingLeft = "0px");
    g.appendChild(f);
    e && (e = document.createElement("ul"), d.childContainer = e, d.childContainer.className = "childContainer", d.appendChild(e));
    g.addEventListener("click", function (a) {
        c.clickItem(a, d);
        return !1
    }, !1);
    g.addEventListener("dblclick", function (a) {
        c.doubleClickItem(a, d);
        return !1
    }, !1);
    g.addEventListener("contextmenu", function (a) {
        c.showContextMenu(c, a, d);
        return !1
    }, !1);
    g.addEventListener("mouseover", function (a) {
        c.viewer.fireEvent({
            type: Autodesk.Viewing.HIGHLIGHT_EVENT,
            dbNode: d.data
        })
    });
    g.addEventListener("mouseout", function (a) {
        d.data === c.lastHighlightNode && c.viewer.fireEvent({
            type: Autodesk.Viewing.HIGHLIGHT_EVENT,
            dbNode: void 0
        })
    });
    setVisible(d, VisibilityManager.isVisible(b));
    this.items[b.dbId] = d
};
DocumentStructurePanel.prototype.createChildren = function (a, b) {
    for (var c = a.children ? a.children.length : 0, e = 0; e < c; e++) this.createItem(b, a.children[e])
};
DocumentStructurePanel.prototype.toggleExpand = function (a) {
    a.expanded ? this.minimize(a) : this.expand(a)
};
DocumentStructurePanel.prototype.expand = function (a) {
    a.expanded || (this.createChildren(a.data, a.childContainer), a.toggleButton.className = "toggleButtonMin", a.expanded = !0, this.setSelectedNodes(this.lastKnownSelectionList))
};
DocumentStructurePanel.prototype.minimize = function (a) {
    a.childContainer.textContent = "";
    a.toggleButton.className = "toggleButtonMax";
    a.expanded = !1
};
DocumentStructurePanel.prototype.setTitleNode = function (a) {
    var b = this.viewer.config.defaultModelStructureTitle;
    b || (b = a.name);
    b || (b = "Model Structure");
    this.title.textContent = b;
    this.title.data = a;
    var c = this;
    this.title.addEventListener("click", function (a) {
        c.clickItem(a, c.title);
        return !1
    }, !1);
    this.title.addEventListener("dblclick", function (a) {
        c.doubleClickItem(a, c.title);
        return !1
    }, !1);
    this.items[a.dbId] = this.title
};
DocumentStructurePanel.prototype.treeLoaded = function (a, b) {
    this.setTitleNode(b);
    this.createChildren(b, a)
};
"undefined" !== typeof window && function (a, b, c) {
    function e(b) {
        if (a.event && a.event.contentOverflow !== c) return {
            x: a.event.offsetX,
            y: a.event.offsetY
        };
        if (b.offsetX !== c && b.offsetY !== c) return {
            x: b.offsetX,
            y: b.offsetY
        };
        var d = b.target.parentNode.parentNode;
        return {
            x: b.layerX - d.offsetLeft,
            y: b.layerY - d.offsetTop
        }
    }

    function d(a, c, d) {
        a = b.createElementNS(v, a);
        for (var e in c) a.setAttribute(e, c[e]);
        "[object Array]" != Object.prototype.toString.call(d) && (d = [d]);
        c = 0;
        for (e = d[0] && d.length || 0; c < e; c++) a.appendChild(d[c]);
        return a
    }

    function g(a) {
        var b, c, d, e, f = a.h % 360 / 60;
        e = a.v * a.s;
        d = e * (1 - Math.abs(f % 2 - 1));
        b = c = a = a.v - e;
        f = ~~f;
        b += [e, d, 0, 0, d, e][f];
        c += [d, e, e, d, 0, 0][f];
        a += [0, 0, d, e, e, d][f];
        d = Math.floor(255 * b);
        c = Math.floor(255 * c);
        a = Math.floor(255 * a);
        return {
            r: d,
            g: c,
            b: a,
            hex: "#" + (16777216 | a | c << 8 | d << 16).toString(16).slice(1)
        }
    }

    function f(a) {
        var b = a.r,
            c = a.g,
            d = a.b;
        if (1 < a.r || 1 < a.g || 1 < a.b) b /= 255, c /= 255, d /= 255;
        var e;
        a = Math.max(b, c, d);
        e = a - Math.min(b, c, d);
        b = (0 == e ? 0 : a == b ? (c - d) / e + (c < d ? 6 : 0) : a == c ? (d - b) / e + 2 : (b - c) / e + 4) % 6 * 60;
        return {
            h: b,
            s: 0 == e ? 0 : e / a,
            v: a
        }
    }

    function k(b, d, f) {
        return function (h) {
            h = h || a.event;
            h = e(h);
            b.h = h.y / d.offsetHeight * 360 + u;
            b.s = b.v = 1;
            var k = g({
                h: b.h,
                s: 1,
                v: 1
            });
            f.style.backgroundColor = k.hex;
            b.callback && b.callback(k.hex, {
                h: b.h - u,
                s: b.s,
                v: b.v
            }, {
                r: k.r,
                g: k.g,
                b: k.b
            }, c, h)
        }
    }

    function h(b, c) {
        return function (d) {
            d = d || a.event;
            d = e(d);
            var f = c.offsetHeight;
            b.s = d.x / c.offsetWidth;
            b.v = (f - d.y) / f;
            f = g(b);
            b.callback && b.callback(f.hex, {
                h: b.h - u,
                s: b.s,
                v: b.v
            }, {
                r: f.r,
                g: f.g,
                b: f.b
            }, d)
        }
    }

    function l(a, b, c) {
        if (!(this instanceof l)) return new l(a, b, c);
        this.h = 0;
        this.v = this.s =
            1;
        if (c) this.callback = c, this.pickerElement = b, this.slideElement = a;
        else {
            a.innerHTML = w;
            this.slideElement = a.getElementsByClassName("slide")[0];
            this.pickerElement = a.getElementsByClassName("picker")[0];
            var d = a.getElementsByClassName("slide-indicator")[0],
                e = a.getElementsByClassName("picker-indicator")[0];
            l.fixIndicators(d, e);
            this.callback = function (a, c, f, g, h) {
                l.positionIndicators(d, e, h, g);
                b(a, c, f)
            }
        } if ("SVG" == s) {
            a = p.cloneNode(!0);
            c = t.cloneNode(!0);
            var f = a.getElementById("gradient-hsv"),
                g = a.getElementsByTagName("rect")[0];
            f.id = "gradient-hsv-" + y;
            g.setAttribute("fill", "url(#" + f.id + ")");
            f = [c.getElementById("gradient-black"), c.getElementById("gradient-white")];
            g = c.getElementsByTagName("rect");
            f[0].id = "gradient-black-" + y;
            f[1].id = "gradient-white-" + y;
            g[0].setAttribute("fill", "url(#" + f[1].id + ")");
            g[1].setAttribute("fill", "url(#" + f[0].id + ")");
            this.slideElement.appendChild(a);
            this.pickerElement.appendChild(c);
            y++
        } else this.slideElement.innerHTML = p, this.pickerElement.innerHTML = t;
        m(this.slideElement, "click", k(this, this.slideElement,
            this.pickerElement));
        m(this.pickerElement, "click", h(this, this.pickerElement));
        n(this, this.slideElement, k(this, this.slideElement, this.pickerElement));
        n(this, this.pickerElement, h(this, this.pickerElement))
    }

    function m(a, b, c) {
        a.attachEvent ? a.attachEvent("on" + b, c) : a.addEventListener && a.addEventListener(b, c, !1)
    }

    function n(a, b, c) {
        var d = !1;
        m(b, "mousedown", function (a) {
            d = !0
        });
        m(b, "mouseup", function (a) {
            d = !1
        });
        m(b, "mouseout", function (a) {
            d = !1
        });
        m(b, "mousemove", function (a) {
            d && c(a)
        })
    }

    function r(a, b, c, d) {
        a.h = b.h %
            360;
        a.s = b.s;
        a.v = b.v;
        b = g(a);
        var e = {
                y: a.h * a.slideElement.offsetHeight / 360,
                x: 0
            },
            f = a.pickerElement.offsetHeight,
            f = {
                x: a.s * a.pickerElement.offsetWidth,
                y: f - a.v * f
            };
        a.pickerElement.style.backgroundColor = g({
            h: a.h,
            s: 1,
            v: 1
        }).hex;
        a.callback && a.callback(d || b.hex, {
            h: a.h,
            s: a.s,
            v: a.v
        }, c || {
            r: b.r,
            g: b.g,
            b: b.b
        }, f, e);
        return a
    }
    var s = a.SVGAngle || b.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML",
        t, p, u = 15,
        v = "http://www.w3.org/2000/svg",
        w = '<div class="picker-wrapper"><div class="picker"></div><div class="picker-indicator"></div></div><div class="slide-wrapper"><div class="slide"></div><div class="slide-indicator"></div></div>';
    "SVG" == s ? (p = d("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        version: "1.1",
        width: "100%",
        height: "100%"
    }, [d("defs", {}, d("linearGradient", {
        id: "gradient-hsv",
        x1: "0%",
        y1: "100%",
        x2: "0%",
        y2: "0%"
    }, [d("stop", {
            offset: "0%",
            "stop-color": "#FF0000",
            "stop-opacity": "1"
        }), d("stop", {
            offset: "13%",
            "stop-color": "#FF00FF",
            "stop-opacity": "1"
        }), d("stop", {
            offset: "25%",
            "stop-color": "#8000FF",
            "stop-opacity": "1"
        }), d("stop", {
            offset: "38%",
            "stop-color": "#0040FF",
            "stop-opacity": "1"
        }), d("stop", {
            offset: "50%",
            "stop-color": "#00FFFF",
            "stop-opacity": "1"
        }),
        d("stop", {
            offset: "63%",
            "stop-color": "#00FF40",
            "stop-opacity": "1"
        }), d("stop", {
            offset: "75%",
            "stop-color": "#0BED00",
            "stop-opacity": "1"
        }), d("stop", {
            offset: "88%",
            "stop-color": "#FFFF00",
            "stop-opacity": "1"
        }), d("stop", {
            offset: "100%",
            "stop-color": "#FF0000",
            "stop-opacity": "1"
        })
    ])), d("rect", {
        x: "0",
        y: "0",
        width: "100%",
        height: "100%",
        fill: "url(#gradient-hsv)"
    })]), t = d("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        version: "1.1",
        width: "100%",
        height: "100%"
    }, [d("defs", {}, [d("linearGradient", {
        id: "gradient-black",
        x1: "0%",
        y1: "100%",
        x2: "0%",
        y2: "0%"
    }, [d("stop", {
        offset: "0%",
        "stop-color": "#000000",
        "stop-opacity": "1"
    }), d("stop", {
        offset: "100%",
        "stop-color": "#CC9A81",
        "stop-opacity": "0"
    })]), d("linearGradient", {
        id: "gradient-white",
        x1: "0%",
        y1: "100%",
        x2: "100%",
        y2: "100%"
    }, [d("stop", {
        offset: "0%",
        "stop-color": "#FFFFFF",
        "stop-opacity": "1"
    }), d("stop", {
        offset: "100%",
        "stop-color": "#CC9A81",
        "stop-opacity": "0"
    })])]), d("rect", {
        x: "0",
        y: "0",
        width: "100%",
        height: "100%",
        fill: "url(#gradient-white)"
    }), d("rect", {
        x: "0",
        y: "0",
        width: "100%",
        height: "100%",
        fill: "url(#gradient-black)"
    })])) : "VML" == s && (p = '<DIV style="position: relative; width: 100%; height: 100%"><v:rect style="position: absolute; top: 0; left: 0; width: 100%; height: 100%" stroked="f" filled="t"><v:fill type="gradient" method="none" angle="0" color="red" color2="red" colors="8519f fuchsia;.25 #8000ff;24903f #0040ff;.5 aqua;41287f #00ff40;.75 #0bed00;57671f yellow"></v:fill></v:rect></DIV>', t = '<DIV style="position: relative; width: 100%; height: 100%"><v:rect style="position: absolute; left: -1px; top: -1px; width: 101%; height: 101%" stroked="f" filled="t"><v:fill type="gradient" method="none" angle="270" color="#FFFFFF" opacity="100%" color2="#CC9A81" o:opacity2="0%"></v:fill></v:rect><v:rect style="position: absolute; left: 0px; top: 0px; width: 100%; height: 101%" stroked="f" filled="t"><v:fill type="gradient" method="none" angle="0" color="#000000" opacity="100%" color2="#CC9A81" o:opacity2="0%"></v:fill></v:rect></DIV>',
        b.namespaces.v || b.namespaces.add("v", "urn:schemas-microsoft-com:vml", "#default#VML"));
    var y = 0;
    l.hsv2rgb = function (a) {
        a = g(a);
        delete a.hex;
        return a
    };
    l.hsv2hex = function (a) {
        return g(a).hex
    };
    l.rgb2hsv = f;
    l.rgb2hex = function (a) {
        return g(f(a)).hex
    };
    l.hex2hsv = function (a) {
        return f(l.hex2rgb(a))
    };
    l.hex2rgb = function (a) {
        return {
            r: parseInt(a.substr(1, 2), 16),
            g: parseInt(a.substr(3, 2), 16),
            b: parseInt(a.substr(5, 2), 16)
        }
    };
    l.prototype.setHsv = function (a) {
        return r(this, a)
    };
    l.prototype.setRgb = function (a) {
        return r(this, f(a),
            a)
    };
    l.prototype.setHex = function (a) {
        return r(this, l.hex2hsv(a), c, a)
    };
    l.positionIndicators = function (a, b, c, d) {
        c && (b.style.left = "auto", b.style.right = "0px", b.style.top = "0px", a.style.top = c.y - a.offsetHeight / 2 + "px");
        d && (b.style.top = d.y - b.offsetHeight / 2 + "px", b.style.left = d.x - b.offsetWidth / 2 + "px")
    };
    l.fixIndicators = function (a, b) {
        b.style.pointerEvents = "none";
        a.style.pointerEvents = "none"
    };
    a.ColorPicker = l
}(window, window.document);
var ContextMenu = function (a) {
    this.viewer = a;
    this.menus = [];
    this.open = !1;
    this.itemWidth = 100;
    this.itemHeight = 25
};
ContextMenu.prototype.show = function (a, b) {
    var c = this.viewer.api.container.getBoundingClientRect(),
        e = a.clientX - c.left,
        c = a.clientY - c.top;
    if (!1 == this.open) {
        var d = this;
        this.showMenu(b, 0, e, c);
        this.open = !0;
        this.hideEventListener = function (a) {
            "menuItem" != a.target.className && d.hide(a)
        };
        document.body.addEventListener("mousedown", this.hideEventListener, !0)
    }
};
ContextMenu.prototype.showMenu = function (a, b, c, e) {
    0 > c && (c = 0);
    0 > e && (e = 0);
    c + this.itemWidth + 10 > this.viewer.canvas.width && (c = this.viewer.canvas.width - this.itemWidth - 10);
    e + Object.keys(a).length * this.itemHeight > this.viewer.canvas.height && (e = this.viewer.canvas.height - Object.keys(a).length * this.itemHeight);
    var d = document.createElement("div");
    d.width = this.itemWidth;
    d.className = "menu";
    d.style.top = e + "px";
    d.style.left = c + "px";
    d.style.zIndex = 10;
    this.viewer.api.container.appendChild(d);
    var g = 0,
        f;
    for (f in a) {
        var k =
            this.createMenuItem(d, f, g),
            g = g + this.itemHeight;
        "object" == typeof a[f] ? this.addSubMenuClickToMenuItem(k, a[f], c + this.itemWidth + 10, e + g) : "function" == typeof a[f] ? this.addCallbackToMenuItem(k, a[f]) : console.warn("Invalid option", a, f)
    }
    d.style.height = g + "px";
    null != this.menus[b] && this.menus[b].parentNode.removeChild(this.menus[b]);
    this.menus[b] = d
};
ContextMenu.prototype.createMenuItem = function (a, b, c) {
    var e = document.createElement("div");
    e.className = "menuItem";
    e.innerHTML = b;
    e.style.top = c + "px";
    a.appendChild(e);
    return e
};
ContextMenu.prototype.addSubMenuClickToMenuItem = function (a, b, c, e) {
    var d = this;
    a.addEventListener("click", function () {
        d.showMenu(b, level + 1, c, e)
    })
};
ContextMenu.prototype.addCallbackToMenuItem = function (a, b) {
    var c = this;
    a.addEventListener("click", function (a) {
        c.hide();
        b();
        a.preventDefault();
        return !1
    })
};
ContextMenu.prototype.hide = function () {
    if (this.open) {
        for (var a = 0; a < this.menus.length; ++a) this.menus[a] && this.menus[a].parentNode.removeChild(this.menus[a]);
        this.menus = [];
        this.open = !1;
        document.body.removeEventListener("mousedown", this.hideEventListener);
        return !0
    }
    return !1
};
ObjectContextMenu = function (a) {
    this.viewerImpl = a;
    this.contextMenu = new ContextMenu(a)
};
ObjectContextMenu.prototype.show = function (a) {
    for (var b = this, c = {}, e = b.viewerImpl.selector.selectedObjects.length, d = !1, g = !1, f = 0; f < e && (VisibilityManager.isVisible(b.viewerImpl.selector.selectedObjects[f]) ? d = !0 : g = !0, !d || !g); f++);
    0 < e && (c.Isolate = function () {
        var a = b.viewerImpl.selector.getSelection();
        b.viewerImpl.selector.clearSelection();
        b.viewerImpl.visibilityManager.isolateMultiple(a)
    }, d && (c["Hide Selected"] = function () {
        var a = b.viewerImpl.selector.getSelection();
        b.viewerImpl.selector.clearSelection();
        b.viewerImpl.visibilityManager.hideMultiple(a)
    }), g && (c["Show Selected"] = function () {
        var a = b.viewerImpl.selector.getSelection();
        b.viewerImpl.selector.clearSelection();
        b.viewerImpl.visibilityManager.showMultiple(a)
    }));
    c["Show All"] = function () {
        b.viewerImpl.visibilityManager.isolate(null)
    };
    0 < e && (c.Focus = function () {
        b.viewerImpl.controls.fitToView()
    });
    this.contextMenu.show(a, c);
    return !1
};
ObjectContextMenu.prototype.hide = function () {
    return this.contextMenu.hide()
};

function OptionSlider(a, b, c, e) {
    function d(a) {
        a.target != g.stepperElement && (g.stepperElement.value = g.sliderElement.value);
        g.fireChangeEvent()
    }
    var g = this;
    this.tbody = e;
    this.sliderRow = this.tbody.insertRow(-1);
    e = this.sliderRow.insertCell(0);
    e.style.fontStyle = "italic";
    this.caption = document.createElement("div");
    this.caption.innerHTML = a + ":";
    this.sliderElement = document.createElement("input");
    this.sliderElement.type = "range";
    this.sliderElement.id = a + "_slider";
    this.sliderElement.min = b;
    this.sliderElement.max = c;
    this.sliderElement.style.width = "100%";
    e.appendChild(this.caption);
    e.appendChild(this.sliderElement);
    e = this.sliderRow.insertCell(1);
    this.stepperElement = document.createElement("input");
    this.stepperElement.type = "number";
    this.stepperElement.id = a + "_stepper";
    this.stepperElement.min = b;
    this.stepperElement.max = c;
    this.stepperElement.step = 1;
    this.stepperElement.style.resize = "none";
    e.appendChild(this.stepperElement);
    e.style.width = "32px";
    this.blockEvent = !1;
    this.stepperElement.addEventListener("change", function (a) {
        a.target !=
            g.sliderElement && (g.sliderElement.value = g.stepperElement.value);
        g.fireChangeEvent()
    }, !1);
    this.sliderElement.addEventListener("change", d, !1);
    this.sliderElement.addEventListener("input", d, !1)
}
OptionSlider.prototype = Object.create(THREE.EventDispatcher.prototype);
OptionSlider.prototype.fireChangeEvent = function () {
    if (!this.blockEvent) {
        this.value = this.sliderElement.value;
        var a = new CustomEvent("change", {
            target: this,
            value: this.sliderElement.value
        });
        this.dispatchEvent(a)
    }
};
OptionSlider.prototype.setValue = function (a) {
    this.blockEvent = !0;
    this.value = a;
    this.sliderElement.value = a;
    this.stepperElement.value = a;
    this.blockEvent = !1
};

function OptionCheckbox(a, b, c) {
    THREE.EventDispatcher.call(this.prototype);
    var e = this;
    this.tbody = b;
    this.sliderRow = this.tbody.insertRow(-1);
    b = this.sliderRow.insertCell(0);
    b.style.fontStyle = "italic";
    this.caption = document.createElement("div");
    this.caption.innerHTML = a + ":";
    b.appendChild(this.caption);
    b = this.sliderRow.insertCell(1);
    this.checkElement = document.createElement("input");
    this.checkElement.type = "checkbox";
    this.checkElement.id = a + "_check";
    this.checkElement.checked = c;
    b.appendChild(this.checkElement);
    this.blockEvent = !1;
    this.checked = c;
    this.checkElement.addEventListener("change", function (a) {
        e.fireChangeEvent()
    }, !1)
}
OptionCheckbox.prototype = Object.create(THREE.EventDispatcher.prototype);
OptionCheckbox.prototype.fireChangeEvent = function () {
    if (!this.blockEvent) {
        this.checked = this.checkElement.checked;
        var a = new CustomEvent("change", {
            target: this,
            value: this.checkElement.checked
        });
        this.dispatchEvent(a)
    }
};
OptionCheckbox.prototype.setValue = function (a) {
    this.blockEvent = !0;
    this.checked = a;
    this.checkElement.checked = a;
    this.blockEvent = !1
};

function OptionDropDown(a, b, c, e) {
    THREE.EventDispatcher.call(this.prototype);
    var d = this;
    this.tbody = b;
    this.sliderRow = this.tbody.insertRow(-1);
    b = this.sliderRow.insertCell(0);
    b.style.fontStyle = "italic";
    this.caption = document.createElement("div");
    this.caption.innerHTML = a + ":";
    b.appendChild(this.caption);
    b = this.sliderRow.insertCell(1);
    this.dropdownElement = document.createElement("select");
    this.dropdownElement.id = a + "_dropdown";
    for (a = 0; a < c.length; a++) {
        var g = document.createElement("option");
        g.value = a;
        g.text =
            c[a];
        this.dropdownElement.add(g)
    }
    this.selectedIndex = this.dropdownElement.selectedIndex = e;
    b.appendChild(this.dropdownElement);
    this.blockEvent = !1;
    this.dropdownElement.addEventListener("change", function (a) {
        d.fireChangeEvent()
    }, !1)
}
OptionDropDown.prototype = Object.create(THREE.EventDispatcher.prototype);
OptionDropDown.prototype.fireChangeEvent = function () {
    if (!this.blockEvent) {
        this.selectedIndex = this.dropdownElement.selectedIndex;
        var a = new CustomEvent("change", {
            target: this,
            value: this.selectedIndex
        });
        this.dispatchEvent(a)
    }
};

function RenderOptionsPanel(a) {
    var b = this;
    this.viewer = a;
    this.dockPanel = new DockingPanel(a, "RenderOptionsPanel", "Rendering Options", !1);
    this.table = document.createElement("table");
    this.table.id = "optionsgrid";
    this.table.className = "tftable";
    this.tbody = document.createElement("tbody");
    this.table.appendChild(this.tbody);
    this.dockPanel.container.appendChild(this.table);
    this.bgSelect = new OptionDropDown("Background", this.tbody, ["Grey", "Blue (light)", "Blue (dark)", "Sky env map", "From model"], 0);
    this.bgSelect.addEventListener("change",
        function (c) {
            c = b.bgSelect.selectedIndex;
            0 == c ? a.impl.setClearColors(230, 230, 230, 150, 150, 150) : 1 == c ? a.impl.setClearColors(200, 233, 255, 100, 116, 127) : 2 == c ? a.impl.setClearColors(41, 76, 120, 1, 2, 3) : 3 == c ? (c = RESOURCE_ROOT + "environments/sky_", a.setEnvironmentMap([c + "px.jpg", c + "nx.jpg", c + "py.jpg", c + "ny.jpg", c + "pz.jpg", c + "nz.jpg"])) : 4 == c && a.impl.resetCubeMap()
        });
    this.saoToggle = new OptionCheckbox("SSAO Enabled", this.tbody, !0);
    this.saoToggle.addEventListener("change", function (c) {
        a.setQualityLevel(b.saoToggle.checked,
            a.impl.renderer.settings.antialias)
    });
    this.saoRadius = new OptionSlider("SSAO Radius", 0, 300, this.tbody);
    this.saoRadius.setValue(100);
    this.saoRadius.addEventListener("change", function (c) {
        a.impl.renderer.setAOOptions(b.saoRadius.value, b.saoIntensity.value);
        a.impl.renderer.composeFinalFrame(!1)
    });
    this.saoIntensity = new OptionSlider("SSAO Intensity", 0, 300, this.tbody);
    this.saoIntensity.setValue(75);
    this.saoIntensity.addEventListener("change", function (c) {
        a.impl.renderer.setAOOptions(b.saoRadius.value, b.saoIntensity.value);
        a.impl.renderer.composeFinalFrame(!1)
    });
    this.toneMapMethod = new OptionDropDown("Tonemap method", this.tbody, "None;Linear;Reinhard RGB;Filmic RGB;Exp RGB;Canon".split(";"), 0);
    this.toneMapMethod.addEventListener("change", function (c) {
        a.impl.renderer.setTonemapMethod(b.toneMapMethod.selectedIndex);
        var e, d;
        e = b.toneMapMethod.selectedIndex;
        0 == e ? (e = 1, c = 0, d = 1) : (d = 2, c = 0, e = 5 == e ? 4.4 : 1.7);
        b.gamma.setValue(e);
        a.impl.renderer.setGamma(e);
        b.exposureBias.setValue(c);
        a.impl.renderer.setExposureBias(c);
        b.whiteScale.setValue(d);
        a.impl.renderer.setWhiteScale(d);
        a.impl.dir_light1.intensity = b.whiteScale.value;
        a.impl.needsClear = !0
    });
    this.gamma = new OptionSlider("Gamma", 0, 5, this.tbody);
    this.gamma.setValue(1);
    this.gamma.sliderElement.step = this.gamma.stepperElement.step = 0.05;
    this.gamma.addEventListener("change", function (c) {
        a.impl.renderer.setGamma(b.gamma.value);
        a.impl.renderer.composeFinalFrame(!1)
    });
    this.exposureBias = new OptionSlider("Exposure bias", -5, 5, this.tbody);
    this.exposureBias.setValue(0);
    this.exposureBias.sliderElement.step =
        this.exposureBias.stepperElement.step = 0.1;
    this.exposureBias.addEventListener("change", function (c) {
        a.impl.renderer.setExposureBias(b.exposureBias.value);
        a.impl.renderer.composeFinalFrame(!1)
    });
    this.whiteScale = new OptionSlider("Direct Light Intensity", 0, 10, this.tbody);
    this.whiteScale.setValue(1);
    this.whiteScale.sliderElement.step = this.whiteScale.stepperElement.step = 0.1;
    this.whiteScale.addEventListener("change", function (c) {
        a.impl.dir_light1.intensity = b.whiteScale.value;
        a.impl.renderer.setWhiteScale(b.whiteScale.value);
        a.impl.needsClear = !0
    });
    this.fovAngle = new OptionSlider("Field of View (degrees)", 6.88, 100, this.tbody);
    this.fovAngle.setValue(45);
    this.fovAngle.addEventListener("change", function (c) {
        a.setFOV(parseFloat(b.fovAngle.value))
    });
    this.viewer.addEventListener("cameraChanged", function (c) {
        c = parseFloat(b.fovAngle.value);
        var e = a.getFOV();
        c != e && b.fovAngle.setValue(e)
    });
    this.dockPanel.container.style.width = "300px";
    this.dockPanel.container.style.top = "180px";
    this.dockPanel.container.style.left = "220px";
    this.dockPanel.container.style.height =
        "420px";
    this.dockPanel.container.dock = !0;
    this.dockPanel.container.style.display = "none"
};

function AlertBox() {}
AlertBox.instances = [];
AlertBox.displayError = function (a, b, c, e, d) {
    var g = document.createElement("div");
    g.className = "alertBox error";
    a.appendChild(g);
    e || (e = RESOURCE_ROOT + "icons/error_item_not_found.png");
    var f = document.createElement("img");
    f.className = "alertBoxImage";
    f.src = e;
    g.appendChild(f);
    e = document.createElement("div");
    e.className = "alertBoxMsg";
    g.appendChild(e);
    c || (c = "Error Occurred");
    f = document.createElement("div");
    f.className = "alertBoxTitle";
    f.textContent = c;
    e.appendChild(f);
    c = document.createElement("div");
    c.className =
        "alertBoxText";
    c.textContent = b;
    e.appendChild(c);
    d && (b = document.createElement("div"), b.className = "alertBoxContent", b.appendChild(d), e.appendChild(b));
    d = document.createElement("div");
    d.className = "alertBoxOK";
    d.textContent = "OK";
    var k = {
        alertBox: g,
        container: a
    };
    d.addEventListener("click", function (b) {
        g.style.visibility = "hidden";
        a.removeChild(g);
        AlertBox.instances.splice(AlertBox.instances.indexOf(k), 1)
    });
    g.appendChild(d);
    g.style.visibility = "visible";
    AlertBox.instances.push(k)
};
AlertBox.dismiss = function () {
    if (0 < AlertBox.instances.length) {
        var a = AlertBox.instances.pop();
        a.alertBox.style.visibility = "hidden";
        a.container.removeChild(a.alertBox);
        return !0
    }
    return !1
};

function TreeDelegate() {}
TreeDelegate.prototype.isTreeNodeGroup = function (a, b) {
    throw "isGroup is not implemented.";
};
TreeDelegate.prototype.getTreeNodeId = function (a) {
    throw "getId is not implemented.";
};
TreeDelegate.prototype.getTreeNodeLabel = function (a) {
    return a.name
};
TreeDelegate.prototype.shouldCreateTreeNode = function (a) {
    return !0
};
TreeDelegate.prototype.onTreeNodeClick = function (a, b, c) {};
TreeDelegate.prototype.onTreeNodeHover = function (a, b, c) {};
TreeDelegate.prototype.getTreeNodeClass = function (a) {
    return ""
};

function Tree(a, b, c, e) {
    this.myDelegate = a;
    this.mySelectedIds = [];
    this.myParentContainerId = c;
    this.myRootContainerId = c + "-treeview";
    this.myInternalIds = [];
    this.myInternalIdCounter = 0;
    this.jQuery = (this.myOptions = e) && e.jQuery ? e.jQuery : $;
    this.jQuery('<div id="' + this.myRootContainerId + '" class="treeview"></div>').appendTo("#" + c);
    this.createElement(b, this.myRootContainerId)
}
Tree.prototype.show = function (a) {
    a ? this.jQuery("#" + this.myRootContainerId).fadeIn() : this.jQuery("#" + this.myRootContainerId).hide()
};
Tree.prototype.getRootContainerId = function () {
    return this.myRootContainerId
};
Tree.prototype.delegate = function () {
    return this.myDelegate
};
Tree.prototype.isCollapsed = function (a) {
    a = "#" + this.getInternalId(a, !1);
    return this.jQuery(a).hasClass("collapsed")
};
Tree.prototype.setCollapsed = function (a, b) {
    var c = "#" + this.getInternalId(a, !1);
    if (b) {
        if (!this.jQuery(c).hasClass("collapsed")) return this.jQuery(c).addClass("collapsed"), this.jQuery(c).removeClass("expanded"), !0
    } else if (this.jQuery(c).hasClass("collapsed")) return this.jQuery(c).removeClass("collapsed"), this.jQuery(c).addClass("expanded"), !0;
    return !1
};
Tree.prototype.addToSelection = function (a) {
    for (var b in a) {
        var c = a[b],
            e;
        e = c; - 1 == this.mySelectedIds.indexOf(e) ? (this.mySelectedIds.push(e), e = !0) : e = !1;
        e && (c = this.getInternalId(c, !1), this.jQuery("#" + c).addClass("selected"))
    }
};
Tree.prototype.removeFromSelection = function (a) {
    for (var b in a) {
        var c = a[b],
            e;
        e = this.mySelectedIds.indexOf(c); - 1 != e ? (this.mySelectedIds.splice(e, 1), e = !0) : e = !1;
        e && (c = this.getInternalId(c, !1), this.jQuery("#" + c).removeClass("selected"))
    }
};
Tree.prototype.setSelection = function (a) {
    this.removeFromSelection(this.mySelectedIds);
    this.addToSelection(a);
    return this.mySelectedIds
};
Tree.prototype.clearSelection = function () {
    this.removeFromSelection(this.mySelectedIds)
};
Tree.prototype.isSelected = function (a) {
    a = this.getInternalId(a, !1);
    return this.jQuery("#" + a).hasClass("selected")
};
Tree.prototype.getInternalId = function (a, b) {
    void 0 === this.myInternalIds[a] && b && (this.myInternalIds[a] = this.myRootContainerId + "-node-" + this.myInternalIdCounter, this.myInternalIdCounter++);
    return this.myInternalIds[a]
};
Tree.prototype.createElement = function (a, b) {
    if (a) {
        var c = this;
        if (this.myDelegate.shouldCreateTreeNode(a)) {
            var e = c.myDelegate.getTreeNodeId(a),
                e = this.getInternalId(e, !0),
                d = "#" + e;
            if (c.myDelegate.isTreeNodeGroup(a)) {
                this.jQuery('<group id="' + e + '" class="expanded"></group>').appendTo(this.jQuery("#" + b)).hover(function () {
                    c.myDelegate.onTreeNodeHover(c, a)
                });
                var g = "#header" + e;
                this.jQuery('<header id="header' + e + '"></header>').appendTo(this.jQuery(d)).click(function (b) {
                    c.myDelegate.onTreeNodeClick(c, a, b)
                });
                this.jQuery("<icon></icon>").appendTo(this.jQuery(g)).click(function (a) {
                    a.stopPropagation();
                    c.jQuery(d).toggleClass("collapsed");
                    c.jQuery(d).toggleClass("expanded")
                });
                this.jQuery("<label>" + c.myDelegate.getTreeNodeLabel(a) + "</label>").appendTo(this.jQuery(g));
                for (var g = a.children ? a.children.length : 0, f = 0; f < g; ++f) c.createElement(a.children[f], e)
            } else this.jQuery('<leaf id="' + e + '"></leaf>').appendTo(this.jQuery("#" + b)).hover(function () {
                c.myDelegate.onTreeNodeHover(c, a)
            }), g = "#header" + e, this.jQuery('<header id="header' +
                e + '"></header>').appendTo(this.jQuery(d)).click(function (b) {
                c.myDelegate.onTreeNodeClick(c, a, b)
            }), this.jQuery("<icon></icon>").appendTo(this.jQuery(g)), this.jQuery("<label>" + c.myDelegate.getTreeNodeLabel(a) + "</label>").appendTo(this.jQuery(g));
            this.jQuery(d).addClass(c.myDelegate.getTreeNodeClass(a))
        }
    }
};

function BrowserDelegate() {}
BrowserDelegate.prototype.getNodeId = function (a) {
    throw "getId is not implemented.";
};
BrowserDelegate.prototype.getNodeLabel = function (a) {
    return a.name
};
BrowserDelegate.prototype.getNodeClass = function (a) {
    return ""
};
BrowserDelegate.prototype.hasThumbnail = function (a) {
    return !1
};
BrowserDelegate.prototype.getThumbnail = function (a) {
    return null
};
BrowserDelegate.prototype.onNodeClick = function (a, b, c) {};
BrowserDelegate.prototype.onNodeHover = function (a, b, c) {};
BrowserDelegate.prototype.hasContent = function (a) {
    return !1
};
BrowserDelegate.prototype.addContent = function (a, b) {};

function Browser(a, b, c, e) {
    this.myDelegate = a;
    this.mySelectedIds = [];
    this.myParentContainderId = c;
    this.myRootContainerId = c + "-browserview";
    this.myInternalIds = [];
    this.myInternalIdCounter = 0;
    this.jQuery = (this.myOptions = e) && e.jQuery ? e.jQuery : $;
    this.jQuery('<div id="' + this.myRootContainerId + '" class="browserview"></div>').appendTo("#" + this.myParentContainderId);
    this.createElements(b, this.myRootContainerId)
}
Browser.prototype.show = function (a) {
    a ? this.jQuery("#" + this.myRootContainerId).fadeIn() : this.jQuery("#" + this.myRootContainerId).hide()
};
Browser.prototype.getRootContainerId = function () {
    return this.myRootContainerId
};
Browser.prototype.delegate = function () {
    return this.myDelegate
};
Browser.prototype.addToSelection = function (a) {
    for (var b in a) {
        var c = a[b],
            e;
        e = c; - 1 == this.mySelectedIds.indexOf(e) ? (this.mySelectedIds.push(e), e = !0) : e = !1;
        e && (c = this.getInternalId(c, !1), this.jQuery("#" + c).addClass("selected"))
    }
};
Browser.prototype.removeFromSelection = function (a) {
    for (var b in a) {
        var c = a[b],
            e;
        e = this.mySelectedIds.indexOf(c); - 1 != e ? (this.mySelectedIds.splice(e, 1), e = !0) : e = !1;
        e && (c = this.getInternalId(c, !1), this.jQuery("#" + c).removeClass("selected"))
    }
};
Browser.prototype.setSelection = function (a) {
    this.removeFromSelection(this.mySelectedIds);
    this.addToSelection(a);
    return this.mySelectedIds
};
Browser.prototype.clearSelection = function () {
    this.removeFromSelection(this.mySelectedIds)
};
Browser.prototype.getInternalId = function (a, b) {
    void 0 === this.myInternalIds[a] && b && (this.myInternalIds[a] = this.myRootContainerId + "-node-" + this.myInternalIdCounter, this.myInternalIdCounter++);
    return this.myInternalIds[a]
};
Browser.prototype.createElements = function (a, b) {
    if (a)
        for (var c = 0; c < a.length; c++) this.createElement(a[c], b)
};
Browser.prototype.createElement = function (a, b) {
    var c = this,
        e = c.myDelegate.getNodeId(a),
        e = c.getInternalId(e, !0),
        d = "#" + e;
    this.jQuery('<item id="' + e + '"></item>').appendTo(this.jQuery("#" + b)).hover(function () {
        c.myDelegate.onNodeHover(c, a)
    });
    this.jQuery("#" + e).click(function (b) {
        c.jQuery(".flipped").removeClass("flipped");
        c.myDelegate.onNodeClick(c, a, b)
    });
    var g = this.jQuery('<div id="card' + e + '" class="card"></div>');
    g.appendTo(this.jQuery(d));
    var f = this.jQuery('<div class="browserElement"></div>');
    f.appendTo(g);
    g = c.myDelegate.getNodeLabel(a);
    this.jQuery("<label>" + g + "</label>").appendTo(f).click(function (b) {
        c.myDelegate.onNodeClick(c, a, b)
    });
    (g = c.myDelegate.getThumbnail(a)) && this.jQuery('<img class="thumb" src="' + g + '" ></img>').appendTo(f).click(function (b) {
        c.myDelegate.onNodeClick(c, a, b)
    });
    c.myDelegate.hasContent(a) && c.myDelegate.addContent(a, e);
    this.jQuery(d).addClass(c.myDelegate.getNodeClass(a))
};
var ErrorInfoData = {
    1: {
        img: "icons/error_reload_in_viewer.png",
        header: "Oops",
        text: "Sorry. We seem to have some technical difficulties and couldn't complete your request.",
        content: "<ul><li>Try loading the item again.</li><li>Please verify your Internet connection, and refresh the browser to see if that fixes the problem.</li></ul>"
    },
    2: {
        img: "icons/error_unsupported_file_type.png",
        header: "Oops",
        text: "Sorry. The item you are trying to view was not processed completely.",
        content: "<ul><li>Try loading the item again.</li><li>Please upload the file again to see if that fixes the issue.</li></ul>"
    },
    3: {
        img: "icons/error_reload_in_viewer.png",
        header: "Oops",
        text: "Sorry. We seem to have some technical difficulties and couldn't complete your request.",
        content: "<ul><li>Try loading the item again.</li><li>Please verify your Internet connection, and refresh the browser to see if that fixes the problem.</li></ul>"
    },
    4: {
        img: "icons/error_unlock_upload.png",
        header: "No access",
        text: "Sorry. You don\u2019t have the required privileges to access this item.",
        content: "<ul><li>Please contact the author.</li></ul>"
    },
    5: {
        img: "icons/error_item_not_found.png",
        header: "Oops",
        text: "Sorry. We can\u2019t display the item you are looking for. It may not have been processed yet. It may have been moved, deleted, or you may be using a corrupt file or unsupported file format.",
        content: '<ul><li>Try loading the item again.</li><li>Try uploading the file again to see if that fixes the issue.</li><li><a href="http://help.autodesk.com/view/ADSK360/ENU/?guid=GUID-488804D0-B0B0-4413-8741-4F5EE0FACC4A" target="_blank">See a list of supported formats.</a></li></ul>'
    },
    6: {
        img: "icons/error_reload_in_viewer.png",
        header: "Oops",
        text: "Sorry. We seem to have some technical difficulties and couldn't complete your request.",
        content: "<ul><li>Try loading the item again.</li><li>Please verify your Internet connection, and refresh the browser to see if that fixes the problem.</li></ul>"
    },
    7: {
        img: "icons/error_reload_in_viewer.png",
        header: "Network problem",
        text: "Sorry. We seem to have some technical difficulties and couldn't complete your request.",
        content: "<ul><li>Try loading the item again.</li><li>Please verify your Internet connection, and refresh the browser to see if that fixes the problem.</li></ul>"
    },
    8: {
        img: "icons/error_unsupported_file_type.png",
        header: "Oops",
        text: "Sorry. We couldn\u2019t show the item because your browser doesn\u2019t support 3D viewing.",
        content: '<ul><li>Please use Google Chrome, Firefox or another browser that supports WebGL 3D graphics.</li><li><a href="http://help.autodesk.com/view/ADSK360/ENU/?guid=GUID-6BD255B4-FB67-4909-9332-3A5905076E0A" target="_blank">See a list of browsers supporting WebGL 3D graphics.</a></li></ul>'
    },
    9: {
        img: "icons/error_item_not_found.png",
        header: "No viewable content",
        text: "There\u2019s nothing to display for this item. It may not have been processed or it may not have content we can display.",
        content: "<ul><li>Please contact the author.</li><li>Try uploading the file again to see if that fixes the issue.</li></ul>"
    }
};
ErrorHandler = function () {};
ErrorHandler.prototype.constructor = ErrorHandler;
ErrorHandler.reportError = function (a, b, c) {
    var e = ErrorInfoData[b];
    if (e) {
        c = e.text;
        b = e.header;
        var d = RESOURCE_ROOT + e.img,
            e = e.content,
            g = null;
        e && (g = document.createElement("div"), g.innerHTML = e);
        AlertBox.displayError(a, c, b, d, g)
    } else AlertBox.displayError(a, c)
};
ErrorHandler.getErrorCode = function (a) {
    return 403 === a || 401 === a ? Autodesk.Viewing.ErrorCodes.NETWORK_ACCESS_DENIED : 404 === a ? Autodesk.Viewing.ErrorCodes.NETWORK_FILE_NOT_FOUND : 500 <= a ? Autodesk.Viewing.ErrorCodes.NETWORK_SERVER_ERROR : Autodesk.Viewing.ErrorCodes.NETWORK_UNHANDLED_RESPONSE_CODE
};
/*
 Copyright (c) 2013 Autodesk Inc. */
AutodeskNamespace("Autodesk.Viewing");
Autodesk.Viewing.SELECTION_CHANGED_EVENT = "selection";
Autodesk.Viewing.ISOLATE_EVENT = "isolate";
Autodesk.Viewing.HIDE_EVENT = "hide";
Autodesk.Viewing.SHOW_EVENT = "show";
Autodesk.Viewing.CAMERA_CHANGE_EVENT = "cameraChanged";
Autodesk.Viewing.HIGHLIGHT_EVENT = "highlight";
Autodesk.Viewing.GEOMETRY_LOADED_EVENT = "geometry_loaded";
var NAVIGATION_MODE = {
    ORBIT: 0,
    PAN: 1,
    DOLLY: 2,
    ROLL: 3,
    FOV: 4,
    OTHER: 5
};
Autodesk.Viewing.BaseViewer3D = function (a, b) {
    Autodesk.Viewing.Viewer.call(this, a, b);
    if ("CANVAS" === this.container.nodeName) throw "Viewer must be initialized on a div [temporary]";
    this.canvas = document.createElement("canvas");
    this.canvas.tabIndex = 0;
    var c = this.getDimensions();
    this.canvas.width = c.width;
    this.canvas.height = c.height;
    this.container.appendChild(this.canvas);
    this.canvas.viewer = this
};
Autodesk.Viewing.BaseViewer3D.prototype = Object.create(Autodesk.Viewing.Viewer.prototype);
Autodesk.Viewing.BaseViewer3D.prototype.constructor = Autodesk.Viewing.BaseViewer3D;
Autodesk.Viewing.BaseViewer3D.kDefaultCanvasConfig = {
    click: {
        onObject: ["setCOI"],
        offObject: ["deselectAll"]
    },
    clickCtrl: {
        onObject: ["selectToggle"]
    },
    clickCtrlShift: {
        onObject: ["deselectAll"],
        offObject: ["deselectAll"]
    }
};
Autodesk.Viewing.BaseViewer3D.prototype.initialize = function () {
    var a = this.detectWebGL();
    if (0 >= a) return ErrorHandler.reportError(this.container, Autodesk.Viewing.ErrorCodes.BROWSER_WEBGL_NOT_SUPPORTED), !1;
    var b = this;
    this.impl = new Viewer3DImpl(this.canvas, this);
    if (4096 == a) return ErrorHandler.reportError(this.container, Autodesk.Viewing.ErrorCodes.BROWSER_WEBGL_NOT_SUPPORTED), !1;
    this.setCanvasClickBehavior(this.config && this.config.canvasConfig ? this.config.canvasConfig : Autodesk.Viewing.BaseViewer3D.kDefaultCanvasConfig);
    this.private_resize = function () {
        b.resize()
    };
    window.addEventListener("resize", this.private_resize, !1);
    this.loader = document.createElement("div");
    this.loader.id = "loader";
    this.loader.className = "loaderoverlay";
    this.container.appendChild(this.loader);
    this.loaderimage = document.createElement("img");
    this.loaderimage.id = "loaderimage";
    this.loaderimage.className = "loaderimage";
    this.loaderimage.alt = "";
    this.loaderimage.src = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiIgd2lkdGg9IjEyOCIgaGVpZ2h0PSIxMjgiIGZpbGw9IndoaXRlIj4KICA8Y2lyY2xlIHRyYW5zZm9ybT0idHJhbnNsYXRlKDggMCkiIGN4PSIwIiBjeT0iMTYiIHI9IjAiPiAKICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9InIiIHZhbHVlcz0iMDsgNDsgMDsgMCIgZHVyPSIxLjJzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgYmVnaW49IjAiCiAgICAgIGtleXRpbWVzPSIwOzAuMjswLjc7MSIga2V5U3BsaW5lcz0iMC4yIDAuMiAwLjQgMC44OzAuMiAwLjYgMC40IDAuODswLjIgMC42IDAuNCAwLjgiIGNhbGNNb2RlPSJzcGxpbmUiIC8+CiAgPC9jaXJjbGU+CiAgPGNpcmNsZSB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNiAwKSIgY3g9IjAiIGN5PSIxNiIgcj0iMCI+IAogICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgdmFsdWVzPSIwOyA0OyAwOyAwIiBkdXI9IjEuMnMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiBiZWdpbj0iMC4zIgogICAgICBrZXl0aW1lcz0iMDswLjI7MC43OzEiIGtleVNwbGluZXM9IjAuMiAwLjIgMC40IDAuODswLjIgMC42IDAuNCAwLjg7MC4yIDAuNiAwLjQgMC44IiBjYWxjTW9kZT0ic3BsaW5lIiAvPgogIDwvY2lyY2xlPgogIDxjaXJjbGUgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjQgMCkiIGN4PSIwIiBjeT0iMTYiIHI9IjAiPiAKICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9InIiIHZhbHVlcz0iMDsgNDsgMDsgMCIgZHVyPSIxLjJzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgYmVnaW49IjAuNiIKICAgICAga2V5dGltZXM9IjA7MC4yOzAuNzsxIiBrZXlTcGxpbmVzPSIwLjIgMC4yIDAuNCAwLjg7MC4yIDAuNiAwLjQgMC44OzAuMiAwLjYgMC40IDAuOCIgY2FsY01vZGU9InNwbGluZSIgLz4KICA8L2NpcmNsZT4KPC9zdmc+Cg==";
    this.loader.appendChild(this.loaderimage);
    this.loader.style.visibility = "visible";
    a = window.devicePixelRatio || 1;
    this.loaderimage.style.top = this.canvas.height / (2 * a) - 64 + "px";
    this.loaderimage.style.left = this.canvas.width / (2 * a) - 64 + "px";
    this.addEventListener(Autodesk.Viewing.ERROR_EVENT, function (a) {
        b.loader.style.display = "None"
    });
    return !0
};
Autodesk.Viewing.BaseViewer3D.prototype.load = function (a, b, c) {
    return this.loadModel(a, null, b, c)
};
Autodesk.Viewing.BaseViewer3D.prototype.uninitialize = function (a) {
    window.removeEventListener("resize", this.private_resize, !1);
    this.container && this.container.parentNode.removeChild(this.container);
    this.impl && this.impl.uninitialize();
    Autodesk.Viewing.Viewer.prototype.uninitialize.call(this)
};
Autodesk.Viewing.BaseViewer3D.prototype.detectWebGL = function () {
    if (_isIE11 && !ENABLE_DEBUG) return 4096;
    if (window.WebGLRenderingContext) {
        for (var a = document.createElement("canvas"), b = ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"], c = !1, e = 0; 4 > e; e++) try {
            if ((c = a.getContext(b[e])) && "function" === typeof c.getParameter) return 1
        } catch (d) {}
        return 0
    }
    return -1
};
Autodesk.Viewing.BaseViewer3D.prototype.resize = function () {
    var a = window.devicePixelRatio || 1;
    this.loaderimage.style.top = this.canvas.clientHeight * a / 2 - 64 + "px";
    this.loaderimage.style.left = this.canvas.clientWidth * a / 2 - 64 + "px";
    return this.impl.resize(this.container.clientWidth, this.container.clientHeight)
};
Autodesk.Viewing.BaseViewer3D.prototype.loadModel = function (a, b, c, e) {
    var d = this;
    return this.impl.loadSvf(a, b, function () {
        d.loader.style.display = "None";
        c && c()
    }, e)
};
Autodesk.Viewing.BaseViewer3D.prototype.getCamera = function () {
    return this.impl.camera
};
Autodesk.Viewing.BaseViewer3D.prototype.setViewFromArray = function (a) {
    this.impl.setViewFromArray(a)
};
Autodesk.Viewing.BaseViewer3D.prototype.setViewFromFile = function () {
    this.impl.setViewFromFile()
};
Autodesk.Viewing.BaseViewer3D.prototype.getProperties = function (a, b) {
    this.impl.svfloader.getProperties(a, b)
};
Autodesk.Viewing.BaseViewer3D.prototype.getObjectTree = function (a) {
    this.impl.svfloader.getObjectTree(a)
};
Autodesk.Viewing.BaseViewer3D.prototype.setCanvasClickBehavior = function (a) {
    this.impl.controls.setClickBehavior(a)
};
Autodesk.Viewing.BaseViewer3D.prototype.search = function (a, b) {
    var c = this;
    this.searchText = a;
    c.impl.svf && c.impl.svf.loadDone ? c.impl.search(a, b) : this.getObjectTree(function (e) {
        c.impl.search(a, b)
    })
};
Autodesk.Viewing.BaseViewer3D.prototype.isolate = function (a) {
    Array.isArray(a) ? this.impl.visibilityManager.isolateMultiple(a) : this.impl.visibilityManager.isolate(a)
};
Autodesk.Viewing.BaseViewer3D.prototype.isolateById = function (a) {
    function b(b) {
        (e = Array.isArray(a) ? d.impl.getNodesByIds(a) : d.impl.getNodesByIds([a])) && d.isolate(e)
    }

    function c(a) {
        this.getObjectTree(b);
        d.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, c)
    }
    var e = [],
        d = this;
    this.impl.svf && this.impl.svf.loadDone ? this.getObjectTree(b) : this.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, c)
};
Autodesk.Viewing.BaseViewer3D.prototype.setBackgroundColor = function (a, b, c, e, d, g) {
    this.impl.setClearColors(a, b, c, e, d, g)
};
Autodesk.Viewing.BaseViewer3D.prototype.toggleSelect = function (a) {
    this.impl.selector.toggleSelectionId(a)
};
Autodesk.Viewing.BaseViewer3D.prototype.select = function (a) {
    "number" === typeof a && (a = [a]);
    this.impl.selector.setSelectionIds(a)
};
Autodesk.Viewing.BaseViewer3D.prototype.deselect = function (a) {
    throw Error("not implemented yet");
};
Autodesk.Viewing.BaseViewer3D.prototype.clearSelection = function () {
    this.impl.selector.clearSelection()
};
Autodesk.Viewing.BaseViewer3D.prototype.hide = function (a) {
    Array.isArray(a) ? this.impl.visibilityManager.hideMultiple(a) : this.impl.visibilityManager.hide(a)
};
Autodesk.Viewing.BaseViewer3D.prototype.show = function (a) {
    Array.isArray(a) ? this.impl.visibilityManager.showMultiple(a) : this.impl.visibilityManager.show(a)
};
Autodesk.Viewing.BaseViewer3D.prototype.showAll = function () {
    this.impl.visibilityManager.isolateNone()
};
Autodesk.Viewing.BaseViewer3D.prototype.hideAll = function () {
    throw Error("not implemented yet");
};
Autodesk.Viewing.BaseViewer3D.prototype.toggleVisibility = function (a) {
    this.impl.visibilityManager.toggleVisibility(a)
};
Autodesk.Viewing.BaseViewer3D.prototype.areAllVisible = function () {
    return this.impl.visibilityManager.areAllVisible()
};
Autodesk.Viewing.BaseViewer3D.prototype.explode = function (a) {
    this.impl.explode(a)
};
Autodesk.Viewing.BaseViewer3D.prototype.setQualityLevel = function (a, b) {
    this.impl.togglePostProcess(a, b)
};
Autodesk.Viewing.BaseViewer3D.prototype.setEnvironmentMap = function (a) {
    this.impl.setCubeMap(a)
};
Autodesk.Viewing.BaseViewer3D.prototype.setGhosting = function (a) {
    this.impl.toggleGhosting(a)
};
Autodesk.Viewing.BaseViewer3D.prototype.setProgressiveRendering = function (a) {
    this.impl.toggleProgressive(a)
};
Autodesk.Viewing.BaseViewer3D.prototype.getNavigationMode = function () {
    if ("getNavigationMode" in this.impl.controls) return this.impl.controls.getNavigationMode()
};
Autodesk.Viewing.BaseViewer3D.prototype.setNavigationMode = function (a) {
    "setNavigationMode" in this.impl.controls && this.impl.controls.setNavigationMode(a)
};
Autodesk.Viewing.BaseViewer3D.prototype.getFOV = function () {
    return "getFOV" in this.impl.controls ? this.impl.controls.getFOV() : this.impl.camera.fov
};
Autodesk.Viewing.BaseViewer3D.prototype.setFOV = function (a) {
    "setFOV" in this.impl.controls ? this.impl.controls.setFOV(a) : (this.impl.camera.fov = a, this.impl.syncCamera())
};
Autodesk.Viewing.BaseViewer3D.prototype.getFocalLength = function () {
    if ("getFocalLength" in this.impl.controls) return this.impl.controls.getFocalLength();
    var a = THREE.Math.degToRad(this.impl.camera.fov);
    return Math.round(12 / Math.tan(0.5 * a))
};
Autodesk.Viewing.BaseViewer3D.prototype.setFocalLength = function (a) {
    "setFocalLength" in this.impl.controls ? this.impl.controls.setFocalLength(a) : (this.impl.camera.setLens(a), this.impl.syncCamera())
};
Autodesk.Viewing.BaseViewer3D.prototype.hideLines = function (a) {
    this.impl.hideLines(a)
};
Autodesk.Viewing.BaseViewer3D.prototype.applyCamera = function (a, b) {
    this.impl.applyCamera(a, b)
};
AutodeskNamespace("Autodesk.Viewing");
Autodesk.Viewing.ErrorCodes = {
    UNKNOWN_FAILURE: 1,
    BAD_DATA: 2,
    NETWORK_FAILURE: 3,
    NETWORK_ACCESS_DENIED: 4,
    NETWORK_FILE_NOT_FOUND: 5,
    NETWORK_SERVER_ERROR: 6,
    NETWORK_UNHANDLED_RESPONSE_CODE: 7,
    BROWSER_WEBGL_NOT_SUPPORTED: 8,
    BAD_DATA_NO_VIEWABLE_CONTENT: 9
};
/*
 Copyright (c) 2013 Autodesk Inc. */
AutodeskNamespace("Autodesk.Viewing");
Autodesk.Viewing.Viewer2D = function (a, b) {
    Autodesk.Viewing.Viewer.call(this, a, b);
    b || (b = {});
    b.domElement = this.container;
    this.impl = new Viewer2DImpl(this, b)
};
Autodesk.Viewing.Viewer2D.prototype = Object.create(Autodesk.Viewing.Viewer.prototype);
Autodesk.Viewing.Viewer2D.prototype.constructor = Autodesk.Viewing.Viewer2D;
Autodesk.Viewing.Viewer2D.prototype.initialize = function () {
    return this.impl.initialize()
};
Autodesk.Viewing.Viewer2D.prototype.load = function (a, b, c) {
    return this.impl.load(a) ? (b && b(), !0) : !1
};
Autodesk.Viewing.Viewer2D.prototype.uninitialize = function () {
    this.impl.uninitialize();
    this.container && this.container.parentNode.removeChild(this.container);
    Autodesk.Viewing.Viewer.prototype.uninitialize.call(this)
};
Autodesk.Viewing.Viewer2D.prototype.resize = function () {
    this.impl.resize()
};
Autodesk.Viewing.Viewer2D.prototype.setViewFromFile = function () {
    this.impl.goHome()
};
/*
 Copyright (c) 2013 Autodesk Inc. */
AutodeskNamespace("Autodesk.Viewing");
Autodesk.Viewing.Document = function (a, b) {
    function c(a) {
        if (a) {
            var b = a.children ? a.children.length : 0;
            if ("geometry" === a.type && "3d" === a.role && b) {
                for (var f = 0, k = 0; k < b; k++) {
                    var h = a.children[k];
                    h && "view" === h.type && "3d" === h.role && (e.myViewGeometry[h.guid] = a, f++)
                }
                e.myNumViews[a.guid] = f
            } else if ("application/autodesk-db" == a.mime) e.myPropertyDb = a.urn.substr(0, a.urn.lastIndexOf("/") + 1);
            else if (0 < b)
                for (k = 0; k < b; k++) c(a.children[k])
        }
    }
    this.myPath = b;
    this.myData = a;
    this.myViewGeometry = {};
    this.myNumViews = {};
    this.myPropertyDb =
        null;
    var e = this;
    c(a)
};
Autodesk.Viewing.Document.prototype.constructor = Autodesk.Viewing.Document;
Autodesk.Viewing.Document.load = function (a, b, c, e) {
    var d = function (a) {
        if ("http://" == a.substr(0, 7) || "https://" == a.substr(0, 8) || "file:///" == a.substr(0, 8)) return a;
        if (-1 === a.indexOf("urn:")) return 0 !== a.indexOf("/") && (a = "/" + a), window.location.protocol + "//" + window.location.host + a;
        a = a.substr(4);
        return VIEWING_URL + "/bubbles/" + a
    }(a);
    try {
        var g = new XMLHttpRequest;
        if (b.oauthNone) g.open("GET", d, !0), g.withCredentials = !0, g.setRequestHeader("Access-Control-Allow-Credentials", !0);
        else if (b.oauth0) encodeURIComponent(b.access_token),
            g.open("GET", d, !0);
        else {
            g.open("GET", d, !0);
            var f = b.getAuthHeader("GET", d);
            g.setRequestHeader("Authorization", f)
        }
        g.setRequestHeader("Access-Control-Allow-Origin", "*");
        !1 == b.oauthNone && (g.responseType = "json");
        g.onload = function (a) {
            if (g.status && 200 === g.status) a = g.response ? g.response : g.responseText, /<[^>]*script/.test(g.responseText) ? e("Malicious document content detected. Abort loading.", Autodesk.Viewing.ErrorCodes.BAD_DATA) : (a = "string" === typeof a ? JSON.parse(a) : a, a = new Autodesk.Viewing.Document(a, d),
                c(a));
            else {
                a = "Network error: " + g.status + " (" + g.statusText + ")";
                var b = ErrorHandler.getErrorCode(g.status);
                e(a, b)
            }
        };
        g.onerror = function (a) {
            a = "Load error: " + g.status + " (" + g.statusText + ")";
            var b = ErrorHandler.getErrorCode(g.status);
            e(a, b)
        };
        g.ontimeout = function (a) {
            a = "Timeout occured: " + g.status + " (" + g.statusText + ")";
            var b = ErrorHandler.getErrorCode(g.status);
            e(a, b)
        };
        g.send()
    } catch (k) {
        e("An exception occurred while loading the document: " + k.toString(), Autodesk.Viewing.ErrorCodes.UNKNOWN_FAILURE)
    }
};
Autodesk.Viewing.Document.prototype.getFullPath = function (a) {
    var b = a;
    0 === a.indexOf("urn") ? b = VIEWING_URL + "/items/" + a : 0 === a.indexOf("$file$") && -1 !== this.myPath.indexOf("/output/bubble.json") && (b = this.myPath.replace("/output/bubble.json", "") + a.replace("$file$", ""));
    return b
};
Autodesk.Viewing.Document.prototype.getThumbnailPath = function (a, b, c) {
    b = b ? b : 200;
    c = c ? c : 200;
    return VIEWING_URL + "/thumbnails/" + this.myData.urn + "?guid=" + encodeURIComponent(a.guid) + "&width=" + b + "&height=" + c
};
Autodesk.Viewing.Document.prototype.getViewablePath = function (a) {
    if ("geometry" === a.type) {
        var b = [];
        "3d" === a.role ? b = Autodesk.Viewing.Document.getSubItemsWithProperties(a, {
            mime: "application/autodesk-svf"
        }, !1) : "2d" === a.role && (b = Autodesk.Viewing.Document.getSubItemsWithProperties(a, {
            role: "tileRoot"
        }, !0));
        if (0 < b.length) return this.getFullPath(b[0].urn)
    } else if ("view" === a.type && (a = this.getViewGeometry(a))) return this.getViewablePath(a);
    return ""
};
Autodesk.Viewing.Document.prototype.getPropertyDbPath = function () {
    return this.myPropertyDb
};
Autodesk.Viewing.Document.prototype.getRootItem = function () {
    return this.myData
};
Autodesk.Viewing.Document.prototype.getPath = function () {
    return this.myPath
};
Autodesk.Viewing.Document.prototype.getItemById = function (a) {
    function b(c) {
        if (!c) return null;
        for (var e in c) {
            var d = c[e];
            if ("guid" === e && d === a) return c;
            if (null !== d && "object" === typeof d && (d = b(d))) return d
        }
        return null
    }
    return b(this.myData)
};
Autodesk.Viewing.Document.getSubItemsWithProperties = function (a, b, c) {
    var e = [];
    if (!a) return [];
    for (var d = a.children ? a.children.length : 0, g = 0; g < d; g++) {
        var f = a.children[g],
            k;
        a: {
            k = b;
            var h = void 0;
            for (h in k)
                if (!(h in f) || k[h] !== f[h]) {
                    k = !1;
                    break a
                }
            k = !0
        }
        k && e.push(f);
        c && e.push.apply(e, Autodesk.Viewing.Document.getSubItemsWithProperties(f, b, c))
    }
    return e
};
Autodesk.Viewing.Document.prototype.getViewGeometry = function (a) {
    return this.myViewGeometry[a.guid]
};
Autodesk.Viewing.Document.prototype.getNumViews = function (a) {
    return this.myNumViews[a.guid] || 0
};
/*
 Copyright (c) 2013 Autodesk Inc. */
AutodeskNamespace("Autodesk.Viewing");
Autodesk.Viewing.ViewingApplication = function (a, b) {
    this.appContainerId = a;
    this.container = document.getElementById(a);
    this.options = b;
    this.myRegisteredViewers = {};
    this.urn = this.myCurrentViewer = this.myDocument = null
};
Autodesk.Viewing.ViewingApplication.prototype.k3D = "3D";
Autodesk.Viewing.ViewingApplication.prototype.k2D = "2D";
Autodesk.Viewing.ViewingApplication.prototype.registerViewer = function (a, b, c) {
    this.myRegisteredViewers[a] = {};
    this.myRegisteredViewers[a].class = b;
    this.myRegisteredViewers[a].config = c
};
Autodesk.Viewing.ViewingApplication.prototype.getViewerClass = function (a) {
    return this.myRegisteredViewers.hasOwnProperty(a) ? this.myRegisteredViewers[a].class : null
};
Autodesk.Viewing.ViewingApplication.prototype.getViewerContainer = function () {
    return document.getElementById(this.appContainerId)
};
Autodesk.Viewing.ViewingApplication.prototype.getViewer = function (a, b) {
    if (a in this.myRegisteredViewers) {
        this.setCurrentViewer(null);
        var c = this.myRegisteredViewers[a].class,
            e = {},
            d = this.myRegisteredViewers[a].config,
            g;
        for (g in d) d.hasOwnProperty(g) && (e[g] = d[g]);
        for (g in b) b.hasOwnProperty(g) && (e[g] = b[g]);
        for (d = this.getViewerContainer(); d.hasChildNodes();) d.removeChild(d.lastChild);
        c = new c(d, e);
        if (c.initialize()) return this.setCurrentViewer(c), c
    }
    return null
};
Autodesk.Viewing.ViewingApplication.prototype.setCurrentViewer = function (a) {
    this.myCurrentViewer && this.myCurrentViewer.uninitialize();
    this.myCurrentViewer = a
};
Autodesk.Viewing.ViewingApplication.prototype.getCurrentViewer = function () {
    return this.myCurrentViewer
};
Autodesk.Viewing.ViewingApplication.prototype.loadDocument = function (a, b, c) {
    var e = this;
    Autodesk.Viewing.Document.load(a, auth, function (a) {
        e.myDocument = a;
        e.onDocumentLoaded(a);
        b && b(a)
    }, function (a, b) {
        e.onDocumentFailedToLoad(a, b);
        c && c(a, b)
    })
};
Autodesk.Viewing.ViewingApplication.prototype.onDocumentLoaded = function (a) {
    console.log(a)
};
Autodesk.Viewing.ViewingApplication.prototype.onDocumentFailedToLoad = function (a, b) {
    var c = this.getViewerContainer();
    c && ErrorHandler.reportError(c, b)
};
Autodesk.Viewing.ViewingApplication.prototype.selectItem = function (a, b) {
    var c = this.myDocument.getViewablePath(a);
    if (c) {
        var e, d, g;
        if ("geometry" === a.type && "3d" === a.role) e = this.k3D, g = a.name;
        else if ("view" === a.type && "3d" === a.role) {
            d = a;
            e = this.k3D;
            var f = this.myDocument.getViewGeometry(a);
            f && (g = f.name)
        } else "geometry" === a.type && "2d" === a.role && (e = this.k2D, g = a.name); if (e) {
            var k = this,
                h = this.myCurrentViewer && this.urn === c,
                f = null,
                f = d && d.camera ? function () {
                    k.myCurrentViewer.setViewFromArray(d.camera);
                    b && b(k.myCurrentViewer,
                        a)
                } : h ? function () {
                    k.myCurrentViewer.setViewFromFile();
                    b && b(k.myCurrentViewer, a)
                } : function () {
                    b && b(k.myCurrentViewer, a)
                },
                l = !1;
            h ? (f && f(), l = !0) : (this.urn = null, (e = this.getViewer(e, {
                defaultModelStructureTitle: g
            })) && e.load(this.myDocument.getFullPath(c), f, this.myDocument.getPropertyDbPath()) && (this.urn = c, l = !0));
            if (l) return this.onItemSelected(a), !0
        }
    }
    return !1
};
Autodesk.Viewing.ViewingApplication.prototype.onItemSelected = function (a) {
    console.log("Selected URL: http://" + location.host + location.pathname + "?document=urn:" + this.myDocument.getRootItem().guid + "&item=" + encodeURIComponent(a.guid))
};
Autodesk.Viewing.ViewingApplication.prototype.selectItemById = function (a, b) {
    var c = this.myDocument.getItemById(a);
    return c ? this.selectItem(c, b) : !1
};
/*
 Copyright (c) 2013 Autodesk Inc. */
AutodeskNamespace("Autodesk.Viewing");
Autodesk.Viewing.Initializer = function (a, b) {
    initializeEnvironmentVariable(a);
    initializeServiceEndPoints();
    initializeAuth(b, a)
};
AutodeskNamespace("Autodesk.Viewing.Private");
Autodesk.Viewing.Private.GuiViewer3D = function (a, b) {
    Autodesk.Viewing.BaseViewer3D.call(this, a, b)
};
Autodesk.Viewing.Private.GuiViewer3D.prototype = Object.create(Autodesk.Viewing.BaseViewer3D.prototype);
Autodesk.Viewing.Private.GuiViewer3D.prototype.constructor = Autodesk.Viewing.Private.GuiViewer3D;
Autodesk.Viewing.Private.GuiViewer3D.prototype.resize = function () {
    Autodesk.Viewing.BaseViewer3D.prototype.resize.call(this);
    600 > this.container.clientWidth ? addClass(this.menu, "toolbar-menu-collapsed") : removeClass(this.menu, "toolbar-menu-collapsed")
};
Autodesk.Viewing.Private.GuiViewer3D.kDefaultDocStructureConfig = {
    click: {
        onObject: ["isolate"]
    },
    clickCtrl: {
        onObject: ["toggleVisibility"]
    }
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initDebugTools = function () {
    this.debugMenu = this.addSubMenu();
    var a = this.renderoptions = new RenderOptionsPanel(this),
        b = this;
    this.addMenuButton(this.debugMenu, "toolbar-renderOptionsButton", "Rendering Options", function (c) {
        b.showRenderingOptions(!a.dockPanel.isVisible())
    });
    var c = document.createElement("li");
    c.className = "toolbar-generic-button";
    c.id = "toolbar-debugButton";
    this.debugMenu.subMenu = document.createElement("ul");
    this.debugMenu.subMenu.style.width = "180px";
    this.debugMenu.subMenu.style.paddingTop = "4px";
    this.debugMenu.subMenu.style.paddingBottom = "4px";
    c.appendChild(this.debugMenu.subMenu);
    this.debugMenu.appendChild(c);
    this.initFPSStats();
    this.initModelStats();
    b = this;
    this.addOptionToggle(this.debugMenu.subMenu, "Show Search Bar", !1, function (a) {
        b.searchMenu.style.display = a.target.checked ? "" : "none"
    })
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initialize = function () {
    if (!Autodesk.Viewing.BaseViewer3D.prototype.initialize.call(this)) return !1;
    var a = this,
        b = a.container;
    this.useLocalStorage = !0;
    var c = this.menuplacer = document.createElement("div");
    c.className = "toolbar-menuplacer";
    var e = this.menu = document.createElement("ul");
    e.className = "toolbar-menu";
    c.appendChild(e);
    b.appendChild(c);
    c = document.createElement("div");
    c.className = "toolbarcentertop";
    b.appendChild(c);
    this.toolbar = document.createElement("div");
    this.toolbar.className = "toolbar";
    c.appendChild(this.toolbar);
    this.initFocalLengthOverlay();
    this.initSettings();
    DockingPanel.initialize(a);
    this.addEventListener(Autodesk.Viewing.FULLSCREEN_MODE_EVENT, function (a) {
        DockingPanel.resizePanels(this)
    });
    this.propertygrid = new PropertyPanel(a);
    this.initMinTools();
    this.initNavTools();
    this.initCameraSubMenu();
    this.initModelTools();
    this.initCameraStateMachine();
    ENABLE_DEBUG && this.initDebugTools();
    this.initSearchBox();
    this.progressbar = new ProgressBar(this.container);
    this.addEventListener(Autodesk.Viewing.PROGRESS_UPDATE_EVENT, function (b) {
        void 0 !== b.percent && a.progressbar.setPercent(b.percent)
    }, !1);
    this.addEventListener(Autodesk.Viewing.ERROR_EVENT, function (a) {
        ErrorHandler.reportError(this.container, a.code)
    });
    this.selectionActive = !1;
    this.addEventListener(Autodesk.Viewing.SELECTION_CHANGED_EVENT, function (b) {
        a.selectionActive = 0 < b.dbIdArray.length
    });
    this.initEscapeHandlers();
    return !0
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.addOptionToggle = function (a, b, c, e, d) {
    var g = this,
        f = this.settings[d];
    c = null !== f ? f : c;
    var f = document.createElement("li"),
        k = document.createElement("input");
    k.className = "toolbar-menu-checkbox";
    k.type = "checkbox";
    f.appendChild(k);
    var h = document.createElement("label");
    h.innerHTML = b;
    f.appendChild(h);
    a.appendChild(f);
    k.checked = c;
    k.onchange = function (a) {
        g.updateSetting(d, a.target.checked);
        e(a)
    };
    return f
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.addHeader = function (a, b) {
    var c = document.createElement("li");
    c.innerHTML = b;
    c.className = "toolbar-header";
    a.appendChild(c);
    return c
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.addDivider = function (a) {
    var b = document.createElement("li");
    b.className = "toolbar-horizontal-divider";
    a.appendChild(b);
    return b
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.addSubMenu = function () {
    var a = document.createElement("div");
    a.className = "toolbar-submenu";
    this.menu.appendChild(a);
    return a
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.addMenuButton = function (a, b, c, e) {
    var d = document.createElement("li");
    d.setAttribute("tooltip", c);
    d.className = "toolbar-generic-button";
    d.id = b;
    a.appendChild(d);
    d.addEventListener("click", e);
    return d
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initColorPicker = function () {
    function a(a, b, e) {
        var m;
        if (7 == a.length) {
            for (b = 1; b < a.length; b++)
                if (e = parseInt(a[b], 16), 0 > e || 16 < e || e !== e) return;
            m = parseInt(a.slice(1), 16);
            b = 1 * (m >> 16 & 255);
            e = 1 * (m >> 8 & 255);
            m = 1 * (m & 255);
            f.setBackgroundColor(b, e, m, 0.6521739130434783 * b, 0.6521739130434783 * e, 0.6521739130434783 * m);
            c.style.background = a;
            g = d.value = a;
            f.updateSetting("bgColor", g)
        }
    }
    var b = document.createElement("li");
    b.className = "color-picker";
    var c = document.createElement("div");
    c.className = "backgroundButton";
    var e = document.createElement("div");
    e.className = "cp-small thecolorpicker";
    c.appendChild(e);
    b.appendChild(c);
    var d = document.createElement("input");
    d.type = "text";
    d.value = this.settings.bgColor;
    b.appendChild(d);
    var g = d.value,
        f = this;
    d.addEventListener("change", function () {
        a(d.value);
        d.value = g
    });
    this.menuoptions.appendChild(b);
    ColorPicker(e, a);
    a(d.value)
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initFPSStats = function () {
    var a = this;
    this.addOptionToggle(this.debugMenu.subMenu, "FPS Statistics", !1, function (b) {
        if (b.target.checked && !a.impl.stats) {
            var c = new Stats;
            c.setMode(1);
            c.domElement.style.position = "absolute";
            c.domElement.style.bottom = "0px";
            c.domElement.style.right = "0px";
            c.domElement.style.visibility = "hidden";
            c.domElement.style["z-index"] = 1;
            a.container.appendChild(c.domElement);
            a.impl.stats = c
        }
        a.impl.stats.domElement.style.visibility = b.target.checked ?
            "visible" : "hidden"
    })
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initModelStats = function () {
    function a(a) {
        var b = c.impl,
            g = "",
            f = b.svf;
        f && (g += "Geom&nbsp;Polys:&nbsp;" + f.geomPolyCount + "<br>", g += "Instance&nbsp;Polys:&nbsp;" + f.instancePolyCount + "<br>", g += "Scenes:&nbsp;" + b.modelQueue.geomScenes.length + "<br>");
        c.modelStats.innerHTML = g + ("# " + (a || ""))
    }

    function b() {
        c.modelStats = document.createElement("div");
        c.modelStats.className = "statspanel";
        c.container.appendChild(c.modelStats);
        c.addEventListener(Autodesk.Viewing.PROGRESS_UPDATE_EVENT, function (b) {
            b.message &&
                a(b.message)
        })
    }
    var c = this;
    this.addOptionToggle(this.debugMenu.subMenu, "Model Stats", !1, function (e) {
        e.target.checked && !c.modelStats && (b(), a(""));
        c.modelStats.style.visibility = e.target.checked ? "visible" : "hidden"
    })
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initExplodeSlider = function () {
    var a = this,
        b = this.explodeslider = document.createElement("input");
    b.className = "slider";
    b.type = "range";
    b.min = "0";
    b.max = "100";
    b.value = "0";
    b.width = "200";
    this.toolbar.appendChild(b);
    b.addEventListener("input", function (c) {
        a.explode(b.value / 100)
    });
    b.addEventListener("change", function (c) {
        a.explode(b.value / 100)
    });
    this.explodebutton = this.addMenuButton(this.modelTools, "toolbar-explodeButton", "Explode Model", function (c) {
        a.showExplodeSlider("hidden" ==
            b.style.visibility || "" == b.style.visibility)
    });
    b.addEventListener("keyup", function (b) {
        27 === b.keyCode && a.canvas.focus()
    })
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.showExplodeSlider = function (a) {
    a ? (this.explodebutton.style.opacity = 0.4, this.explodeslider.style.visibility = "visible") : (this.explodebutton.style.opacity = 1, this.explodeslider.style.visibility = "hidden")
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.showRenderingOptions = function (a) {
    this.renderoptions.dockPanel.setVisible(a)
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initMinTools = function () {
    var a = this;
    this.minTools = this.addSubMenu();
    this.minTools.minfullscreenbutton = this.addMenuButton(this.minTools, "toolbar-minfullscreenButton", "Full Screen", function (b) {
        a.nextScreenMode()
    })
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initNavTools = function () {
    var a = this;
    this.navTools = this.addSubMenu();
    this.navTools.orbitbutton = this.addMenuButton(this.navTools, "toolbar-orbitButton", "Orbit", function (b) {
        a.setNavigationMode(NAVIGATION_MODE.ORBIT)
    });
    this.navTools.orbitbutton.style.opacity = 1;
    this.navTools.panbutton = this.addMenuButton(this.navTools, "toolbar-panButton", "Pan", function (b) {
        a.setNavigationMode(a.getNavigationMode() === NAVIGATION_MODE.PAN ? NAVIGATION_MODE.ORBIT : NAVIGATION_MODE.PAN)
    });
    this.navTools.panbutton.style.opacity = 0.4;
    this.navTools.dollybutton = this.addMenuButton(this.navTools, "toolbar-zoomButton", "Zoom", function (b) {
        a.setNavigationMode(a.getNavigationMode() === NAVIGATION_MODE.DOLLY ? NAVIGATION_MODE.ORBIT : NAVIGATION_MODE.DOLLY)
    });
    this.navTools.dollybutton.style.opacity = 0.4;
    a.canvas.style.cursor = "url(" + RESOURCE_ROOT + "icons/turntable_cur.cur), wait";
    this.navigationMode = NAVIGATION_MODE.ORBIT
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initCameraStateMachine = function () {
    var a = this;
    a.addEventListener(Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT, function (b) {
        a.navTools.orbitbutton.style.opacity = 0.4;
        a.navTools.dollybutton.style.opacity = 0.4;
        a.navTools.panbutton.style.opacity = 0.4;
        a.cameraMenu.fovbutton.style.opacity = 0.4;
        a.cameraMenu.rollbutton.style.opacity = 0.4;
        switch (b.value) {
        case NAVIGATION_MODE.ORBIT:
            a.navTools.orbitbutton.style.opacity = 1;
            a.canvas.style.cursor = "url(" + RESOURCE_ROOT + "icons/turntable_cur.cur), wait";
            break;
        case NAVIGATION_MODE.DOLLY:
            a.navTools.dollybutton.style.opacity = 1;
            a.canvas.style.cursor = "url(" + RESOURCE_ROOT + "icons/dolly_cur.cur), wait";
            break;
        case NAVIGATION_MODE.PAN:
            a.navTools.panbutton.style.opacity = 1;
            a.canvas.style.cursor = "url(" + RESOURCE_ROOT + "icons/pan_cur.cur), wait";
            break;
        case NAVIGATION_MODE.FOV:
            a.cameraMenu.fovbutton.style.opacity = 1;
            a.canvas.style.cursor = "url(" + RESOURCE_ROOT + "icons/fov_cur.cur), wait";
            break;
        case NAVIGATION_MODE.ROLL:
            a.cameraMenu.rollbutton.style.opacity = 1;
            a.canvas.style.cursor =
                "auto";
            break;
        default:
            a.canvas.style.cursor = "auto"
        }
        a.navigationMode = b.value;
        a.showFocalLengthOverlay(a.navigationMode === NAVIGATION_MODE.FOV)
    })
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initCameraSubMenu = function () {
    this.cameraMenu = this.addSubMenu();
    var a = document.createElement("li");
    a.className = "toolbar-generic-button";
    a.id = "toolbar-cameraSubmenuButton";
    var b = document.createElement("ul");
    b.style.paddingTop = "4px";
    b.style.paddingBottom = "4px";
    a.appendChild(b);
    this.cameraMenu.appendChild(a);
    var a = function (a, c, g) {
            var f = document.createElement("li");
            f.setAttribute("tooltip", c);
            f.className = "toolbar-generic-button";
            f.id = a;
            b.appendChild(f);
            f.addEventListener("click",
                g);
            return f
        },
        c = this;
    this.cameraMenu.fittoviewbutton = a("toolbar-fitToViewButton", "Fit to View (F)", function (a) {
        c.impl.controls.fitToView()
    });
    this.cameraMenu.fovbutton = a("toolbar-focalLengthButton", "Focal Length  (CTRL+SHIFT - drag)", function (a) {
        c.setNavigationMode(c.getNavigationMode() === NAVIGATION_MODE.FOV ? NAVIGATION_MODE.ORBIT : NAVIGATION_MODE.FOV)
    });
    this.cameraMenu.fovbutton.style.opacity = 0.4;
    this.cameraMenu.rollbutton = a("toolbar-rollButton", "Roll (ALT+SHIFT - drag)", function (a) {
        c.setNavigationMode(c.getNavigationMode() ===
            NAVIGATION_MODE.ROLL ? NAVIGATION_MODE.ORBIT : NAVIGATION_MODE.ROLL)
    });
    this.cameraMenu.rollbutton.style.opacity = 0.4
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initModelTools = function () {
    var a = this;
    this.modelTools = this.addSubMenu();
    this.structurebutton = this.addMenuButton(this.modelTools, "toolbar-modelStructureButton", "Model Structure", function (b) {
        a.docstructure && a.showDocumentStructurePanel(!a.docstructure.isVisible())
    });
    this.initExplodeSlider();
    this.addMenuButton(this.modelTools, "toolbar-resetButton", "Reset Model", function (b) {
        a.explode(0);
        a.explodeslider.value = 0;
        a.showAll()
    });
    this.modelTools.propertiesbutton =
        this.addMenuButton(this.modelTools, "toolbar-propertiesButton", "Properties", function (b) {
            a.propertygrid.isVisible() ? (a.propertygrid.setVisible(!1), a.modelTools.propertiesbutton.style.opacity = 1) : (a.propertygrid.getNodeId() || a.propertygrid.setDefaultProperties(), a.propertygrid.setVisible(!0), a.modelTools.propertiesbutton.style.opacity = 0.4)
        });
    this.modelTools.propertiesbutton.style.display = "none";
    this.createOptionsButton();
    this.modelTools.fullscreenbutton = this.addMenuButton(this.modelTools, "toolbar-fullscreenButton",
        "Full Screen", function (b) {
            a.nextScreenMode()
        })
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.setPropertiesOnSelect = function (a) {
    this.modelTools.propertiesbutton.style.display = a ? "none" : "list-item";
    this.propertygrid.setOpenOnSelect(a)
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.createOptionsButton = function () {
    var a = this,
        b = document.createElement("li");
    b.className = "toolbar-generic-button";
    b.id = "toolbar-optionsSubmenuButton";
    this.menuoptions = document.createElement("ul");
    this.menuoptions.style.width = "220px";
    this.menuoptions.style.paddingTop = "4px";
    this.menuoptions.style.paddingBottom = "4px";
    b.appendChild(this.menuoptions);
    this.modelTools.appendChild(b);
    this.addHeader(this.menuoptions, "Background Color");
    this.initColorPicker();
    this.addDivider(this.menuoptions);
    this.initViewCube();
    this.modelTools.propertiesOnSelectCheckbox = this.addOptionToggle(this.menuoptions, "Open Properties on Select", !0, function (b) {
        a.setPropertiesOnSelect(b.target.checked)
    }, "openPropertiesOnSelect");
    this.setPropertiesOnSelect(this.settings.openPropertiesOnSelect);
    this.addDivider(this.menuoptions);
    this.addHeader(this.menuoptions, "Performance and Quality");
    this.modelTools.propertiesOnSelectCheckbox.style.opacity = 1;
    this.addOptionToggle(this.menuoptions, "Ghost Hidden Objects", !0, function (b) {
            a.setGhosting(b.target.checked)
        },
        "ghosting");
    this.addOptionToggle(this.menuoptions, "Ambient Shadows", !this.isAndroid, function (b) {
        a.setQualityLevel(b.target.checked, a.settings.antialiasing)
    }, "ambientShadows");
    this.addOptionToggle(this.menuoptions, "Antialiasing", !this.isAndroid, function (b) {
        a.setQualityLevel(a.settings.ambientShadows, b.target.checked)
    }, "antialiasing");
    this.addOptionToggle(this.menuoptions, "Progressive Model Display", !0, function (b) {
        a.setProgressiveRendering(b.target.checked)
    }, "progressiveRendering");
    this.addOptionToggle(this.menuoptions,
        "Display Lines", !0, function (b) {
            a.hideLines(!b.target.checked)
        }, "lineRendering");
    this.addOptionToggle(this.menuoptions, "Environment Map", !1, function (b) {
        b.target.checked ? (b = RESOURCE_ROOT + "environments/sky_", a.setEnvironmentMap([b + "px.jpg", b + "nx.jpg", b + "py.jpg", b + "ny.jpg", b + "pz.jpg", b + "nz.jpg"])) : a.setEnvironmentMap()
    }, "environmentMap")
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initEscapeHandlers = function () {
    var a = this;
    this.addEventListener(Autodesk.Viewing.ESCAPE_EVENT, function (b) {
        if (a.renderoptions && a.renderoptions.dockPanel.isVisible()) a.renderoptions.dockPanel.setVisible(!1);
        else if ("hidden" !== a.explodeslider.style.visibility && "" !== a.explodeslider.style.visibility) a.showExplodeSlider(!1);
        else if (a.navigationMode !== NAVIGATION_MODE.ORBIT) a.setNavigationMode(NAVIGATION_MODE.ORBIT);
        else if (a.selectionActive) a.clearSelection();
        else if (!a.areAllVisible()) a.showAll();
        else if (!AlertBox.dismiss()) {
            for (b = 0; b < a.dockingPanels.length; ++b) {
                var c = a.dockingPanels[b];
                if ("none" !== c.container.style.display && "" !== c.container.style.display) {
                    c.container === a.docstructure ? a.showDocumentStructurePanel(!1) : c.setVisible(!1);
                    return
                }
            }
            a.escapeScreenMode()
        }
    })
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initViewCube = function () {
    function a(a) {
        b.viewcube || (b.viewcube = document.createElement("div"), b.viewcube.className = "viewcube", b.container.appendChild(b.viewcube), ViewCube(b.viewcube, b), b.viewcube.style.display = "none", b.impl.needsClear = !0);
        b.viewcube.style.display = a ? "block" : "none";
        b.homeViewContainer.style.width = a ? b.viewcube.style.width : "auto"
    }
    var b = this,
        c = this.homeViewContainer = document.createElement("div");
    c.className = "homeViewWrapper";
    var e = document.createElement("img");
    e.className = "homeView";
    e.src = RESOURCE_ROOT + "icons/resetview_icon.png";
    e.style.cursor = "pointer";
    c.appendChild(e);
    c.style.width = "auto";
    this.container.appendChild(c);
    e.addEventListener("click", function () {
        b.impl.controls.goHome()
    });
    this.addOptionToggle(this.menuoptions, "View Cube", !1, function (b) {
        a(b.target.checked)
    }, "viewCube");
    !0 === this.settings.viewCube && a(!0)
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initSearchBox = function () {
    var a = document.createElement("li"),
        b = document.createElement("input");
    b.type = "search";
    b.results = 5;
    b.placeholder = "Search";
    b.incremental = "incremental";
    b.autosave = this.container.id + "search_autosave";
    a.appendChild(b);
    this.searchMenu = this.addSubMenu();
    this.searchMenu.appendChild(a);
    this.searchMenu.style.display = "none";
    var c = this;
    this.searchbox = b;
    b.addEventListener("change", function (a) {
        stderr("search " + b.value);
        c.search(b.value, function (a) {
            c.isolateById(a)
        })
    });
    b.addEventListener("keypress", function (a) {
        27 === a.keyCode && setTimeout(function () {
            "" !== b.value && (b.value = "")
        }, 0)
    });
    this.menu.addEventListener("mouseleave", function (a) {
        function d() {
            clearTimeout(g)
        }
        var g;
        c.menu.addEventListener("mouseenter", d);
        g = setTimeout(function () {
            c.menu.removeEventListener("mouseenter", d);
            document.activeElement === b && c.canvas.focus()
        }, 2E3)
    })
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.setStructureButtonEnabled = function (a) {
    this.structurebutton.style.opacity = a ? 0.4 : 1
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.showDocumentStructurePanel = function (a) {
    this.docstructure.setVisible(a)
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.createDocumentStructurePanel = function () {
    var a = new DocumentStructurePanel(this);
    a.setClickBehavior(this.config && this.config.docStructureConfig ? this.config.docStructureConfig : Autodesk.Viewing.Private.GuiViewer3D.kDefaultDocStructureConfig);
    this.docstructure = a;
    var b = this;
    this.docstructure.addVisibilityListener(function (a) {
        b.setStructureButtonEnabled(a)
    })
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initFocalLengthOverlay = function () {
    var a = this.focallength = document.createElement("div");
    a.className = "focallength";
    var b = document.createElement("table"),
        c = document.createElement("tbody");
    b.appendChild(c);
    a.appendChild(b);
    this.container.appendChild(a);
    var b = c.insertRow(-1),
        e = b.insertCell(0);
    e.textContent = "Focal Length:";
    e = b.insertCell(1);
    e.textContent = "";
    e.style.width = "4em";
    e.style.textAlign = "right";
    var d = 0,
        g = this;
    this.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT,
        function (a) {
            a = g.getFocalLength();
            d !== a && (d = a, e.textContent = a.toString() + " mm")
        });
    a.style.visibility = "hidden"
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.showFocalLengthOverlay = function (a) {
    this.focallength && "hidden" !== this.focallength.style.visibility !== a && (this.focallength.style.visibility = a ? "visible" : "hidden")
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.load = function (a, b, c) {
    var e = this;
    return Autodesk.Viewing.BaseViewer3D.prototype.load.call(this, a, function () {
        e.createDocumentStructurePanel();
        b && b()
    }, c)
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initSettings = function () {
    var a = window.navigator;
    this.settings = {};
    this.isAndroid = -1 != a.platform.indexOf("armv") || a.appVersion && -1 != a.appVersion.indexOf("Android");
    for (var a = {
            ambientShadows: !this.isAndroid,
            antialiasing: !this.isAndroid,
            progressiveRendering: !0,
            environmentMap: !0,
            openPropertiesOnSelect: !0,
            ghosting: !0,
            bgColor: "#E6E6E6",
            viewCube: !1,
            lineRendering: !0
        }, b = "ambientShadows ghosting progressiveRendering antialiasing bgColor viewCube environmentMap lineRendering openPropertiesOnSelect".split(" "),
        c = 0; c < b.length; c++) {
        var e = b[c],
            d = this._settingStore(e);
        if ("true" === d || "false" === d) d = "true" === d;
        this.settings[e] = d
    }
    b = Object.keys(a);
    for (c = 0; c < b.length; c++) e = this.settings[b[c]], this.settings[b[c]] = null != e ? e : a[b[c]];
    this.setQualityLevel(this.settings.ambientShadows, this.settings.antialiasing);
    this.setGhosting(this.settings.ghosting);
    this.setProgressiveRendering(this.settings.progressiveRendering);
    this.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, function () {
        this.hideLines(!this.settings.lineRendering);
        if (!0 === this.settings.environmentMap) {
            var a = RESOURCE_ROOT + "environments/sky_";
            this.setEnvironmentMap([a + "px.jpg", a + "nx.jpg", a + "py.jpg", a + "ny.jpg", a + "pz.jpg", a + "nz.jpg"])
        } else this.setEnvironmentMap()
    })
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.updateSetting = function (a, b) {
    this.settings[a] = b;
    this._settingStore(a, b)
};
Autodesk.Viewing.Private.GuiViewer3D.prototype._settingStore = function (a, b) {
    return this.useLocalStorage ? "undefined" !== typeof sessionStorage && "string" === typeof a ? ("undefined" !== typeof b ? sessionStorage["Autodesk.Viewing.Private.GuiViewer3D.SavedSettings." + a] = b : b = sessionStorage["Autodesk.Viewing.Private.GuiViewer3D.SavedSettings." + a] || null, b) : null : null
};
AutodeskNamespace("Autodesk.Viewing.Private");
Autodesk.Viewing.Private.GuiViewer2D = function (a, b) {
    Autodesk.Viewing.Viewer2D.call(this, a, b)
};
Autodesk.Viewing.Private.GuiViewer2D.prototype = Object.create(Autodesk.Viewing.Viewer2D.prototype);
Autodesk.Viewing.Private.GuiViewer2D.prototype.constructor = Autodesk.Viewing.Private.GuiViewer2D;
Autodesk.Viewing.Private.GuiViewer2D.prototype.initialize = function () {
    if (!Autodesk.Viewing.Viewer2D.prototype.initialize.call(this)) return !1;
    var a = document.createElement("div");
    a.className = "toolbar-menuplacer";
    this.container.appendChild(a);
    var b = this.menu = document.createElement("ul");
    b.className = "toolbar-menu";
    a.appendChild(b);
    this.initNavTools();
    this.initModelTools();
    this.initEscapeHandlers();
    this.initHomeButton();
    return !0
};
Autodesk.Viewing.Private.GuiViewer2D.prototype.initNavTools = function () {
    var a = this;
    this.navTools = this.addSubMenu();
    this.navTools.panbutton = this.addMenuButton(this.navTools, "toolbar-panButton", "Pan", function (b) {
        a.impl.setNavigationMode(VIEWER2D_NAVIGATION_MODE.PAN)
    });
    this.navTools.dollybutton = this.addMenuButton(this.navTools, "toolbar-zoomButton", "Zoom", function (b) {
        a.impl.setNavigationMode(VIEWER2D_NAVIGATION_MODE.ZOOM)
    });
    this.addEventListener(Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT, function (b) {
        a.navTools.panbutton.style.opacity =
            0.6;
        a.navTools.dollybutton.style.opacity = 0.6;
        switch (b.value) {
        case VIEWER2D_NAVIGATION_MODE.PAN:
            a.navTools.panbutton.style.opacity = 1;
            a.impl.container.style.cursor = "url(" + RESOURCE_ROOT + "icons/pan_cur.cur), wait";
            break;
        case VIEWER2D_NAVIGATION_MODE.ZOOM:
            a.navTools.dollybutton.style.opacity = 1;
            a.impl.container.style.cursor = "url(" + RESOURCE_ROOT + "icons/dolly_cur.cur), wait";
            break;
        default:
            a.impl.container.style.cursor = "auto"
        }
    });
    this.impl.setNavigationMode(VIEWER2D_NAVIGATION_MODE.PAN)
};
Autodesk.Viewing.Private.GuiViewer2D.prototype.initModelTools = function () {
    var a = this;
    this.modelTools = this.addSubMenu();
    this.modelTools.fullscreenbutton = this.addMenuButton(this.modelTools, "toolbar-fullscreenButton", "Full Screen", function (b) {
        a.nextScreenMode()
    })
};
Autodesk.Viewing.Private.GuiViewer2D.prototype.initEscapeHandlers = function () {
    var a = this;
    this.addEventListener(Autodesk.Viewing.ESCAPE_EVENT, function (b) {
        a.impl.setNavigationMode(VIEWER2D_NAVIGATION_MODE.PAN) || a.escapeScreenMode()
    }, !1)
};
Autodesk.Viewing.Private.GuiViewer2D.prototype.initHomeButton = function () {
    var a = this,
        b = this.homeViewContainer = document.createElement("div");
    b.className = "homeViewWrapper";
    var c = document.createElement("img");
    c.className = "homeView";
    c.src = RESOURCE_ROOT + "icons/resetview_icon.png";
    c.style.cursor = "pointer";
    b.appendChild(c);
    b.style.width = "auto";
    this.container.appendChild(b);
    c.addEventListener("click", function () {
        a.impl.goHome()
    })
};
Autodesk.Viewing.Private.GuiViewer2D.prototype.addSubMenu = function () {
    var a = document.createElement("div");
    a.className = "toolbar-submenu";
    this.menu.appendChild(a);
    return a
};
Autodesk.Viewing.Private.GuiViewer2D.prototype.addMenuButton = function (a, b, c, e) {
    var d = document.createElement("li");
    d.setAttribute("tooltip", c);
    d.className = "toolbar-generic-button";
    d.id = b;
    a.appendChild(d);
    d.addEventListener("click", e);
    return d
};
var auth = null,
    env, VIEWING_URL, SEARCH_URL, RESOURCE_ROOT = "",
    USE_OAUTH_NONE = !0,
    USE_OAUTH_ZERO = !1,
    USE_OAUTH_ONE = !1,
    USE_OAUTH_TWO = !1,
    SHOULD_SET_TOKEN = !0,
    EnvironmentConfigurations = {
        Local: {
            RESOURCE: "",
            VIEWING: "https://viewing-dev.api.autodesk.com/viewingservice/v1",
            SEARCH: "https://search-dev.api.autodesk.com/search/v1"
        },
        Development: {
            RESOURCE: "https://viewing-dev.api.autodesk.com/viewingservice/v1/viewers/",
            VIEWING: "https://viewing-dev.api.autodesk.com/viewingservice/v1",
            SEARCH: "https://search-dev.api.autodesk.com/search/v1"
        },
        Staging: {
            RESOURCE: "https://viewing-staging.api.autodesk.com/viewingservice/v1/viewers/",
            VIEWING: "https://viewing-staging.api.autodesk.com/viewingservice/v1",
            SEARCH: "https://search-staging.api.autodesk.com/search/v1"
        },
        Production: {
            RESOURCE: "https://viewing.api.autodesk.com/viewingservice/v1/viewers/",
            VIEWING: "https://viewing.api.autodesk.com/viewingservice/v1",
            SEARCH: "https://search.api.autodesk.com/search/v1"
        }
    };

function setAuthTokenInCookie(a, b) {
    var c = {
        oauth: {
            token: ""
        }
    };
    c.oauth.token = a;
    var e = new XMLHttpRequest;
    e.open("POST", VIEWING_URL + "/token", !0);
    e.setRequestHeader("Content-Type", "application/json");
    e.withCredentials = !0;
    b && (e.onload = b);
    e.send(JSON.stringify(c))
}

function initializeEnvironmentVariable(a) {
    if (a && a.env) env = a.env;
    else switch (window.location.hostname) {
    case "viewing-dev.api.autodesk.com":
        env = "Development";
        break;
    case "viewing-staging.api.autodesk.com":
        env = "Staging";
        break;
    case "viewing.api.autodesk.com":
        env = "Production";
        break;
    default:
        env = "Local"
    }
    console.log("Host name : " + window.location.hostname);
    console.log("Environment initialized as : " + env)
}

function initializeServiceEndPoints() {
    VIEWING_URL = EnvironmentConfigurations[env].VIEWING;
    SEARCH_URL = EnvironmentConfigurations[env].SEARCH;
    RESOURCE_ROOT = EnvironmentConfigurations[env].RESOURCE
}

function initializeAuth(a, b) {
    auth = new Auth;
    if (USE_OAUTH_ZERO) {
        var c = getParameterByName("accessToken");
        c || (c = "fRK+hYtOoq0+Y1xL1i8I/jeCy+o=");
        auth.configureOAuthZero(c)
    } else if (USE_OAUTH_ONE) {
        var c = getParameterByName("consumerKey"),
            e = getParameterByName("consumerSecret"),
            d = getParameterByName("token"),
            g = getParameterByName("tokenSecret");
        c || (c = "");
        e || (e = "");
        d || (d = "");
        g || (g = "");
        auth.configureOAuthOne(c, e, d, g)
    } else USE_OAUTH_TWO ? auth.configureOAuthTwo() : USE_OAUTH_NONE && (auth.configureOAuthNone(), c = b ? b.getAccessToken ?
        b.getAccessToken() : b.accessToken ? b.accessToken : getParameterByName("accessToken") : getParameterByName("accessToken"), c || (c = "I+st+K1gYU5zmb5IiJQZJQ3Agrs=", console.log("Warning : no access token is provided. Use built in token : " + c)), SHOULD_SET_TOKEN && setAuthTokenInCookie(c, a));
    return auth
}

function getAuthObject() {
    return auth
}

function getParameterByName(a) {
    return getParameterByNameFromPath(a, window.location.href)
}

function getParameterByNameFromPath(a, b) {
    a = a.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
    var c = (new RegExp("[\\?&]" + a + "=([^&#]*)")).exec(b);
    return null == c ? "" : decodeURIComponent(c[1].replace(/\+/g, " "))
}

function getQueryParameters(a, b) {
    var c = [];
    b || (b = window.location.href);
    a = a.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
    for (var e = new RegExp(a + "=([^&#]+)", "ig");;) {
        var d = e.exec(b);
        if (d && d[1]) c.push(d[1]);
        else break
    }
    return c.length ? 1 == c.length ? c[0] : c : null
}

function getDemoDocumentURN() {
    var a;
    switch (env) {
    case "Development":
        a = "urn:dXJuOmFkc2suczM6ZGVyaXZlZC5maWxlOnRyYW5zbGF0aW9uXzI1X3Rlc3RpbmcvRFdGL0Nhci5kd2Y=";
        break;
    case "Staging":
        a = "urn:dXJuOmFkc2suczM6ZGVyaXZlZC5maWxlOlZpZXdpbmdTZXJ2aWNlVGVzdEFwcC91c2Vycy9NaWNoYWVsX0hhbicvTU0zNTAwQXNzZW1ibHkuZHdm";
        break;
    case "Production":
        a = "FIXME";
        break;
    default:
        a = "urn:dXJuOmFkc2suczM6ZGVyaXZlZC5maWxlOnRyYW5zbGF0aW9uXzI1X3Rlc3RpbmcvRFdGL0Nhci5kd2Y="
    }
    return a
}

function stderr(a) {
    ENABLE_TRACE && console.log(a)
};